@ROUT ATL_ipsyr2k
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))

#ifdef Conj_
int Mjoin(PATL,ipher2k)
#else
int Mjoin(PATL,ipsyr2k)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
   const TYPE rbeta,
      #define IFLG 1
   #else
      #define IFLG 0
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   ablk2cmat_t blk2C_b0, blk2C_b1;
   ATL_SZT sz, szA, szB, nfnblks, nnblks, nkblks;
   unsigned int szC, MVS=0;
   TYPE *aC, *bC;  /* access- and block-major C */
   TYPE *aA, *aB;  /* access-major A & B */
   void (*syput)(ATL_CSZT N, const TYPE *D, const SCALAR beta0, TYPE *A, 
                 ATL_CSZT lda);
   void (*geputT)(ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
                  const SCALAR beta, TYPE *C, ATL_CSZT ldc);
   #ifdef TCPLX
      TYPE *aCr;
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero}, *ONE;
      #ifdef Conj_
         const TYPE beta[2]={rbeta, ATL_rzero};
      #endif
   #else
      #define ZERO ATL_rzero
      #define ONE ATL_rone
      #define aCr aC
   #endif
   ipinfo_t ip;
   #ifdef Conj_
      const enum ATLAS_TRANS TB = (TA == AtlasConjTrans) ? 
         AtlasNoTrans:AtlasConjTrans;
   #else
      const enum ATLAS_TRANS TB = (TA == AtlasTrans) ? 
         AtlasNoTrans:AtlasTrans;
   #endif
   if (!N)
      return(0);
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ONE(beta))
         return(0);
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return(0);
   }
   Mjoin(PATL,ipmenInfo)(&ip, TA, TB, N, N, K, lda, ldb, ldc, alpha, ZERO);
   blk2C_b0 = ip.blk2c;
   blk2C_b1 = ip.blk2c_b1;
   #ifdef TCPLX
      ONE = ip.ONE;
      #ifdef Conj_
         if (rbeta == ATL_rone)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b1):Mjoin(PATL,her2k_putL_b1));
            geputT = Mjoin(PATL,geput1H_b1);
         }
         else if (rbeta == ATL_rzero)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b0):Mjoin(PATL,her2k_putL_b0));
            geputT = Mjoin(PATL,geput1H_b0);
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_bXi0):Mjoin(PATL,her2k_putL_bXi0));
            geputT = (rbeta == ATL_rnone) ?  
               Mjoin(PATL,geput1H_bN) : Mjoin(PATL,geput1H_bX);
         }
      #else
         if (beta[1] == ATL_rzero) /* real beta */
         {
            const TYPE rb=(*beta);
            if (rb == ATL_rone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
               geputT = Mjoin(PATL,geput1T_b1);
            }
            else if (rb == ATL_rzero)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
               geputT = Mjoin(PATL,geput1T_b0);
            }
            else if (rb == ATL_rnone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_bn1):Mjoin(PATL,syr2k_putL_bn1));
               geputT = Mjoin(PATL,geput1T_bN);
            }
            else
            {
               syput = ((Uplo == AtlasUpper) ? 
                       Mjoin(PATL,syr2k_putU_bXi0):Mjoin(PATL,syr2k_putL_bXi0));
               geputT = Mjoin(PATL,geput1T_bX);
            }
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
            geputT = Mjoin(PATL,geput1T_bX);
         }
      #endif
   #else
      if (beta == ATL_rone)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
         geputT = Mjoin(PATL,geput1T_b1);
      }
      else if (beta == ATL_rzero)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
         geputT = Mjoin(PATL,geput1T_b0);
      }
      else
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
         geputT = (beta == ATL_rnone) ? 
            Mjoin(PATL,geput1T_bN) : Mjoin(PATL,geput1T_bX);
      }
   #endif
   nfnblks = ip.nfnblks;
   nnblks = nfnblks + ip.npnblks;
   nkblks = ip.nfkblks + 1;
/*
 * This algorithm requires allocating all of A & B + 2 blks for C 
 */
   szC = ip.szC;
   if (nnblks > 1)
   {
      szA = (nfnblks*ip.szA + ip.npnblks*ip.pszA)*nkblks;
      szB = (nfnblks*ip.szB + ip.npnblks*ip.pszB)*nkblks;
      MVS=3;
   }
   else if (nfnblks)
   {
     szA = ip.szA;
     szB = ip.szB;
   }
   else
   {
     szA = ip.pszA;
     szB = ip.pszB;
   }
   sz = ATL_MulBySize(szA+szB+szC+szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);

   bC = ATL_AlignPtr(vp);
   aC = bC + (szC SHIFT);
   aC = ATL_AlignPtr(aC);
   #ifdef TCPLX
     aCr = aC + szC;
     aA = aCr + szC;
   #else
      aA = aC + szC;
   #endif
   aA = ATL_AlignPtr(aA);
   aB = aA + (szA SHIFT);
   aB = ATL_AlignPtr(aB);
/*
 * Now, set sz[A,B] for incr workspace ptrs
 */
   if (nnblks > 1)
   {
      szA = ip.szA;
      szB = ip.szB;
      szA *= nkblks SHIFT;
      szB *= nkblks SHIFT;
   }
   else   /* just reusing same A/B space for 1 blk C! */
      szA = szB = 0;

   if (Uplo == AtlasLower)
   {
      ATL_iptr_t imsk = ~(0L);
      ATL_SZT j;
      ATL_CUINT NB = (nfnblks) ? ip.nb : ip.pnb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, wAj += szA, wBj += szB)
      {
         TYPE *wAi=wAj+szA, *wBi=wBj+szB;
         TYPE *pC = C;
         ATL_SZT incA, incB, i;
         ATL_UINT n;

         if (j < nfnblks)
         {
            n = NB;
            incA = ip.incAm & imsk;
            incB = ip.incBn & imsk;
         }
         else
         {
            n = ip.nF;
            incA = ip.pincAm & imsk;
            incB = ip.pincBn & imsk;
         }
/*
 *       First do diagonal block
 */
         ip.ldc = n;
         Mjoin(PATL,iploopsK)(&ip, j, j, A, B, bC, MVS, wAj, wBj, aCr, aC, 
                              ZERO, blk2C_b0);
         syput(n, bC, beta, pC, ldc);
         pC += n SHIFT;
         A += incA;
         B += incB;
         for (i=j+1; i < nnblks; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            if (i < nfnblks)
            {
               m = NB;
               incA = ip.incAm & imsk;
               incB = ip.incBn & imsk;
            }
            else
            {
               m = ip.mF;
               incA = ip.pincAm & imsk;
               incB = ip.incBn & imsk;
            }
            ip.ldc = n;
            Mjoin(PATL,iploopsK)(&ip, j, i, NULL, B, bC, 3, wAj, wBi, aCr, aC, 
                                 ZERO, blk2C_b0);
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            if (m == n)
            {
               Mjoin(PATL,iploopsK)(&ip, i, j, A, NULL, bC, 3, wAi, wBj, 
                                    aCr, aC, ONE, blk2C_b1);
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
            {
               ip.ldc = ldc;
               Mjoin(PATL,iploopsK)(&ip, i, j, A, NULL, pC, 3, wAi, wBj, 
                                    aCr, aC, ONE, blk2C_b1);
            }
            pC += m SHIFT;
            A += incA;
            B += incB;
         }
         A = NULL;
         B = NULL;
         imsk = 0L;
         C += NB*((ldc+1)SHIFT);
      }
   }
   else   /* C is symmetric matrix stored in Upper format */
   {
      ATL_CSZT incB = (nfnblks) ? ip.incBn : ip.pincBn;
      ATL_CSZT incA = (nfnblks) ? ip.incAm : ip.pincAm;
      ATL_SZT j;
      ATL_CUINT NB = (nfnblks) ? ip.nb : ip.pnb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += NB*(ldc SHIFT), wAj += szA, wBj += szB)
      {
         const TYPE *aa=A, *bb=B;
         TYPE *wAi=aA, *wBi=aB;
         TYPE *pC = C;
         ATL_SZT i, incA;
         ATL_UINT n;

         if (j < nfnblks)
         {
            n = NB;
            incA = ip.incAm;
         }
         else
         {
            n = ip.nF;
            incA = ip.pincAm;
         }
         for (i=0; i < j; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            ip.ldc = n;
            Mjoin(PATL,iploopsK)(&ip, j, i, aa, NULL, bC, 3, wAj, wBi, aCr, aC,
                                 ZERO, blk2C_b0);
            aa = NULL;
            if (i < nfnblks)
               m = NB;
            else
               m = ip.mF;
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);

            if (m == n)
            {
               Mjoin(PATL,iploopsK)(&ip, i, j, NULL, bb, bC, 3, wAi, wBj,
                                    aCr, aC, ONE, blk2C_b1);
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
            {
               ip.ldc = ldc;
               Mjoin(PATL,iploopsK)(&ip, i, j, NULL, bb, pC, 3, wAi, wBj,
                                    aCr, aC, ONE, blk2C_b1);
            }
            bb = NULL;
            pC += m SHIFT;
         }
/*
 *       Do diagonal block to copy new A block
 */
         ip.ldc = n;
         Mjoin(PATL,iploopsK)(&ip, j, j, aa, bb, bC, MVS, wAj, wBj, aCr, aC,
                              ZERO, blk2C_b0);
         syput(n, bC, beta, pC, ldc);
         B += incB;
         A += incA;
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_opsyr2k
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#ifdef Conj_
   #define syr2k_OP Mjoin(PATL,opher2k)
#else
   #define syr2k_OP Mjoin(PATL,opsyr2k)
#endif

int syr2k_OP
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
   const TYPE rbeta,
      #define IFLG 1
   #else
      #define IFLG 0
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   ablk2cmat_t blk2C_b0, blk2C_b1;
   ATL_SZT sz, szA, szB, nfnblks, nnblks;
   unsigned int szC;
   unsigned int mb, nb, KB;
   TYPE *aC, *bC;  /* access- and block-major C */
   TYPE *aA, *aB;  /* access-major A & B */
   void (*syput)(ATL_CSZT N, const TYPE *D, const SCALAR beta0, TYPE *A, 
                 ATL_CSZT lda);
   void (*geputT)(ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
                  const SCALAR beta, TYPE *C, ATL_CSZT ldc);
   #ifdef TCPLX
      TYPE *aCr;
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero}, *ONE;
      #ifdef Conj_
         const TYPE beta[2]={rbeta, ATL_rzero};
      #endif
   #else
      #define ZERO ATL_rzero
      #define ONE ATL_rone
      #define aCr aC
   #endif
   opinfo_t op;

   if (!N)
      return(0);
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ONE(beta))
         return(0);
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return(0);
   }
   if (K < 3)
   {
      #if !defined(TCPLX) || defined(Conj_)
         #ifdef Conj_
         if (K == 1 && rbeta == ATL_rone && TA == AtlasNoTrans)
         #else
         if (K == 1 && SCALAR_IS_ONE(beta))
         #endif
         {
            ATL_SZT incA, incB;
            if (TA == AtlasTrans || TA == AtlasConjTrans)
            {
               incA = lda;
               incB = ldb;
            }
            else
            {
               incA = 1;
               incB = 1;
            }
            #ifdef Conj_
               Mjoin(PATL,her2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #else
               Mjoin(PATL,syr2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #endif
            return(0);
         }
      #endif
      #ifdef Conj_
         Mjoin(PATL,refher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              rbeta, C, ldc);
      #else
         Mjoin(PATL,refsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              beta, C, ldc);
      #endif
      return(0);
   }
   blk2C_b0 = Mjoin(PATL,opsyr2kInfo)(&op, IFLG, TA, N, K, lda, ldb, ldc, 
                                      alpha, beta);
   if (!blk2C_b0)
      return(2);
   blk2C_b1 = op.blk2C;
   KB = op.KB;
   #ifdef TCPLX
      ONE = op.ONE;
      #ifdef Conj_
         if (rbeta == ATL_rone)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b1):Mjoin(PATL,her2k_putL_b1));
            geputT = Mjoin(PATL,geput1H_b1);
         }
         else if (rbeta == ATL_rzero)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b0):Mjoin(PATL,her2k_putL_b0));
            geputT = Mjoin(PATL,geput1H_b0);
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_bXi0):Mjoin(PATL,her2k_putL_bXi0));
            geputT = (rbeta == ATL_rnone) ?  
               Mjoin(PATL,geput1H_bN) : Mjoin(PATL,geput1H_bX);
         }
      #else
         if (beta[1] == ATL_rzero) /* real beta */
         {
            const TYPE rb=(*beta);
            if (rb == ATL_rone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
               geputT = Mjoin(PATL,geput1T_b1);
            }
            else if (rb == ATL_rzero)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
               geputT = Mjoin(PATL,geput1T_b0);
            }
            else if (rb == ATL_rnone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_bn1):Mjoin(PATL,syr2k_putL_bn1));
               geputT = Mjoin(PATL,geput1T_bN);
            }
            else
            {
               syput = ((Uplo == AtlasUpper) ? 
                       Mjoin(PATL,syr2k_putU_bXi0):Mjoin(PATL,syr2k_putL_bXi0));
               geputT = Mjoin(PATL,geput1T_bX);
            }
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
            geputT = Mjoin(PATL,geput1T_bX);
         }
      #endif
   #else
      if (beta == ATL_rone)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
         geputT = Mjoin(PATL,geput1T_b1);
      }
      else if (beta == ATL_rzero)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
         geputT = Mjoin(PATL,geput1T_b0);
      }
      else
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
         geputT = (beta == ATL_rnone) ? 
            Mjoin(PATL,geput1T_bN) : Mjoin(PATL,geput1T_bX);
      }
   #endif
   nfnblks = op.nfnblks;
   nnblks = nfnblks + op.npnblks;
   if (nfnblks) 
      mb = nb = op.nb;
   else
   {
      mb = op.pmb;
      nb = op.pnb;
   }
/*
 * This algorithm requires allocating all of A & B + 2 blks for C 
 */
   szC = op.szC;
   szA = nfnblks*op.szA + op.npnblks*op.pszA;
   szB = nfnblks*op.szB + op.npnblks*op.pszB;
   sz = ATL_MulBySize(szA+szB+szC+szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);

   bC = ATL_AlignPtr(vp);
   aC = bC + (szC SHIFT);
   aC = ATL_AlignPtr(aC);
   #ifdef TCPLX
     aCr = aC + szC;
     aA = aCr + szC;
   #else
      aA = aC + szC;
   #endif
   aA = ATL_AlignPtr(aA);
   aB = aA + (szA SHIFT);
   aB = ATL_AlignPtr(aB);
   szB = (nfnblks) ? (op.szB SHIFT) : 0;  /* inc between B blks */
   szA = (nfnblks) ? (op.szA SHIFT) : 0;

   if (Uplo == AtlasLower)
   {
      ATL_SZT j;
      ATL_CUINT NB = op.nb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += nb*((ldc+1)SHIFT), wAj += szA, wBj += szB)
      {
         TYPE *wAi=wAj+szA, *wBi=wBj+szB;
         TYPE *pC = C;
         ATL_SZT i;
         ATL_UINT nb, n;

         if (j < nfnblks)
            nb = n = NB;
         else
         {
            nb = op.pnb;
            n = op.nF;
         }
/*
 *       First do diagonal block
 */
         Mjoin(PATL,opblk)(&op, j, j, A, B, NULL, wAj, wAj, 
                           wBj, wBj+szB, aCr, aC);
         #ifdef TCPLX
            blk2C_b0(n, n, ONE, aCr, aC, ZERO, bC, n);
         #else
            blk2C_b0(n, n, ONE, aC, ZERO, bC, n);
         #endif
         syput(n, bC, beta, pC, ldc);
         pC += n SHIFT;
         for (i=j+1; i < nnblks; i++, wAi += szA, wBi += szB)
         {
            ATL_CSZT in = (i < nnblks-1) ? i+1 : 0;
            ATL_UINT mb, m;
            if (i < nfnblks)
               mb = m = NB;
            else
            {
               mb = op.pmb;
               m = op.mF;
            }
            Mjoin(PATL,opblk)(&op, j, i, NULL, B, NULL, wAj, wAi, 
                              wBi, wBj, aCr, aC);
            #ifdef TCPLX
               blk2C_b0(n, m, ONE, aCr, aC, ZERO, bC, n);
            #else
               blk2C_b0(n, m, ONE, aC, ZERO, bC, n);
            #endif
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            Mjoin(PATL,opblk)(&op, i, j, A, NULL, NULL, wAi, wAj+szA, 
                              wBj, wBi+szB, aCr, aC);
            if (m == n)
            {
               #ifdef TCPLX
                  blk2C_b1(n, n, ONE, aCr, aC, ONE, bC, n);
               #else
                  blk2C_b1(n, n, ONE, aC, ONE, bC, n);
               #endif
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
               #ifdef TCPLX
                  blk2C_b1(m, n, ONE, aCr, aC, ONE, pC, ldc);
               #else
                  blk2C_b1(m, n, ONE, aC, ONE, pC, ldc);
               #endif
            pC += m SHIFT;
         }
         A = NULL;
         B = NULL;
      }
   }
   else
   {
      ATL_SZT j;
      ATL_CUINT NB = Mmin(mb,nb);
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += nb*(ldc SHIFT), wAj += szA, wBj += szB)
      {
         const TYPE *aa=A, *bb=B;
         TYPE *wAi=aA, *wBi=aB;
         TYPE *pC = C;
         ATL_SZT i;
         ATL_UINT n;

         if (j < nfnblks)
            nb = n = NB;
         else
         {
            nb = op.pnb;
            n = op.nF;
         }
         for (i=0; i < j; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            if (i < nfnblks)
               mb = m = NB;
            else
            {
               mb = op.pmb;
               m = op.mF;
            }
            Mjoin(PATL,opblk)(&op, j, i, aa, NULL, NULL, wAj, wAi,
                              wBi, wBj, aCr, aC);
            aa = NULL;
            #ifdef TCPLX
               blk2C_b0(n, m, ONE, aCr, aC, ZERO, bC, n);
            #else
               blk2C_b0(n, m, ONE, aC, ZERO, bC, n);
            #endif
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            Mjoin(PATL,opblk)(&op, i, j, NULL, bb, NULL, wAi, wAj+szA,
                              wBj, wBi+szB, aCr, aC);
            bb = NULL;
            if (m == n)
            {
               #ifdef TCPLX
                  blk2C_b1(n, n, ONE, aCr, aC, ONE, bC, n);
               #else
                  blk2C_b1(n, n, ONE, aC, ONE, bC, n);
               #endif
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
               #ifdef TCPLX
                  blk2C_b1(m, n, ONE, aCr, aC, ONE, pC, ldc);
               #else
                  blk2C_b1(m, n, ONE, aC, ONE, pC, ldc);
               #endif
            pC += m SHIFT;
         }
/*
 *       Do diagonal block to copy new A block
 */
         Mjoin(PATL,opblk)(&op, j, j, aa, bb, NULL, wAj, wAj,
                           wBj, wBj+szB, aCr, aC);
         #ifdef TCPLX
            blk2C_b0(n, n, ONE, aCr, aC, ZERO, bC, n);
         #else
            blk2C_b0(n, n, ONE, aC, ZERO, bC, n);
         #endif
         syput(n, bC, beta, pC, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_syr2k
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#ifdef Conj_
   #define SYR2K Mjoin(PATL,her2k)
   #define IFLG 4
#else
   #define SYR2K Mjoin(PATL,syr2k)
   #define IFLG 0
#endif
#ifdef Conj_
int Mjoin(PATL,opher2k_wrap)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   return(Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              *beta, C, ldc));
}
#else
typedef int (*syr2k_t)(const enum ATLAS_UPLO, const enum ATLAS_TRANS, 
                       ATL_CSZT, ATL_CSZT, const SCALAR, 
                       const TYPE*, ATL_CSZT, const TYPE*, ATL_CSZT, 
                       const SCALAR, TYPE*, ATL_CSZT);
void Mjoin(PATL,syr2k_rec)
(
   ATL_CUINT bv, /* 0:Upper?, 1:Transpose?, 2:HER2K? */
   ATL_CSZT  N,
   ATL_CSZT K,  /* if NoTrans, ncols of A&B, else nrows A&B */
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc,
   void *syr2kOP
)
{
   const enum ATLAS_UPLO UL=(bv&1) ? AtlasUpper:AtlasLower;
   #ifdef TCPLX
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      enum ATLAS_TRANS TA;
      if (bv&4)
         TA = (bv&2) ? AtlasConjTrans : AtlasNoTrans;
      else
         TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
      #define ONE ATL_rone
   #endif
   if (N == 1)  /* can use dot product! */
   {
      ATL_SZT incA, incB;
      if (bv&2) /* K is rows */
      {
         incA = 1;
         incB = 1;
      }
      else
      {
         incA = lda;
         incB = ldb;
      }
      #ifdef TCPLX
         if (bv&4) /* dotc */
         {
            TYPE dot[2];
            register TYPE rd;
            const register TYPE ra=(*alpha), ia=alpha[1], rb=(*beta);
            if (incA == 1 && incB == 1 && ia == ATL_rzero)
            {
               rd = Mjoin(PATLU,dot)(K+K, A, incA, B, incB);
               rd *= ra;
            }
            else
            {
               register TYPE id;
               Mjoin(PATL,dotc_sub)(K, A, incA, B, incB, dot);
               rd = *dot;
               id = dot[1];
               if (bv&2)
                  rd = rd*ra - id*ia;
               else
                  rd = rd*ra + id*ia;
            }
            rd += rd;
            if (rb == ATL_rzero)
               *C = rd;
            else
               *C = *C * rb + rd;
            C[1] = ATL_rzero;
         }
         else /* dotu */
         {
            TYPE dot[2];
            register TYPE rc, ic, rd, id;
            const register TYPE ra=(*alpha),ia=alpha[1], rb=(*beta),ib=beta[1];
            Mjoin(PATL,dotu_sub)(K, A, incA, B, incB, dot);
            rd = *dot;
            id = dot[1];
            rc = rd*ra - id*ia;  /* multiply by alpha */
            ic = rd*ia + id*ra;
            rc += rc;            /* double it */
            ic += ic;
            if (rb != ATL_rzero || ib != ATL_rzero)  /* apply beta to C */
            {                                        /* and add into answer */
               rd = *C;
               id = C[1];
               rc += rb*rd - ib*id;
               ic += rb*id + ib*rd;
            }
            *C = rc;
            C[1] = ic;
         }
      #else
         TYPE dot;
         dot = Mjoin(PATL,dot)(K, A, incA, B, incB);
         dot *= alpha;
         dot += dot;
         if (beta == ATL_rzero)
            *C = dot;
         else
            *C = *C * beta + dot;
      #endif
       return;
   }
/*
 * If K small enough, need the outer-product version of syrk
 */
   if (K <= ATL_VWopgen_MAX_KB)
   {
      syr2k_t opsyr2k = syr2kOP;
      if (!opsyr2k(UL, TA, N, K, alpha, A, lda, B, ldb, beta, C, ldc))
         return;
   }
/*
 * Try the inner product version for any case outer-product fails on
 */
   {
      #ifdef TCPLX
      if (bv&4)
      {
         if (!Mjoin(PATL,ipher2k)(UL, TA, N, K, alpha, A, lda, B, ldb, 
                                  *beta, C, ldc));
            return;
      }
      else
      #endif
      {
         if (!Mjoin(PATL,ipsyr2k)(UL, TA, N, K, alpha, A, lda, B, ldb, 
                                  beta, C, ldc));
            return;
      }
   }
/*
 *    Splitting K or N reduces mem req by same amount, so split largest.
 *    When we split along N, we wind up with two syr2k calls, and two calls 
 *    to GEMM.
 */
      if (N >= K)
      {
         ATL_SZT NL=N>>1, NR=N-NL;
         const TYPE *an, *bn;
         enum ATLAS_TRANS TA, TB;
         if (bv&2) /* A & B are KxN */
         {
            an = A + (NL SHIFT)*lda;
            bn = B + (NL SHIFT)*ldb;
            #ifdef TCPLX
               TA = (bv&4) ? AtlasConjTrans:AtlasTrans;
            #else
               TA = AtlasTrans;
            #endif
               TB = AtlasNoTrans;
         }
         else      /* A & B are NxK */
         {
            TA = AtlasNoTrans;
            #ifdef TCPLX
               TB = (bv&4) ? AtlasConjTrans:AtlasTrans;
            #else
               TB = AtlasTrans;
            #endif
            an = A + (NL SHIFT);
            bn = B + (NL SHIFT);
         }
         Mjoin(PATL,syr2k_rec)(bv, NL, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc, syr2kOP);
         Mjoin(PATL,syr2k_rec)(bv, NR, K, alpha, an, lda, bn, ldb, 
                               beta, C+((ldc+1)SHIFT)*NL, ldc, syr2kOP);
         if (bv&1) /* Upper */
         {
            C += ldc*(NL SHIFT);
            Mjoin(PATL,ammm)(TA, TB, NL, NR, K, alpha, A, lda, bn, ldb, 
                             beta, C, ldc);
            Mjoin(PATL,ammm)(TA, TB, NL, NR, K, alpha, B, ldb, an, lda, 
                             ONE, C, ldc);
         }
         else
         {
            C += (NL SHIFT);
            Mjoin(PATL,ammm)(TA, TB, NR, NL, K, alpha, an, lda, B, ldb, 
                             beta, C, ldc);
            Mjoin(PATL,ammm)(TA, TB, NR, NL, K, alpha, bn, ldb, A, lda, 
                             ONE, C, ldc);
         }
         return;
      }
/*
 * If we reach here, split K, resulting in 2 syr2k, 2nd with BETA=ONE
 */
   {
      ATL_SZT KL=(K>>1), KR = K - KL;
      Mjoin(PATL,syr2k_rec)(bv, N, KL, alpha, A, lda, B, ldb, 
                            beta, C, ldc, syr2kOP);
      #ifdef TCPLX
         KL += KL;
      #endif
      if (bv&2)  /* K controls rows of A&B */
      {
         A += KL;
         B += KL;
      }
      else       /* K controls cols of A&B */
      {
         A += KL * lda;
         B += KL * ldb;
      }
      Mjoin(PATL,syr2k_rec)(bv, N, KR, alpha, A, lda, B, ldb, ONE, C, ldc, 
                            syr2kOP);
   }
}
   #ifndef TCPLX
      #undef ONE
   #endif
#endif
void SYR2K
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
      const TYPE rbeta,
   #else
      const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp;
   #ifdef Conj_
      const TYPE beta[2] = {rbeta, ATL_rzero};
   #endif
   ATL_UINT bv;
   if (!N)
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      #ifdef Conj_
         if (rbeta == ATL_rone)
            return;
      #else
         if (SCALAR_IS_ONE(beta))
            return;
      #endif
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return;
   }
/*
 * Outer-product syr2k handles degenerate K, along with any 1-block K
 */
   if (K < 3) /* ATL_VWopgen_MAX_KB) */
   #ifdef Conj_
      if (!Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               rbeta, C, ldc))
         return;
      vp = Mjoin(PATL,opher2k_wrap);
      bv = 4;
      if (TA == AtlasConjTrans)
         bv |= 2;
   #else
      if (!Mjoin(PATL,opsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc))
         return;
      vp = Mjoin(PATL,opsyr2k);
      bv = 0;
      #ifdef TCPLX
         if (TA == AtlasTrans) 
      #else
         if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
            bv |= 2;
   #endif
   bv |= (Uplo == AtlasUpper);
   Mjoin(PATL,syr2k_rec)(bv, N, K, alpha, A, lda, B, ldb, beta, C, ldc, vp);
}
@ROUT ATL_sqsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk)
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrkBlk Mjoin(PATL,sqherkBlk)
   #define syrk_K  Mjoin(PATL,sqherk_KLoop)
   #define syrk  Mjoin(PATL,sqherk)
#else
   #define syrkBlk Mjoin(PATL,sqsyrkBlk)
   #define syrk_K  Mjoin(PATL,sqsyrk_KLoop)
   #define syrk  Mjoin(PATL,sqsyrk)
#endif
/*#define MEM_DEBUG 1*/

void syrkBlk
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   size_t k,      /* which K block of A is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c && non-NULL, which C to write to */
   TYPE *rS,      /* real portion of wS (unused for real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real portion of wC (unused for real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* reflection space for Upper if non-NULL */
)
{
   ATL_CUINT kb = (k != ip->nfkblks) ? ip->kb : ip->kb0;
   ATL_UINT nb, kbS, nnu;
   size_t nfblks = ip->nfnblks;
   #ifdef TCPLX
      TYPE *rA, *rB;
   #endif
   if (d == nfblks + ip->npnblks - 1)
   {
      nb = ip->nF;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + ip->szA;
            rB = wB + ip->szB;
         }
         else
         {
            rA = wA + ip->pszA;
            rB = wB + ip->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = ip->nb;
      #ifdef TCPLX
         rA = wA + ip->szA;
         rB = wB + ip->szB;
      #endif
   }
   else
   {
      nb = ip->pnb;
      #ifdef TCPLX
         rA = wA + ip->pszA;
         rB = wB + ip->pszB;
      #endif
   }
   nnu = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   if (A)  /* want to copy input array */
   {
      A = IdxA_ip(ip, A, d, k);
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, rA, wA);
         #else
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, wA);
         #endif
         if (ip->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, rB, wB);
         #else
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, wB);
         #endif
         if (ip->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, ip->ONE, A, ip->lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, ip->lda, wS);
         #endif
      }
   }
   if (wC && wS)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         if (flag&4)
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
         else
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=ip->ldc;
      #ifdef TCPLX
         const TYPE *alp = ip->alpC;
      #else
         TYPE alp = ip->alpC;
      #endif
      if (ip->alpA != ip->alpB)
         alp = (ip->alpA != ip->alpC) ? ip->alpA : ip->alpB;
      if (C)
      {
         C = IdxC_ip(ip, C, d, d);
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
   #if 0
   if ((flag&1) && C && wU)  /* need to reflect from Lower to Upper */
   {
      size_t ldc2=(ip->ldc)SHIFT;
      #ifdef Conj_
         for (k=0; k < nb; k++, C += ldc2, wU += 2)
         {
            Mjoin(PATL,axpbyConj)(k+1, ip->ONE, wU, nb, beta, C, 1);
            C[((k+1)<<1)-1] = ATL_rzero;
         }
      #else
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, ip->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
      #endif
   }
   #endif
}

/*
 * This helper function computes one block of C by looping over the K dim.
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 */
void syrk_K  /* inner-product based syrk/herk loop over K loop */
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real portion of wS (unused in real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *rC,      /* real portion of wC (unused in real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   const size_t nfkblks = ip->nfkblks;
   size_t k;
   ATL_UINT szA, szB;
   if (d < ip->nfnblks)
      szA = szB = ip->szA;
   else
   {
      szA = ip->pszA;
      szB = ip->pszB;
   }
   #ifdef TCPLX
      szA += szA;
      szB += szB;
   #endif
/*
 * For first K block, use beta=0 kernel to init wC
 */
   if (nfkblks)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, NULL, beta, NULL, rS, wS,
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
   else /* this is first & last block! */
   {
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, blk2c, beta, C, rS, wS,
              wA, wA, wB, wB, rC, wC, wU);
      return;
   }
/*
 * Handle all blocks except first (handled above) & last (handled below)
 */
   for (k=1; k < nfkblks; k++)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag, d, k, A, sy2blk, NULL, beta, NULL, rS, wS,
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
/*
 * Last block actually writes to C
 */
   syrkBlk(ip, flag, d, k, A, sy2blk, blk2c, beta, C, rS, wS,
           wA, wA, wB, wB, rC, wC, wU);
}

int syrk
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   void *vp=NULL;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int ierr;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;
   ipinfo_t ip;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   Mjoin(PATL,ipmenInfo)(&ip, TA, TB, N,N,K, lda, lda, ldc, alpha, beta);
   #if 0
   printf("D=(%u,%u), B=(%u,%u,%u), b=(%u,%u,%u), nB=(%u,%u,%u)\n",
          (unsigned int)N,(unsigned int)K, ip.mb, ip.nb, ip.kb,
          ip.pmb, ip.pnb, ip.kb0, ip.nfmblks, ip.nfnblks, ip.nfkblks);
   #endif
/*
 * Will eventually need syrk timed for all square blocks to select best case.
 * For now, just pretend syrk time doesn't matter
 */
/*
 * Need space for only one column-panel of At
 */
   szB = ip.nfnblks ? ip.szA : ip.pszA;
   szB *= (ip.nfkblks+1);
/*
 * A needs entire matrix minus one row/col panel
 */
   szA = szB * (ip.nfnblks + ip.npnblks - 1);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   nbS = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SYRKK_NU;
   szC *= ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
          * ATL_SYRKK_VLEN;
   extra = ip.exsz;
   extra = Mmax(extra, (ATL_SYRKK_NU+ATL_SYRKK_NU)*ATL_SYRKK_NU);
   szS = ((ip.kb + ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   szS *= nbS;
   sz = Mmax(ip.szC,szC);
   sz = ATL_MulBySize(sz + szS + szA+szB + extra) + 5*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szB SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   if (!szA)
      wA = NULL;
   wCs = wC;
   #ifdef TCPLX
      rC = wC + ip.szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rCs = rC = wC;
      rS = wS;
   #endif
/*
 * ============================================================================
 * First, we compute diagonals of C, and in the process we will copy A/A^T
 * for use in computing non-diaginal blocks using inner-product amm.
 * ============================================================================
 */
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_syrkT) : Mjoin(PATL,a2blk_syrkN);

   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
   }
   nnblks = ip.nfnblks + ip.npnblks;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
/*
 * Upper doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   if (Uplo == AtlasUpper)
   {
      flg |= 1;
      syrk_K(&ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL,
             rCs, wC, wCs);
      if (N > nb)
      {
         const size_t incC = nb*((ldc+1)SHIFT);
         size_t i;
/*
 *       Compute all C blks within this rowpan of C, copy rest of At
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsNK)(&ip, 0, 1, NULL, A, C, 11, wB, wA, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         for (i=1; i < nnblks-1; i++)
         {
            syrk_K(&ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL,
                   rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsNK)(&ip, i, i+1, NULL, NULL, C+i*(nb SHIFT), 11,
                                  wB, wA, rC, wC, beta, blk2c);
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(&ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, NULL,
                rCs, wC, wCs);
      }
   }
/*
 * Lower doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   else
   {
      const size_t incC = (ldc SHIFT) * nb;
      size_t j;
      TYPE *c;
/*
 *    Compute first diag block, copying At to wB for use by all of this colpan
 *    of C's gemm computation
 */
      syrk_K(&ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, wB,
             rCs, wC, wCs);
      if (N > nb)
      {
/*
 *       Compute all C blks within this colpan of C, copying rest of A
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsMK)(&ip, 1, 0, A, NULL, C, 7, wA, wB, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         c = C + incC;
         for (j=1; j < nnblks-1; j++)
         {
            syrk_K(&ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS,
                   NULL, wB, rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsMK)(&ip, j+1, j, NULL, NULL, c, 7, wA, wB, rC, wC,
                                  beta, blk2c);
            c += incC;
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(&ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS,
                NULL, NULL, rCs, wC, wCs);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_umsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_umsyrk.h))
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk)
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrkBlk Mjoin(PATL,umherkBlk)
   #define syrk_K  Mjoin(PATL,umherk_KLoop)
   #define syrk  Mjoin(PATL,umherk)
#else
   #define syrkBlk Mjoin(PATL,umsyrkBlk)
   #define syrk_K  Mjoin(PATL,umsyrk_KLoop)
   #define syrk  Mjoin(PATL,umsyrk)
#endif
/*#define MEM_DEBUG 1*/

void syrkBlk
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans*/
   size_t d,      /* which global diagonal blk of C is being computed */
   size_t k,      /* which K block of A is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   const TYPE *B, /* if non-NULL, base A ptr to copy */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c && non-NULL, which C to write to */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real portion of wC (unused for real routines) */
   TYPE *wC      /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   ATL_CUINT kb = (k != ip->nfkblks) ? ip->kb : ip->kb0;
   ATL_UINT mb, nb, kbS, nnu, nmu;
   size_t nfblks = ip->nfnblks;
   #ifdef TCPLX
      TYPE *rA, *rB;
   #endif
   if (d == nfblks + ip->npnblks - 1)
   {
      nb = ip->nF;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + ip->szA;
            rB = wB + ip->szB;
         }
         else
         {
            rA = wA + ip->pszA;
            rB = wB + ip->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = ip->nb;
      #ifdef TCPLX
         rA = wA + ip->szA;
         rB = wB + ip->szB;
      #endif
   }
   else
   {
      nb = ip->pnb;
      #ifdef TCPLX
         rA = wA + ip->pszA;
         rB = wB + ip->pszB;
      #endif
   }
/*
 * calc nmu and nnu. one must be multiple of other
 */
   if (ip->mu > ip->nu)
   {
      nmu = (nb+ip->mu-1)/ip->mu;
      nnu = nmu * (ip->mu/ip->nu); /* NU must be multiple of MU */
   }
   else
   {
      nnu = (nb+ip->nu-1)/ip->nu;
      nmu = nnu * (ip->nu/ip->mu); /* NU must be multiple of MU */
   }
   kbS = ((kb+ip->ku-1)/ip->ku)*ip->ku; /* same as KB0 */
/*
 * copy A
 */
   if (A)  /* want to copy input array */
   {
      A = IdxA_ip(ip, A, d, k);
      #ifdef TCPLX
         ip->a2blk(kb, nb, ip->alpA, A, ip->lda, rA, wA);
      #else
         ip->a2blk(kb, nb, ip->alpA, A, ip->lda, wA);
      #endif
   }
   if (B)
   {
      B = IdxB_ip(ip, B, k, d);
      #ifdef TCPLX
         ip->b2blk(kb, nb, ip->alpB, B, ip->ldb, rB, wB);
      #else
         ip->b2blk(kb, nb, ip->alpB, B, ip->ldb, wB);
      #endif
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         if (flag&4)
         {
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         }
         else
         {
            Mjoin(PATL,amsyrkK_bn)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
            Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         }
         Mjoin(PATL,amsyrkK_bn)(nmu, nnu, kbS, rA, rB, rC, wA, rB, wC);
         Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, wA, rB, wC, wA, wB, wC);
      #else
         if (flag&4)
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
         else
            Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=ip->ldc;
      #ifdef TCPLX
         const TYPE *alp = ip->alpC;
      #else
         TYPE alp = ip->alpC;
      #endif
      if (ip->alpA != ip->alpB)
         alp = (ip->alpA != ip->alpC) ? ip->alpA : ip->alpB;
      if (C)
      {
         C = IdxC_ip(ip, C, d, d);
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
}

void syrk_K  /* inner-product based syrk/herk loop over K loop */
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans*/
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   const TYPE *B, /* if non-NULL, base B ptr to copy */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *rC,      /* real portion of wC (unused in real routines) */
   TYPE *wC       /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   const size_t nfkblks = ip->nfkblks;
   size_t k;
   ATL_UINT szA, szB;
   if (d < ip->nfnblks)
   {
      /*szA = szB = ip->szA;*/
      szA = ip->szA;
      szB = ip->szB;
   }
   else
   {
      szA = ip->pszA;
      szB = ip->pszB;
   }
   #ifdef TCPLX
      szA += szA;
      szB += szB;
   #endif
/*
 * For first K block, use beta=0 kernel to init wC
 */
   if (nfkblks)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag|4, d, 0, A, B, NULL, beta, NULL, wA,wAn, wB,wBn,
                 rC, wC);
      wA = wAn;
      wB = wBn;
   }
   else /* this is first & last block! */
   {
      syrkBlk(ip, flag|4, d, 0, A, B, blk2c, beta, C, wA, wA, wB, wB,
                rC, wC);
      return;
   }
/*
 * Handle all blocks except first (handled above) & last (handled below)
 */
   for (k=1; k < nfkblks; k++)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag, d, k, A, B, NULL, beta, NULL, wA, wAn, wB, wBn,
                rC, wC);
      wA = wAn;
      wB = wBn;
   }
/*
 * Last block actually writes to C
 */
   syrkBlk(ip, flag, d, k, A, B, blk2c, beta, C, wA,wA, wB,wB, rC,wC);
}

int syrk
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   void *vp=NULL;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int k, ierr;
   ablk2cmat_t blk2sy, blk2c;
   ipinfo_t ip;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
#ifdef MEM_DEBUG
   void *vA=NULL, *vB=NULL, *vC=NULL;
#endif
   Mjoin(PATL,ipmenUMInfo)(&ip, TA, TB, N,N,K, lda, lda, ldc, alpha, beta);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   nnblks = ip.nfnblks + ip.npnblks;
/*
 * Main idea:
 * 1. with syrk+gemm of full blks, syrk can always reuse the workspace of gemm
 *    no need to allocate extra space for syrk
 * 2. syrk only: need to allocate only considering the syrk
 */
/*
 * Need space for only one column-panel of At
 */
   szB = ip.nfnblks ? ip.szA : ip.pszA;
   szB *= (ip.nfkblks+1);
/*
 * space calc for single syrk block
 */
   if (nnblks == 1)    /* single blk in n-dimension: syrk only*/
   {
      int smnu=(ip.mu > ip.nu)?ip.mu:ip.nu; /* max of mu, nu*/
      nbS = (nb+smnu-1)/smnu;
      szC = ((nbS+1)*nbS)>>1;
      nbS *= smnu;
/*
 *    considering mu and nu as one is multiple of other, the size of subblock
 *    is smnu*smnu (rounded with ku).
 */
      szC *= ((smnu*smnu+ip.ku-1)/ip.ku)*ip.ku;
      szS =  ((ip.kb+ip.ku-1)/ip.ku)*ip.ku;
      szA = nbS * szS * (ip.nfkblks + 1);
      extra = (smnu+smnu)*smnu;  /* may not need */
   }
   else
   {
/*
 *    A needs entire matrix minus one row/col panel
 */
      szA = szB * (ip.nfnblks + ip.npnblks - 1);
      szC = ip.szC;
      extra = ip.exsz;
   }
#ifdef MEM_DEBUG
/*
 * DEBUG: to debug, I allocate memory individually.... so that I can use
 * valgrind to find out of memory access error
 */
   sz = ATL_MulBySize(szA) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vA = malloc(sz);
   if (!vA)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vA);

   sz = ATL_MulBySize(szB) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vB = malloc(sz);
   if (!vB)
      return(1);  /* keep recurring, can't malloc space! */
   wB = ATL_AlignPtr(vB);

   sz = ATL_MulBySize(szC + extra) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vC = malloc(sz);
   if (!vC)
      return(1);  /* keep recurring, can't malloc space! */
   wC = ATL_AlignPtr(vC);
#else
/*
 * use it for timing to reduce mulitple malloc.
 */
   sz = ATL_MulBySize(szC + szA+szB + extra) + 5*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wC = wB + (szB SHIFT);
   wC = ATL_AlignPtr(wC);
#endif
   #ifdef TCPLX
      rC = wC + szC;
   #else
      rC = wC;
   #endif
/*
 * ============================================================================
 * First, we compute diagonals of C, and in the process we will copy A/A^T
 * for use in computing non-diaginal blocks using inner-product amm.
 * ============================================================================
 */
   flg = (TA == AtlasNoTrans) ? 2 : 0;
/*
 * NOTE: alpha may be already applied on A-copy. So, use ip.alpC instead of
 * alpha to select appropriate copy routines
 */
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(ip.alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip.alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
   }
/*
 * syrk-upper
 */
   if (Uplo == AtlasUpper)
   {
      flg |= 1;
/*
 *    1st syrk: copies both formats, no reuse
 */
      syrk_K(&ip, flg, 0, A, A, blk2sy, beta, C, wB, wA, rC, wC);
      if (N > nb)
      {
         const size_t incC = nb*((ldc+1)SHIFT);
         size_t i;
/*
 *       Compute all C blks within this rowpan of C, copies B (At), reuse A
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsNK)(&ip, 0, 1, NULL, A, C, 11, wB, wA, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         for (i=1; i < nnblks-1; i++)
         {
/*
 *          syrk copies A and reuses B copy
 */
            syrk_K(&ip, flg, i, A, NULL, blk2sy, beta, C, wB, wA,
                          rC, wC);
            wA += szB SHIFT;
/*
 *          gemm can reuse both the copies
 */
            Mjoin(PATL,iploopsNK)(&ip, i, i+1, NULL, NULL, C+i*(nb SHIFT), 11,
                                  wB, wA, rC, wC, beta, blk2c);
         }
/*
 *       Last colpan is only 1 diag blk
 */
         syrk_K(&ip, flg, i, A, NULL, blk2sy, beta, C, wB, wA,
                       rC, wC);
      }
   }
/*
 * Lower doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   else
   {
      const size_t incC = (ldc SHIFT) * nb;
      size_t j;
      TYPE *c;
/*
 *    Compute first diag block, copies both
 */
      syrk_K(&ip, flg, 0, A, A, blk2sy, beta, C, wA, wB, rC, wC);
      if (N > nb)
      {
/*
 *       Compute all C blks within this colpan of C, copying rest of A, reuse B
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsMK)(&ip, 1, 0, A, NULL, C, 7, wA, wB, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         c = C + incC;
         for (j=1; j < nnblks-1; j++)
         {
/*
 *          syrk reuse A and copies B
 */
            syrk_K(&ip, flg, j, NULL, A, blk2sy, beta, C, wA, wB,
                          rC, wC);
            wA += szB SHIFT;
/*
 *          gemm reuses both the copies
 */
            Mjoin(PATL,iploopsMK)(&ip, j+1, j, NULL, NULL, c, 7, wA, wB, rC, wC,
                                  beta, blk2c);
            c += incC;
         }
/*
 *       Last colpan is only 1 diag blk, still reuses A
 */
         syrk_K(&ip, flg, j, NULL, A, blk2sy, beta, C, wA, wB,
                       rC, wC);
      }
   }
#ifdef MEM_DEBUG
   free(vA);
   free(vB);
   free(vC);
#else
   free(vp);
#endif
   return(0);
}
@ROUT ATL_syrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_umsyrk.h))
#ifndef Conj_
   #define ATL_DECL_ 1
#endif
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h))
#ifndef Conj_
   #undef ATL_DECL_
#endif
#if 0
   #define USEREF 1
   #include "atlas_reflevel3.h"
#endif
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk) 
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrk_amm  Mjoin(PATL,herk_amm)
   #define opsyrk  Mjoin(PATL,opherk)
   #define ipsyrk  Mjoin(PATL,ipherk)
   #define SYRK Mjoin(PATL,herk)
   #define herk_FLG 1
   #define umsyrk  Mjoin(PATL,umherk)
   #define sqsyrk  Mjoin(PATL,sqherk)
#else
   #define syrk_amm  Mjoin(PATL,syrk_amm)
   #define opsyrk  Mjoin(PATL,opsyrk)
   #define ipsyrk  Mjoin(PATL,ipsyrk)
   #define SYRK Mjoin(PATL,syrk)
   #define herk_FLG 0
   #define umsyrk  Mjoin(PATL,umsyrk)
   #define sqsyrk  Mjoin(PATL,sqsyrk)
#endif

int syrk_amm
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_iptr_t  N,
   ATL_iptr_t K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_iptr_t ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int i, k, ierr;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   ipinfo_t ip, ipmen;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   #ifdef USEREF
   {
      #ifdef Conj_
         Mjoin(PATL,refherk)(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         Mjoin(PATL,refsyrk)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }
   #endif
   if (N == 0)     /* no output */
      return(0);   /* so return with no-op */
@BEGINSKIP
/*
 * Does the operation not involve A at all?
 */
   #ifdef Conj_
      if (ralpha == ATL_rzero || !K)
      {
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         return(0);
      }
   #else
      if (SCALAR_IS_ZERO(alpha) || !K)
      {
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         return(0);
      }
   #endif
   if (N == 1) /* really a dot product */
   {
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
      #endif
      #ifdef Conj_
         TYPE d0;
         ATL_zdotc_sub(K, A, incA, A, incA, dot);
         C[1] = ATL_rzero;
         d0 = *dot * ralpha;
         if (rbeta == ATL_rzero)
            C[0] = d0;
         else 
            C[0] = C[0] * rbeta + d0;
      #elif defined(TCPLX)
         const TYPE ra=(*alpha), ia=alpha[1], rb=(*beta), ib=beta[1];
         TYPE rd, id, rt;
         ATL_zdotu_sub(K, A, incA, A, incA, dot);
         rt = rd = dot[0];
         id = dot[1];
         rd = rd*ra - id*ia;
         id = rt*ia + id*ra;
         if (ib == ATL_rzero) /* beta is a real number only */
         {
            if (rb == ATL_rzero) /* beta is 0 */
            {
               C[0] = rd;
               C[1] = id;
            }
            else
            {
               C[0] = C[0] * rb + rd;
               C[1] = C[1] * rb + id;
            }
         }
         else
         {
            const register rc=(*C), ic=C[1];
            C[0] = rc*rb - ic*ib + rd;
            C[1] = rc*ib + ic*rb + id;
         }
      #else /* real */
         TYPE dot, c;
         c = SCALAR_IS_ZERO(beta) ? ATL_rzero : *C * beta;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         if (!SCALAR_IS_ONE(alpha))
            dot *= alpha;
         *C = c + dot;
      #endif
   }
@skip   else if (K < 3) /* really a rank-1 or rank-2 update */
   else if (K == 1) /* really rank-1 update, for now just use two-pass */
   {                /* thru C for BETA!=1, optimize later with axpby */
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? 1 : lda;
      #ifdef Conj_
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         Mjoin(PATL,her)(Uplo, N, ralpha, A, incA, C, ldc);
      #else
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         Mjoin(PATL,syr)(Uplo, N, alpha, A, incA, C, ldc);
      #endif
   }
@ENDSKIP
   if (K < 3 || SCALAR_IS_ZERO(alpha))      /* degenerate case handled by*/
   {                                        /* ipsyrk */
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }

/*
 * Inner-product version calls nothing by SYRK kernels, and is called in
 * LAPACK's default left-looking Cholesky.  _IP handles L1/L2BLAS cases too.
 */
   timG = Mjoin(PATL,ipsyrkInfo)(&ip,herk_FLG, TA, N, K, lda, ldc, alpha, beta);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   #if 1
   if (timG < 0.0)
   {
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }
   #endif
/*
 * Outer product version will call outer-product-optimized amm, and since
 * N is too large to call ipsyrk, we expect amm perf to dominate this case.
 * Outer product SYRK is used in right-looking Cholesky.
 */
   #if 1
   if (K <= ATL_VWopgen_BEST_KB)
   {
      int ierr;
   #ifdef Conj_
      ierr = opsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
   #else
      ierr = opsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
      if (ierr)
      {
         if (ierr == 1)  /* if we failed to malloc */
            return(1);   /* tell recursion to continue */
         if (nb >= N)    /* if we can do it with ipsyrk or opsyrk */
         {               /* use ipsyrk if opsyrk fails */
            #ifdef Conj_
               ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
            #else
               ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
            #endif
            return(0);
         }
      }
      else
         return(0);
   }
   #endif
/*
 * Will eventually need syrk timed for all square blocks to select best case.
 * For now, just pretend syrk time doesn't matter
 */
/*
 * We will decide between sqsyrk and umsyrk based on the pref data from 
 * amm_syrkPerf.h.  
 */
#if 1  /* apply umsyrk*/ 
   #ifdef Conj_
      ierr = umsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
   #else
      ierr = umsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
#else /* sqsyrk */
   #ifdef Conj_
      ierr = sqsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
   #else
      ierr = sqsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
#endif
   return(ierr);
}

static void syrk_rec
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #if defined(Conj_) || defined(TREAL)
      #define ONE ATL_rone
   #else
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif
/*
 * If we cannot solve problem at this size, recursively cut dims until we can
 */
   if (syrk_amm(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc))
   {
      if (N > K)
      {
         ATL_iptr_t nL=N>>1, nR=N-nL;
         const TYPE *Ar = A+((TA==AtlasNoTrans)?(nL SHIFT):lda*(nL SHIFT));
         TYPE *Ct = C + (ldc+1)*(nL SHIFT);
         const enum ATLAS_TRANS TB =
         #ifdef Conj_
               (TA == AtlasNoTrans) ? AtlasConjTrans:AtlasNoTrans;
            const TYPE galp[2]={alpha,ATL_rzero}, gbet[2]={beta,ATL_rzero};
         #else
               (TA == AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
            #define galp alpha
            #define gbet beta
         #endif
         syrk_rec(Uplo, TA, nL, K, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, nR, K, alpha, Ar, lda, beta, Ct, ldc);
         if (Uplo == AtlasUpper)
            Mjoin(PATL,gemm)(TA, TB, nL, nR, K, galp, A, lda, Ar, lda, 
                             gbet, Ct-(nL SHIFT), ldc);
         else
            Mjoin(PATL,gemm)(TA, TB, nR, nL, K, galp, Ar, lda, A, lda, 
                             gbet, C+(nL SHIFT), ldc);
         #ifndef Conj_
            #undef galp
            #undef gbet
         #endif
      }
      else
      {
         ATL_iptr_t kL=K>>1, kR=K-kL, incA=((TA == AtlasNoTrans)?lda:1)SHIFT;
         syrk_rec(Uplo, TA, N, kL, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, N, kR, alpha, A+incA*kL, lda, ONE, C, ldc);
      }
   }
}
#if defined(Conj_) || defined(TREAL)
   #undef ONE
#endif

void SYRK
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
#if 0
   #ifdef Conj_
      Mjoin(PATL,herk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #else
      Mjoin(PATL,syrk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
   return;
#endif
   syrk_rec(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);

}
@ROUT ATL_opsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_umsyrk.h))
#ifdef Conj_
   #define sqsyrkBlk Mjoin(PATL,sqherkBlk_OP)
   #define umsyrkBlk Mjoin(PATL,umherkBlk_OP)
   #define opsqsyrk Mjoin(PATL,opsqherk)
   #define opumsyrk Mjoin(PATL,opumherk)
   #define opsyrk Mjoin(PATL,opherk)
#else
   #define sqsyrkBlk Mjoin(PATL,sqsyrkBlk_OP)
   #define umsyrkBlk Mjoin(PATL,umsyrkBlk_OP)
   #define opsqsyrk Mjoin(PATL,opsqsyrk)
   #define opumsyrk Mjoin(PATL,opumsyrk)
   #define opsyrk Mjoin(PATL,opsyrk)
#endif
/*
 * Indexes both A and C from base ptrs according to d (diagonal blk)
 */
void sqsyrkBlk
(
   opinfo_t *op,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real ptr (unused for real types) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, op-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL op-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real ptr (unused for real routs) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   ATL_CSZT lda = op->lda, nfblks = op->nfnblks;
   ATL_CUINT KB = op->KB, kb = op->kb;
   ATL_UINT nb, kbS, nnu;
   #ifdef TCPLX
      ATL_UINT szC, szA;
      TYPE *rA, *rB;
   #endif
   const SCALAR beta=op->beta;
   if (d == nfblks + op->npnblks - 1)  /* last block is SYRK only */
   {
      nb = op->nF;
      nb = (nb) ? nb : op->nb;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + op->szA;
            rB = wB + op->szB;
         }
         else
         {
            rA = wA + op->pszA;
            rB = wB + op->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = op->nb;
      #ifdef TCPLX
         rA = wA + op->szA;
         rB = wB + op->szB;
      #endif
   }
   else
   {
      nb = op->pnb;
      #ifdef TCPLX
         rA = wA + op->pszA;
         rB = wB + op->pszB;
      #endif
   }
   nnu = (nb+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
   kbS = ((kb+ATL_SQSYRKK_KU-1)/ATL_SQSYRKK_KU)*ATL_SQSYRKK_KU;
   if (A)  /* want to copy input array */
   {
/*
 *    Move A ptr to d'th block
 */
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         A += n*op->incAm;
         n = d - n;  /* # of partial blocks remaining in d */
         A += n*op->pincAm;
      }
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            op->a2blk(kb, nb, op->alpA, A, lda, rA, wA);
         #else
            op->a2blk(kb, nb, op->alpA, A, lda, wA);
         #endif
         if (op->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            op->b2blk(kb, nb, op->alpB, A, lda, rB, wB);
         #else
            op->b2blk(kb, nb, op->alpB, A, lda, wB);
         #endif
         if (op->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, op->ONE, A, lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, lda, wS);
         #endif
      }
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            Mjoin(PATL,sqsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,sqsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            Mjoin(PATL,sqsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,sqsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=op->ldc;
      int k;
      #ifdef TCPLX
         const TYPE *alp = (op->alpA == op->ONE) ? op->alpB : op->alpA;
      #else
         TYPE alp = (op->alpA == ATL_rone) ? op->alpB : op->alpA;
      #endif
      C += d*op->nb*((ldc+1)SHIFT);
      if (flag&1)  /* Upper matrix */
      {
         @BEGINSKIP
         #ifdef TCPLX
            const TYPE zero[2] = {ATL_rzero, ATL_rzero};
            blk2c(nb, nb, alp, rC, wC, zero, wU, nb);
            #ifdef Conj_  /* must zero imag part of diagonal for HERK */
            {
               ATL_CINT ldc2=ldc+ldc;
               for (k=0; k < nb; k++, C += ldc2, wU += 2)
               {
                  Mjoin(PATL,axpbyConj)(k+1, op->ONE, wU, nb, beta, C, 1);
                  C[((k+1)<<1)-1] = ATL_rzero;
               }
            }
            #endif
         #else
            blk2c(nb, nb, alp, wC, ATL_rzero, wU, nb);
         #endif
/*
 *       Copy matrix back to original C while applying beta
 */
         #ifndef Conj_
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, op->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
         #endif
         @ENDSKIP
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
      else
      {
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
}
int opsqsyrk
(
   opinfo_t *op,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szC, szU, szS, nnblks, szAblk;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wU, *rC, *rCs, *rS;
   int nb, nbS, flg, idx, extra;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   nnblks = op->nfnblks + op->npnblks;
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_sqsyrkT) : Mjoin(PATL,a2blk_sqsyrkN);

   if (Uplo == AtlasLower)
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1b1):Mjoin(PATL,sqSyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1bN):Mjoin(PATL,sqSyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1b0):Mjoin(PATL,sqSyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1bX):Mjoin(PATL,sqSyrkIntoC_aXbX);
      }
   }
   else  /* C is Upper */
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1b1_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1bN_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1b0_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1bX_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXbX_L2UT);
      }
@BEGINSKIP
      szU = N*N;
      if (SCALAR_IS_NONE(alpha))
         blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0);
      else
         blk2sy = SCALAR_IS_ONE(alpha) ?
                  Mjoin(PATL,sqSyrkIntoC_a1b0):Mjoin(PATL,sqSyrkIntoC_aXb0);
@ENDSKIP
   }
   extra = (ATL_SQSYRKK_NU+ATL_SQSYRKK_NU)*ATL_SQSYRKK_NU;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
   if (TA == AtlasUpper)
   {
      flg |= 1;
      extra -= Mmin(extra, szU);
   }
   if (nnblks == 1)  /* we've got a 1 block of SYRK only! */
   {
      nbS = (N+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
      szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
      nbS *= ATL_SQSYRKK_NU;
      szC *= ((ATL_SQSYRKK_NU*ATL_SQSYRKK_NU+ATL_SQSYRKK_VLEN-1)/ATL_SQSYRKK_VLEN)
             * ATL_SQSYRKK_VLEN;
      #if ATL_SQSYRKK_KVEC > 1
         szS = ((K+ATL_SQSYRKK_KVEC-1)/ATL_SQSYRKK_KVEC)*ATL_SQSYRKK_KVEC;
         szS *= nbS;
      #else
         szS = nbS * K;
      #endif
      szU = Mmax(op->szC, szU);  /* Majedul: don't need anymore */
      sz = ATL_MulBySize(szU + szC + szS + extra) + 3*ATL_Cachelen;
      vp = malloc(sz);
      if (!vp)
         return(1);
      wS = ATL_AlignPtr(vp);
      wC = wS + (szS SHIFT);
      wC = ATL_AlignPtr(wC);
      wU = wC + (szC SHIFT);
      wU = ATL_AlignPtr(wU);
      #ifdef TCPLX
         rC = wC + szC;
         rS = wS + szS;
      #else
         rC = wC;
         rS = wS;
      #endif
      flg |= (Uplo == AtlasUpper) ? 1 : 0;
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS,
              NULL, NULL, NULL, NULL, rC, wC, wU);
      free(vp);
      return(0);
   }
/*
 * If we reach here, we have at rank-K SYRK update requiring both SYRK & GEMM
 * Since nnblks > 1, nfnblks > 1 as well.
 */
   nbS = (op->nb+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SQSYRKK_NU;
   szC *= ((ATL_SQSYRKK_NU*ATL_SQSYRKK_NU+ATL_SQSYRKK_VLEN-1)/ATL_SQSYRKK_VLEN)
          * ATL_SQSYRKK_VLEN;
   #if ATL_SQSYRKK_KVEC > 1
      szS = ((K+ATL_SQSYRKK_KVEC-1)/ATL_SQSYRKK_KVEC)*ATL_SQSYRKK_KVEC;
      szS *= nbS;
   #else
      szS = nbS * K;
   #endif
   szU = Mmax(op->szC, szU);  /* Majedul: no need anymore */
   szAblk = op->szA;
   szA = szAblk * (nnblks-1);
   /*
    * FIXED: wC is used both for syrk and gemm. 
    * We need to allocate Mmax(szC, op->szC) for wC
    */
   sz = Mmax(szC, op->szC);
   sz = ATL_MulBySize(szA+szAblk + szS + sz + szU + extra) + 5*ATL_Cachelen;
   vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szAblk SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   wU = wC + (szC SHIFT);
   wU = ATL_AlignPtr(wU);
   #ifdef TCPLX
      rC = wC + op->szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rC = wC;
      rCs = wC;
      rS = wS + szS;
   #endif
   if (Uplo == AtlasLower)
   {
      size_t j;
/*
 *    Do first diagonal block, don't copy A blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB,
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, cop->ing entire A at same time
 */
      Mjoin(PATL,oploopsM)(op, 1, 0, A, NULL, C, 1, wA, wB, rC, wC);
/*
 *    For remaining column panels of C, sqsyrkBlk copies B, reusues wA
 */
      for (j=1; j < nnblks-1; j++)
      {
         sqsyrkBlk(op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB,
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsM)(op, j+1, j, NULL, NULL, C, 1, wA, wB, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      sqsyrkBlk(op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   else
   {
      size_t i;
/*
 *    Do first diagonal block, don't copy A^T blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      flg |= 1;
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL,
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A^T at same time
 */
      Mjoin(PATL,oploopsN)(op, 0, 1, NULL, A, C, 2, wB, wA, rC, wC);
/*
 *    For remaining column panels of C, sqsyrkBlk copies A, reuses A^T
 */
      for (i=1; i < nnblks-1; i++)
      {
         sqsyrkBlk(op, flg, i, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL,
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsN)(op, i, i+1, NULL, NULL, C, 2, wB, wA, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      sqsyrkBlk(op, flg, i, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   free(vp);
   return(0);
}
void umsyrkBlk
(
   opinfo_t *op,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy in wA */
   const TYPE *B, /* if non-NULL, base A ptr to copy in wB */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *wA,      /* if non-NULL, op-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL op-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real ptr (unused for real routs) */
   TYPE *wC      /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   ATL_CSZT lda = op->lda, nfblks = op->nfnblks;
   ATL_CSZT ldb = op->ldb;
   ATL_CUINT KB = op->KB, kb = op->kb;
   ATL_UINT nb, kbS, nnu, nmu;
#ifdef TCPLX
   ATL_UINT szC, szA;
   TYPE *rA, *rB;
   TYPE *iA=wA, *iB=wB; /* may not need ... wA, wB can be used !!!*/
#endif
   const SCALAR beta=op->beta;
   TYPE *wS;
   /*assert(op->mb==op->nb);*/
   if (d == nfblks + op->npnblks - 1) /* last syrk only block*/
   {
      nb = op->nF;
      nb = (nb) ? nb : op->nb;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + op->szA;
            rB = wB + op->szB;
         }
         else
         {
            rA = wA + op->pszA;
            rB = wB + op->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = op->nb;
      #ifdef TCPLX
         rA = wA + op->szA;
         rB = wB + op->szB;
      #endif
   }
   else
   {
      nb = op->pnb;
      #ifdef TCPLX
         rA = wA + op->pszA;
         rB = wB + op->pszB;
      #endif
   }
/*
 * calc nmu and nnu. one must be multiple of other
 */
   if (op->mu > op->nu)
   {
      nmu = (nb+op->mu-1)/op->mu;
      nnu = nmu * (op->mu/op->nu); /* NU must be multiple of MU */
   }
   else
   {
      nnu = (nb+op->nu-1)/op->nu;
      nmu = nnu * (op->nu/op->mu); /* NU must be multiple of MU */
   }
/*
 * we can use KB since we are using same kernel as gemm
 */
   kbS = op->KB;

   if (A)  /* want to copy input array in wA */
   {
/*
 *    Move A ptr to d'th block
 */
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         A += n*op->incAm;
         n = d - n;  /* # of partial blocks remaining in d */
         A += n*op->pincAm;
      }
      #ifdef TCPLX
         op->a2blk(kb, nb, op->alpA, A, lda, rA, wA);
      #else
         op->a2blk(kb, nb, op->alpA, A, lda, wA);
      #endif
   }
   if (B) /* want to copy input array in wB */
   {
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         B += n*op->incBn;
         n = d - n;  /* # of partial blocks remaining in d */
         B += n*op->pincBn;
      }

      #ifdef TCPLX
         op->b2blk(kb, nb, op->alpB, B, ldb, rB, wB);
      #else
         op->b2blk(kb, nb, op->alpB, B, ldb, wB);
      #endif
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
/*
 *    NOTE: no need to specially handle herk/conj, since we are using gemm's
 *    copy routines and similar kernels
 */
      #ifdef TCPLX
         Mjoin(PATL,umsyrkK_b0)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
         Mjoin(PATL,umsyrkK_b0)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         Mjoin(PATL,umsyrkK_bn)(nmu, nnu, kbS, rA, rB, rC, wA, rB, wC);
         Mjoin(PATL,umsyrkK_b1)(nmu, nnu, kbS, wA, rB, wC, wA, wB, wC);
      #else
         Mjoin(PATL,umsyrkK_b0)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=op->ldc;
      int k;
      #ifdef TCPLX
         const TYPE *alp = (op->alpA == op->ONE) ? op->alpB : op->alpA;
      #else
         TYPE alp = (op->alpA == ATL_rone) ? op->alpB : op->alpA;
      #endif
      C += d*op->nb*((ldc+1)SHIFT);
      if (flag&1)  /* Upper matrix */
      {
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
      else
      {
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
}

int opumsyrk
(
   opinfo_t *op,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szC, szU, szS, nnblks, szAblk;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wU, *rC, *rCs, *rS;
   int nb, nbS, flg, idx, extra;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;
   int smnu;

   nnblks = op->nfnblks + op->npnblks;
   smnu = Mmax(op->mu, op->nu);           /* max unrolling */
/*
 * select c-copy 
 */
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1b1);
      else if (SCALAR_IS_NONE(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1bN);
      else if (SCALAR_IS_ZERO(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1b0);
      else
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1bX);
   }
   else  /* C is Upper */
   {
      if (SCALAR_IS_ONE(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1b1_L2UT);
      else if (SCALAR_IS_NONE(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1bN_L2UT);
      else if (SCALAR_IS_ZERO(beta))
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1b0_L2UT);
      else
         blk2sy = Mjoin(PATL,umSyrkIntoC_a1bX_L2UT);
   }
   flg = (TA == AtlasNoTrans) ? 2 : 0;
   if (TA == AtlasUpper)
      flg |= 1;
   if (nnblks == 1)  /* we've got a 1 block of SYRK only! */
   {
      extra = (smnu+smnu)*smnu;
      nbS = (N+smnu-1)/smnu;
      szC = ((nbS+1)*nbS)>>1;
      nbS *= smnu;
      szC *= ((smnu*smnu+op->ku-1)/op->ku)*op->ku;
      szS = nbS * op->KB;         /* KB is already rounded with ku */
      szA = szAblk = szS;
      sz = ATL_MulBySize(szA+szAblk+szC+extra) + 3*ATL_Cachelen;
      vp = malloc(sz);
      if (!vp)
         return(1);
      wA = ATL_AlignPtr(vp);
      wB = wA + (szA SHIFT);
      wB = ATL_AlignPtr(wB);
      wC = wB + (szAblk SHIFT);
      wC = ATL_AlignPtr(wC);
      #ifdef TCPLX
         rC = wC + szC;
      #else
         rC = wC;
      #endif
      flg |= (Uplo == AtlasUpper) ? 1 : 0;
      umsyrkBlk(op, flg, 0, A, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
      free(vp);
      return(0);
   }
/*
 * If we reach here, we have at rank-K SYRK update requiring both SYRK & GEMM
 * Since nnblks > 1, nfnblks > 1 as well.
 */
/*
 * syrk needs less space than gemm, so we can reuse same wC space
 */
   szC = op->szC;
   szAblk = op->szA;
   szA = szAblk * (nnblks-1);
   extra = op->exsz;           /* why needed?? */
   sz = ATL_MulBySize(szA + szAblk + szC + extra) + 3*ATL_Cachelen;

   vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wC = wB + (szAblk SHIFT);
   wC = ATL_AlignPtr(wC);
   #ifdef TCPLX
      rC = wC + op->szC;
   #else
      rC = wC;
   #endif
   if (Uplo == AtlasLower)
   {
      size_t j;
/*
 *    SYRK uses same copy routines as GEMM. copy of B can be reused in GEMM
 *    of the column panels
 */
      umsyrkBlk(op, flg, 0, A, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A at same time
 */
      Mjoin(PATL,oploopsM)(op, 1, 0, A, NULL, C, 1, wA, wB, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies B, re-uses wA
 */
      for (j=1; j < nnblks-1; j++)
      {
/*
 *       ****** big idea:
 *       1. Resue A from previous wA calculated in oploopsM last time.
 *          After the first call of oploopsM the whole wA is populated
 *       2. compute wB which can be reused in subsequent oploopsM
 */
         umsyrkBlk(op, flg, j, NULL, A, blk2sy, C, wA,wA, wB,wB, rC, wC);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsM)(op, j+1, j, NULL, NULL, C, 1, wA, wB, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      umsyrkBlk(op, flg, j, NULL, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
   }
   else
   {
      size_t i;
/*
 *    GEMM will reuse A*T, Syrk can reuse B later... wB is wA
 */
      flg |= 1;
      umsyrkBlk(op, flg, 0, A, A, blk2sy, C, wB, wB, wA, wA, rC, wC);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A^T at same time
 */
      Mjoin(PATL,oploopsN)(op, 0, 1, NULL, A, C, 2, wB, wA, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies A, reuses A^T
 */
      for (i=1; i < nnblks-1; i++)
      {
         umsyrkBlk(op, flg, i, A, NULL, blk2sy, C, wB,wB, wA,wA, rC, wC);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsN)(op, i, i+1, NULL, NULL, C, 2, wB, wA, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      umsyrkBlk(op, flg, i, A, NULL, blk2sy, C, wB, wB, wA, wA, rC, wC);
   }
   free(vp);
   return(0);
}

int opsyrk
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   int i, ismul;
   int ierr;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   opinfo_t op;
/*
 * find opsyrkinfo
 */
   #ifdef Conj_
      if (Mjoin(PATL,opsyrkInfo)(&op, 1, TA, N, K, lda, ldc, alpha, beta))
   #else
      if (Mjoin(PATL,opsyrkInfo)(&op, 0, TA, N, K, lda, ldc, alpha, beta))
   #endif
         return(2);
   #if 0
   fprintf(stderr, "D=(%u,%u), B=(%u,%u,%u), pB=(%u,%u,%u)\n",
           (unsigned int)N, (unsigned int)K, op.mb, op.nb, op.KB,
           op.pmb, op.pnb, op.kb);
   #endif
/*
 * mu,nu,ku, must match with amm_umsyrk.h to apply umsyrk until we manage 
 * to have opgenview for UM
 */
   ismul = 1;
   if (op.mu != ATL_UMSYRKK_MU || op.nu != ATL_UMSYRKK_NU 
         || op.ku !=ATL_UMSYRKK_KU )
      ismul = 0;
/*
 * try to use umsyrk first if possible 
 */
   if (ismul)
      ierr = opumsyrk(&op, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   else
      ierr = opsqsyrk(&op, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   return(ierr);
}
@ROUT ATL_ipsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2015 
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,amm_sum.h))
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h)) /* blocking & perf info */
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))  /* syrk kernel info */
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_umsyrk.h))

static INLINE void ATL_syr1
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * First, see if we can simply call the Level-2 BLAS
 */
   #ifdef Conj_
      TYPE *c=C+1;
   #endif
   #ifndef TCPLX
      if (beta == 1.0)
      {
         Mjoin(PATL,syr)(Uplo, N, alpha, A, TA==AtlasNoTrans?1:lda, C, ldc);
         return;
      }
   #endif
   {
      size_t k;
      TYPE *X=(TYPE*)A;
      void *vp=NULL;
      #ifdef Conj_
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
/*
 *    Copy A if it's a row so it is contiguous for all N axpby calls
 */
      #ifdef Conj_
      if (TA == AtlasConjTrans)
      #else
      if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
      {
         vp = malloc(ATL_MulBySize(N)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, A, lda, X, 1);
         #else
            Mjoin(PATL,copy)(N, A, lda, X, 1);
         #endif
      }
      #ifdef Conj_
         if (rbeta == 1.0)
         {
            Mjoin(PATL,her)(Uplo, N, ralpha, X, 1, C, ldc);
            if (vp)
               free(vp);
            return;
         }
      #endif  /* NO syr for complex, so cplx SYR has to use axpy-based code */
      #ifdef TCPLX
         if (Uplo == AtlasUpper)
         {
            size_t ldc2 = ldc+ldc;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldc2)
            {
               size_t k2=k+k;
               #ifndef Conj_
                  const register TYPE rx=X[k2], ix=X[k2+1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha*X[k2];
                  scal[1] = -ralpha*X[k2+1];
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(k+1, scal, X, 1, beta, C, 1);
            }
         }
         else   /* Uplo == AtlasLower */
         {
            size_t ldcp1 = (ldc+1)SHIFT;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldcp1, X += 2)
            {
               #ifndef Conj_
                  const register TYPE rx=*X, ix=X[1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha* *X;
                  scal[1] = ralpha * (-X[1]);
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(N-k, scal, X, 1, beta, C, 1);
            }
         }
      #else  /* real with beta != 1.0 */
         if (Uplo == AtlasUpper)
         {
            for (k=0; k < N; k++, C += ldc)
               Mjoin(PATL,axpby)(k+1, X[k]*alpha,  X, 1, beta, C, 1);
         }
         else   /* Uplo == AtlasLower */
         {
            for (k=0; k < N; k++, C += (ldc+1), X++)
               Mjoin(PATL,axpby)(N-k, (*X)*alpha,  X, 1, beta, C, 1);
         }
      #endif
      if (vp)
         free(vp);
      @beginskip
         {
            size_t n=N;
            TYPE zero[2] = {ATL_rzero, ATL_rzero;
            else
               vp = NULL;
            if (Uplo == Upper)
            {
               if (SCALAR_IS_ONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                     Mjoin(PATL,axpby)(M, X+k+k,  X, 1, beta, C, 1);
               }
               else if (SCALAR_IS_NONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     const TYPE scal[2] = {-X[k+k], -X[k+k+1]};
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
               else  /* alpha should be multiplied */
               {
                  const register TYPE ralp=*alpha, ialp=alpha[1];
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     TYPE scal[2];
                     const register TYPE rx=X[k+k], ix=X[k+k+1];
                     scal[0] = rx*ralp - ix*ialp;
                     scal[1] = rx*ialp + ix*ralp;
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
            }
            else  /* Uplo == Lower */
            {
            }
         }
         @endskip
   }
   #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
      Mjoin(PATLU,zero)(N, c, (ldc+1)SHIFT);
   #endif
}

#include "atlas_cache.h"
#include "atlas_reflevel3.h"
/*
 * This routine assumes 1st col of A is x, 2nd y, and NoTrans case
 */
static void ATL_syr2_axpy
(
   const enum ATLAS_UPLO Uplo,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *x,
   const TYPE *y,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef Conj_
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
   if (Uplo == AtlasLower)
   {
      ATL_CSZT ldcp1 = (ldc+1)SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldcp1)
      {
         ATL_CSZT n = N-j;
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(n, alpx, x+(j SHIFT), 1, beta, C, 1);
         Mjoin(PATL,axpy)(n, alpy, y+(j SHIFT), 1, C, 1);
         #ifdef Conj_
            C[1] = ATL_rzero;
         #endif
      }
   }
   else /* Uplo == AtlasUpper */
   {
      ATL_CSZT ldc2 = ldc SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldc2)
      {
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(j+1, alpx, x, 1, beta, C, 1);
         Mjoin(PATL,axpy)(j+1, alpy, y, 1, C, 1);
         #ifdef Conj_
            C[j+j+1] = ATL_rzero;
         #endif
      }
   }
}

#ifdef Conj_
   #define ATL_ger2 Mjoin(PATL,ger2c)
#elif defined(TCPLX)
   #define ATL_ger2 Mjoin(PATL,ger2u)
#else
   #define ATL_ger2 Mjoin(PATL,ger2)
#endif
static void ATL_syr2
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   TYPE *x, *y;
   #ifdef TCPLX
      ATL_CSZT lda2 = lda+lda, ldc2 = ldc+ldc;
   #else
      #define lda2 lda
      #define ldc2 ldc
   #endif
   #ifdef Conj_
      const TYPE alpha[2]={ralpha, ATL_rzero};
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
/*
 * If A cols are strided, copy them to contiguous & aligned storage
 */
   if (TA != AtlasNoTrans)
   {
      vp = malloc(ATL_MulBySize(N+N) + ATL_Cachelen+ATL_Cachelen);
      ATL_assert(vp);
      x = ATL_AlignPtr(vp);
      y = x + (N SHIFT);
      y = ATL_AlignPtr(y);
      #ifdef Conj_
         Mjoin(PATL,copyConj)(N, A, lda, x, 1);
         Mjoin(PATL,copyConj)(N, A+(1 SHIFT), lda, y, 1);
      #else
         Mjoin(PATL,copy)(N, A, lda, x, 1);
         Mjoin(PATL,copy)(N, A+(1 SHIFT), lda, y, 1);
      #endif
   }
   else
   {
      x = (TYPE *) A;
      y = (TYPE *) (A + lda2);
   }
/*
 * If BETA != 1, then we must pass through C twice, so use daxpy-based code
 */
   #ifdef Conj_
   if (rbeta != ATL_rone)
   #else
   if (!SCALAR_IS_ONE(beta))
   #endif
   {
      #ifdef Conj_
         ATL_syr2_axpy(Uplo, N, ralpha, x, y, rbeta, C, ldc);
      #else
         ATL_syr2_axpy(Uplo, N, alpha, x, y, beta, C, ldc);
      #endif
   }
   else /* beta=1 can use ger2 based code, make only 1 pass thru C */
   {
      #ifdef Conj_
         const TYPE alpha[2] = {ralpha, ATL_rzero};
      #endif
      #if L1C_ELTS >= 16384
         unsigned int Np = (N > 128) ? 120 : N;
      #elif L1C_ELTS >= 8192
         unsigned int Np = (N > 90) ? 80 : N;
      #elif L1C_ELTS >= 4096
         unsigned int Np = (N > 64) ? 60 : N;
      #elif L1C_ELTS >= 2048
         unsigned int Np = (N > 48) ? 40 : N;
      #else
         unsigned int Np = (N > 40) ? 24 : N;
      #endif
      if (Uplo == AtlasLower)
      {
         ATL_CSZT incC=((ldc+1)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C, ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C, ldc);
            #endif
            ATL_ger2(N-j-nb, nb, alpha, x+nb2, 1, x, 1, alpha, y+nb2, 1, y, 1, 
                     C+nb2, ldc);
         }
      }
      else
      {
         const TYPE *x0 = x, *y0 = y;
         ATL_CSZT incC=((ldc)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            if (j)
               ATL_ger2(j, nb, alpha, x0, 1, x, 1, alpha, y0, 1, y, 1,
                        C, ldc);
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C+(j SHIFT), ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C+(j SHIFT), ldc);
            #endif
         }
      }
   }
   if (vp)
      free(vp);
}

@ROUT ATL_ipsyrk N2Idx
static INLINE int N2Idx(const unsigned int N)
/*
 * Uses Recursive halving to find smallest NB >= N in VWsyrk.
 */
{
   unsigned int idxB=ATL_VWsyrk_NCASES-1, idxS=0, idxM;
   unsigned int nbB, nbS=ATL_VWsyrk_MIN_NB, nbM;
   if (N <= ATL_VWsyrk_MIN_NB)
      return(0);
   nbB = ATL_GetVWsyrkMB(idxB);
   if (N >= nbB)
      return(ATL_VWsyrk_NCASES-1);
   KEEP_ON:
      idxM = ((idxB-idxS)>>1)+idxS;
      if (idxM == idxS)
         return((nbS >= N) ? idxS:idxB);
      nbM = ATL_GetVWsyrkMB(idxM);
      if (nbM > N)
      {
         idxB = idxM;
         nbB = nbM;
      }
      else if (nbM < N)
      {
         idxS = idxM;
         nbS = nbM;
      }
      else /* if (nbM == N) */
         return(idxM);
   goto KEEP_ON;
}
@ROUT ATL_ipsyrk

#ifdef Conj_
void Mjoin(PATL,ipherk)
#else
void Mjoin(PATL,ipsyrk)
#endif
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
/* 
 * C NxN, A NxK
 * SYRK:
 *    C = alpha * A * A^T + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^T * A + beta*C, if TA == AtlasTrans
 * HERK:
 *    C = alpha * A * A^H + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^H * A + beta*C, if TA == AtlasTrans
 */
{
   cm2am_t a2blk;
   ablk2cmat_t blk2c;
   void *vp;
   #ifdef TCPLX
      TYPE *rA, *iA, *rC, *iC, *c;
      TYPE one[2] = {ATL_rone, ATL_rzero};
      #ifdef Conj_
         TYPE *crA, *ciA;
         const TYPE alpha[2] = {ralpha, ATL_rzero};
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
   #else
      TYPE *pA, *pC, *c;
      #define one ATL_rone
   #endif
   size_t szA, szC, szE, incAk, nkb, k;
   ATL_CUINT nnu = (N+ATL_SYRKK_NU-1)/ATL_SYRKK_NU, NN=nnu*ATL_SYRKK_NU;
   ATL_UINT kb, kbS, kb0, KB0, idx;
/*
 * Handle degenerate cases
 */
   if (!N)                            /* no output! */
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)  /* really scale of C */
   {
      if (SCALAR_IS_ONE(beta))       /* no-op */
         return;
      if (SCALAR_IS_ZERO(beta))      /* explicit zero */
      {
         if (Uplo == AtlasLower)
            Mjoin(PATL,trsetL)(N, N, beta, beta, C, ldc);
         else
            Mjoin(PATL,trsetU)(N, N, beta, beta, C, ldc);
         return;
      }
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
      #endif
      return;
   }
   if (K == 1)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr1(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr1(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (K == 2)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr2(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr2(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (N == 1)  /* dot product */
   {
      const size_t incA = (TA==AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(K, A, incA, A, incA, dot);
            *dot   *= ralpha;
            if (rbeta != ATL_rzero)
               *dot   += rbeta * *C;
            *C = *dot;
            C[1] = ATL_rzero;
         #else
            const register TYPE ra=(*alpha), ia=alpha[1];
            register TYPE rd, id, rr;
            Mjoin(PATL,dotu_sub)(K, A, incA, A, incA, dot);
            rr = rd = dot[0];
            id = dot[1];
            rd = rr*ra - id*ia;
            id = rr*ia + id*ra;
            if (!SCALAR_IS_ZERO(beta))
            {
               const register TYPE rb=(*beta), ib=beta[1];
               const register TYPE rc=(*C), ic=C[1];
               rd += rb*rc - ib*ic;
               id += rb*ic + ib*rc;
            }
            C[0] = rd;
            C[1] = id;
         #endif
      #else
         TYPE dot;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         dot *= alpha;
         if (beta != ATL_rzero)
            dot += beta * *C;
         *C = dot;
      #endif
      return;
   }
/*
 * Find NB closest to our present N, and set initial KB to its tuned version
 */
   idx = N2Idx(NN);
   kb = ATL_GetVWsyrkKB(idx);
   szC = ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
         * ATL_SYRKK_VLEN;
   szC *= ((nnu+1)*nnu)>>1;  /* only need lower tri blks, not full nnu*nnu */
/*
 * Our SYRK C copy is always to Lower, so if output is Upper, will need
 * workspace to put the Lower part, before reflecting it to Upper.
 * Need max of this extra space, or preload distance.
 */
@skip   szE = (Uplo == AtlasLower) ? 0 : N*N;
@skip   szE = Mmax(szE, ATL_SYRKK_NU*ATL_SYRKK_NU*2);
   szE = (ATL_SYRKK_NU*ATL_SYRKK_NU)<<1;
   if (K > kb)
   {
      nkb = K / kb;
      kb0 = K - nkb*kb;
      if (!kb0)
      {
         kb0 = kb;
         nkb--;
      }
      KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
      kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   else
   {
      nkb = 0;
      kb0 = K;
      kbS = kb = KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   if (IS_COLMAJ(TA))
   {
      incAk = lda*(kb SHIFT);
      a2blk = Mjoin(PATL,a2blk_syrkT);
   }
   else
   {
      incAk = kb SHIFT;
      a2blk = Mjoin(PATL,a2blk_syrkN);
   }
@skip   szA = nnu*ATL_SYRKK_NU;
@skip   k = (Uplo == AtlasUpper) ? Mmax(kb,N) : kb;
@skip   szA *= k;
   szA = nnu*ATL_SYRKK_NU * kbS;
   vp = malloc(ATL_MulBySize(szA + szC + szE) 
               + 2*ATL_Cachelen);
   ATL_assert(vp);
   #ifdef TCPLX
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iC = rA + szA;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
      #ifdef Conj_
         crA = (TA == AtlasNoTrans) ? rA : iA;
         ciA = (TA == AtlasNoTrans) ? iA : rA;
      #endif
      c = rC + szC;
   #else
      pA = ATL_AlignPtr(vp);
      pC = pA + (szA SHIFT);
      pC = ATL_AlignPtr(pC);
      c = pC + szC;
   #endif
#if 0
   ipinfo_t ip;
   int i, flg;
   Mjoin(PATL,ipgenInfo)(&ip, 0, TA, TA, N, N, K, lda, lda, ldc, alpha, beta);
   flg = (Uplo == AtlasLower) ? 0 : 1;
   if (TA == AtlasNoTrans)
      flg |= 2;
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ?
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
   }
   Mjoin(PATL,syrkBlk)(&ip, flg|4, 0, 0, A, a2blk, K<=ip.kb?blk2c:NULL, beta, C,
                       pA, NULL, NULL, NULL, NULL, pC, pA);
/*   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1); */
   nkb = K / ip.kb;
   if (nkb * ip.kb == K)
      nkb--;
   for (k=0; k < nkb; k++)
      Mjoin(PATL,syrkBlk)(&ip, flg, 0, k+1, A, a2blk, k == nkb-1 ? blk2c:NULL, 
                          beta, C, pA, NULL, NULL, NULL, NULL, pC, pA);
#else

   #ifdef TCPLX
      a2blk(kb0, N, one, A, lda, rA, iA);
      #ifdef Conj_
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, crA, ciA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, crA, ciA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, rA, rA, rC, ciA, crA, iC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, ciA, crA, iC, iA, iA, rC);
      #else
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, rA, iA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, rA, iA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, rA, rA, rC, iA, rA, iC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, iA, rA, iC, iA, iA, rC);
      #endif
   #else
      a2blk(kb0, N, ATL_rone, A, lda, pA);
      Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, pA, pA, pC, pA, pA, pC);
   #endif
   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1);
   for (k=0; k < nkb; k++, A += incAk)
   {
      #ifdef TCPLX
         a2blk(kb, N, one, A, lda, rA, iA);
         #ifdef Conj_
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, iA, rC, crA, ciA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, crA, ciA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, rA, rC, ciA, crA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, ciA, crA, iC, iA, iA, rC);
         #else
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, iA, iA, rC, rA, iA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, iA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, rA, rA, rC, iA, rA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, rA, iC, iA, iA, rC);
         #endif
      #else
         a2blk(kb, N, ATL_rone, A, lda, pA);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, pA, pA, pC, pA, pA, pC);
      #endif
   }
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
   else /* Upper */
   {
      @BEGINSKIP
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ? 
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, c, N);
         #ifdef Conj_  /* must zero imag part of diagonal for HERK */
         {
            ATL_CINT ldc2=ldc+ldc;
            for (k=0; k < N; k++, c += 2, C += ldc2)
            {
               Mjoin(PATL,axpbyConj)(k+1, one, c, N, beta, C, 1);
               C[((k+1)<<1)-1] = ATL_rzero;
            }
         }
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, c, N);
      #endif
      #ifndef Conj_
      if (SCALAR_IS_ZERO(beta))
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,copy)(k+1, c, N, C, 1);
      else
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,axpby)(k+1, one, c, N, beta, C, 1);
      #endif
      @ENDSKIP
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
#endif
   free(vp);
}
#undef one
@ROUT ATL_symmR
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
/*
 * On the Right, symmetrix matrix is GEMM's B, with K=N
 */
#ifdef Conj_
int Mjoin(PATL,ophemmR)
#else
int Mjoin(PATL,opsymmR)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aS, *aB, *aC, *bS;
   #ifdef TCPLX
      TYPE *rS, *rC;
   #endif
   opinfo_t oi;
int Mjoin(PATL,opsymmInfo)
   (opinfo_t *op, ATL_UINT bv,
    ATL_CSZT M, ATL_CSZT N, ATL_CSZT lda, ATL_CSZT ldb, ATL_CSZT ldc,
     const SCALAR alpha, const SCALAR beta);

   if (!M || !N)
      return(0);
   if (N == 1) /* symmetric matrix is dense scalar! */
   {
      #ifdef TCPLX
         const register TYPE ra=(*alpha), ia=alpha[1], rA = *A;
         #ifdef Conj_
            const TYPE X[2] = {ra*rA, ia*rA};
         #else
            const register TYPE  iA=A[1];
            TYPE X[2];
            *X = ra*rA - ia*iA;
            X[1] = ra*iA + ia*rA;
         #endif
         Mjoin(PATL,axpby)(M, X, B, 1, beta, C, 1);
      #else
         Mjoin(PATL,axpby)(M, alpha*(*A), B, 1, beta, C, 1);
      #endif
      return(0);
   }
   #ifdef Conj_
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?6:4, M, N, lda, ldb,
                              ldc, alpha, beta))
   #else
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?2:0, M, N, lda, ldb,
                              ldc, alpha, beta))
   #endif
      return(1);

   szW = oi.szB;
   szW = Mmax(szW, oi.szA);
   sz = oi.szB + szW + oi.szC;
   sz = ATL_MulBySize(sz) + 3*ATL_Cachelen + oi.exsz;
   vp = malloc(sz);
   ATL_assert(vp);
   aS = ATL_AlignPtr(vp);
   #ifdef TCPLX
      rS = aS + oi.szB;
      aB = rS + oi.szB;
      aB = ATL_AlignPtr(aB);
      aC = aB + (szW<<1);
      aC = ATL_AlignPtr(aC);
      rC = aC + oi.szC;
   #else
      aB = aS + oi.szB;
      aB = ATL_AlignPtr(aB);
      aC = aB + szW;
      aC = ATL_AlignPtr(aC);
   #endif
   if (Uplo == AtlasUpper)
   @whiledef up L U
      @mif up = "L
   else /* Uplo == AtlasLower */
      @endmif
   {
      #ifdef TCPLX
         #ifdef Conj_
            #define SYCPY Mjoin(PATL,hecpy@(up)NB)
         #else
            #define SYCPY Mjoin(PATL,sycpy@(up)NB)
         #endif
         if (alpha[1] == ATL_rzero)
         {
            const register TYPE ral=(*alpha);
            if (ral == ATL_rone)
               Mjoin(SYCPY,_a1)(N, alpha, A, lda, aB, N);
            else if (ral == ATL_rnone)
               Mjoin(SYCPY,_an)(N, alpha, A, lda, aB, N);
            else
               Mjoin(SYCPY,_ar)(N, alpha, A, lda, aB, N);
         }
         else
         #ifdef Conj_
            Mjoin(SYCPY,_a1)(N, oi.ONE, A, lda, aB, N);
         #else
            Mjoin(SYCPY,_aX)(N, alpha, A, lda, aB, N);
         #endif
         #undef SYCPY
      #else
         if (alpha == ATL_rone)
            Mjoin(PATL,sycpy@(up)NB_a1)(N, alpha, A, lda, aB, N);
         else if (alpha == ATL_rnone)
            Mjoin(PATL,sycpy@(up)NB_an)(N, alpha, A, lda, aB, N);
         else
            Mjoin(PATL,sycpy@(up)NB_aX)(N, alpha, A, lda, aB, N);
      #endif
      #if 0
         Mjoin(PATL,geprint)("aG", N, N, A, lda);
         Mjoin(PATL,geprint)("aS", N, N, aB, N);
      #endif
   }
   @endwhile
   #ifdef TCPLX
      oi.b2blk(N, N, oi.ONE, aB, N, rS, aS);
      Mjoin(PATL,oploopsM)(&oi, 0, 0, B, NULL, C, 0, aB, aS, rC, aC);
   #else
      oi.b2blk(N, N, ATL_rone, aB, N, aS);
      Mjoin(PATL,oploopsM)(&oi, 0, 0, B, NULL, C, 0, aB, aS, aC, aC);
   #endif
   free(vp);
   return(0);
}

#ifndef Conj_
   #ifdef TCPLX
      #define MY_ENUM TA, Uplo
   #else
      #define ONE ATL_rone
      #define MY_ENUM Uplo
      #define TA AtlasTrans
   #endif
void Mjoin(PATL,symmR_rec)
(
   #ifdef TCPLX
   const enum ATLAS_TRANS TA,  /* AtlasConjTrans for HEMM, else AtlasTrans */
   #endif
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   if (N <= ATL_VWopgen_LAST_KB)
   {
      #ifdef TCPLX
         if (TA == AtlasConjTrans)
         {
            if (!Mjoin(PATL,ophemmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
         }
         else
            if (!Mjoin(PATL,opsymmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
      #else
         if (!Mjoin(PATL,opsymmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                  beta, C, ldc))
            return;
      #endif
   }
/*
 * C0 = B0 * A00  + beta*C0  (symm)
 * C0 = B1 * A10 + C0        (gemm)
 * C1 = B0 * A10^T + beta*C1 (gemm)
 * C1 = B1 * A11 + C1        (symm)
 */
   {
      #ifdef TCPLX
         const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      #endif
      const int NL=(N>>1), NR = N-NL;
      const TYPE *B1 = B + ldb*(NL SHIFT);
      TYPE *C1 = C + ldc*(NL SHIFT);

      ATL_assert(NL);  /* debugging, remove later */
      Mjoin(PATL,symmR_rec)(MY_ENUM, M, NL, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
      if (Uplo == AtlasLower)
      {
         const TYPE *A10 = A + (NL SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, NL, NR, alpha, 
                          B1, ldb, A10, lda, ONE, C, ldc);
         Mjoin(PATL,ammm)(AtlasNoTrans, TA, M, NR, NL, alpha, 
                          B, ldb, A10, lda, beta, C1, ldc);
      }
      else /* Upper matrix */
      {
         const TYPE *A01 = A + NL*(lda SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, TA, M, NL, NR, alpha, 
                          B1, ldb, A01, lda, ONE, C, ldc);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, NR, NL, alpha, 
                          B, ldb, A01, lda, beta, C1, ldc);
      }
      Mjoin(PATL,symmR_rec)(MY_ENUM, M, NR, alpha, A+(NL SHIFT)*(lda+1), lda, 
                            B1, ldb, ONE, C1, ldc);
   }
}
   #undef MY_ENUM
   #ifdef TCPLX
      #define MY_TRAN AtlasTrans,
   #else
      #undef TA
      #define MY_TRAN
   #endif
#else
   #define MY_TRAN AtlasConjTrans,
   void Mjoin(PATL,symmL_rec)
      (const enum ATLAS_TRANS, const enum ATLAS_UPLO, ATL_CSZT, ATL_CSZT,
       const SCALAR, const TYPE*, ATL_CSZT, const TYPE*, ATL_CSZT,
       const SCALAR, TYPE*, ATL_CSZT);
#endif
@ROUT ATL_symmL
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
/*
 * On the left, symmetrix matrix is GEMM's A, with K=M
 */
#ifdef Conj_
int Mjoin(PATL,ophemmL)
#else
int Mjoin(PATL,opsymmL)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aA, *aB, *aC, *bA;
   #ifdef TCPLX
      TYPE *rA, *rC;
   #endif
   opinfo_t oi;
int Mjoin(PATL,opsymmInfo)
   (opinfo_t *op, ATL_UINT bv,
    ATL_CSZT M, ATL_CSZT N, ATL_CSZT lda, ATL_CSZT ldb, ATL_CSZT ldc,
     const SCALAR alpha, const SCALAR beta);

   if (!M || !N)
      return(0);
   if (M == 1) /* symmetric matrix is dense scalar! */
   {
      #ifdef TCPLX
         const register TYPE ra=(*alpha), ia=alpha[1], rA = *A;
         #ifdef Conj_
            const TYPE X[2] = {ra*rA, ia*rA};
         #else
            const register TYPE  iA=A[1];
            TYPE X[2];
            *X = ra*rA - ia*iA;
            X[1] = ra*iA + ia*rA;
         #endif
         Mjoin(PATL,axpby)(N, X, B, ldb, beta, C, ldc);
      #else
         Mjoin(PATL,axpby)(N, alpha*(*A), B, ldb, beta, C, ldc);
      #endif
      return(0);
   }
   #ifdef Conj_
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?7:5, M, N, lda, ldb,
                              ldc, alpha, beta))
   #else
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?3:1, M, N, lda, ldb,
                              ldc, alpha, beta))
   #endif
      return(1);

   szW = oi.szB;
   szW = Mmax(szW, oi.szA);
   sz = oi.szA + szW + oi.szC;
   sz = ATL_MulBySize(sz) + ATL_Cachelen + oi.exsz;
   vp = malloc(sz);
   ATL_assert(vp);
   aA = ATL_AlignPtr(vp);
   #ifdef TCPLX
      rA = aA + oi.szA;
      aB = rA + oi.szA;
      aC = aB + (szW<<1);
      rC = aC + oi.szC;
   #else
      aB = aA + oi.szA;
      aC = aB + szW;
   #endif
   if (Uplo == AtlasUpper)
   @whiledef up L U
      @mif up = "L
   else /* Uplo == AtlasLower */
      @endmif
   {
      #ifdef TCPLX
         #ifdef Conj_
            #define SYCPY Mjoin(PATL,hecpy@(up)NB)
         #else
            #define SYCPY Mjoin(PATL,sycpy@(up)NB)
         #endif
         if (alpha[1] == ATL_rzero)
         {
            const register TYPE ral=(*alpha);
            if (ral == ATL_rone)
               Mjoin(SYCPY,_a1)(M, alpha, A, lda, aB, M);
            else if (ral == ATL_rnone)
               Mjoin(SYCPY,_an)(M, alpha, A, lda, aB, M);
            else
               Mjoin(SYCPY,_ar)(M, alpha, A, lda, aB, M);
         }
         else
         #ifdef Conj_
            Mjoin(SYCPY,_a1)(M, oi.ONE, A, lda, aB, M);
         #else
            Mjoin(SYCPY,_aX)(M, alpha, A, lda, aB, M);
         #endif
         #if 0
            Mjoin(PATL,geprint)("aG", M, M, A, lda);
            Mjoin(PATL,geprint)("aS", M, M, aB, M);
         #endif
         #undef SYCPY
      #else
         if (alpha == ATL_rone)
            Mjoin(PATL,sycpy@(up)NB_a1)(M, alpha, A, lda, aB, M);
         else if (alpha == ATL_rnone)
            Mjoin(PATL,sycpy@(up)NB_an)(M, alpha, A, lda, aB, M);
         else
            Mjoin(PATL,sycpy@(up)NB_aX)(M, alpha, A, lda, aB, M);
      #endif
   }
   @endwhile
   #ifdef TCPLX
      oi.a2blk(M, M, oi.ONE, aB, M, rA, aA);
      Mjoin(PATL,oploopsN)(&oi, 0, 0, NULL, B, C, 0, aA, aB, rC, aC);
   #else
      oi.a2blk(M, M, ATL_rone, aB, M, aA);
      Mjoin(PATL,oploopsN)(&oi, 0, 0, NULL, B, C, 0, aA, aB, aC, aC);
   #endif
   free(vp);
   return(0);
}

#ifndef Conj_
   #ifdef TCPLX
      #define MY_ENUM TA, Uplo
   #else
      #define ONE ATL_rone
      #define MY_ENUM Uplo
      #define TA AtlasTrans
   #endif
void Mjoin(PATL,symmL_rec)
(
   #ifdef TCPLX
   const enum ATLAS_TRANS TA,  /* AtlasConjTrans for HEMM, else AtlasTrans */
   #endif
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   if (M <= ATL_VWopgen_LAST_KB)
   {
      #ifdef TCPLX
         if (TA == AtlasConjTrans)
         {
            if (!Mjoin(PATL,ophemmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
         }
         else
            if (!Mjoin(PATL,opsymmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
      #else
         if (!Mjoin(PATL,opsymmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                  beta, C, ldc))
            return;
      #endif
   }
/*
 * C0 = A00 * B0 + beta*C0 (symm)
 * C0 = A10^T * B1 + C0    (gemm)
 * C1 = A10 * B0 + beta*C1 (gemm)
 * C1 = A11 * B1 + C1      (symm)
 */
   {
      #ifdef TCPLX
         const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      #endif
      const int ML=(M>>1), MR = M-ML;
      const TYPE *B1 = B + (ML SHIFT);
      TYPE *C1 = C + (ML SHIFT);

      ATL_assert(ML);  /* debugging, remove later */
      Mjoin(PATL,symmL_rec)(MY_ENUM, ML, N, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
      if (Uplo == AtlasLower)
      {
         const TYPE *A10 = A + (ML SHIFT);
         Mjoin(PATL,ammm)(TA, AtlasNoTrans, ML, N, MR, alpha, A10, lda,
                          B1, ldb, ONE, C, ldc);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, MR, N, ML, alpha, 
                          A10, lda, B, ldb, beta, C1, ldc);
      }
      else /* Upper matrix */
      {
         const TYPE *A01 = A + ML*(lda SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, ML, N, MR, alpha, 
                          A01, lda, B1, ldb, ONE, C, ldc);
         Mjoin(PATL,ammm)(TA, AtlasNoTrans, MR, N, ML, alpha, 
                          A01, lda, B, ldb, beta, C1, ldc);
      }
      Mjoin(PATL,symmL_rec)(MY_ENUM, MR, N, alpha, A+(ML SHIFT)*(lda+1), 
                            lda, B1, ldb, ONE, C1, ldc);
   }
}
   #undef MY_ENUM
   #ifdef TCPLX
      #define MY_TRAN AtlasTrans,
   #else
      #undef TA
      #define MY_TRAN
   #endif
#else
   #define MY_TRAN AtlasConjTrans,
   void Mjoin(PATL,symmL_rec)
      (const enum ATLAS_TRANS, const enum ATLAS_UPLO, ATL_CSZT, ATL_CSZT,
       const SCALAR, const TYPE*, ATL_CSZT, const TYPE*, ATL_CSZT,
       const SCALAR, TYPE*, ATL_CSZT);
#endif
void Mjoin(PATL,symmR_rec)
(
   #ifdef TCPLX
   const enum ATLAS_TRANS TA,  /* AtlasConjTrans for HEMM, else AtlasTrans */
   #endif
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
);
#ifdef Conj_
void Mjoin(PATL,hemm)
#else
void Mjoin(PATL,symm)
#endif
(
   const enum ATLAS_SIDE  Side,
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aA, *aB, *aC, *bA;
   opinfo_t oi;
   ATL_UINT bv;

   if (!M || !N)
      return;
   if (SCALAR_IS_ZERO(alpha))  /* doing nothing but scaling C */
   {
      if (!SCALAR_IS_ONE(beta))  /* if there is scaling of C to do */
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
     
      return;
   }

   if (Side == AtlasLeft) /* K=M, A is GEMM's A */
   {
      #if defined(Conj_) || !defined(TCPLX)
      if (N == 1) /* really HEMV/SYMV */
      {
         #ifdef Conj_
            Mjoin(PATL,hemv)(Uplo, M, alpha, A, lda, B, 1, beta, C, 1);
         #else
            Mjoin(PATL,symv)(Uplo, M, alpha, A, lda, B, 1, beta, C, 1);
         #endif
         return;
      }
      #endif
      Mjoin(PATL,symmL_rec)(MY_TRAN Uplo, M, N, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
   }
   else                   /* Right: K=N, A is GEMM's B */
   {
      Mjoin(PATL,symmR_rec)(MY_TRAN Uplo, M, N, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
      @BEGINSKIP
      #ifdef Conj_
      Mjoin(PATL,hemm_APR)(Side, Uplo, M, N, alpha, A, lda, B, ldb, 
                           beta, C, ldc);
      #else
      Mjoin(PATL,symm_APR)(Side, Uplo, M, N, alpha, A, lda, B, ldb, 
                           beta, C, ldc);
      #endif
      @ENDSKIP
   }
}
