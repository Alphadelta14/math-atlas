@extract -b @(topd)/gen.inc what=crsetup
@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@ifdef @type
@extract -b @(incd)/f77.inc what=type type=@(@type)
@endifdef
@ROUT lamch
#include "atlas_misc.h"
#include "atlas_f77.h"
#include "atlas_lapack.h"
#include "atlas_lamch.h"

#if defined(NoChange)
   #define F77lamch Mjoin(PRE,lamch)
#elif defined(UpCase)
   #define F77lamch Mjoin(PREU,LAMCH)
#elif defined(Add__)
   #define F77lamch Mjoin(PRE,lamch_)
#else /* Add_ */
   #define F77lamch Mjoin(PRE,lamch_)
#endif

#if defined(StringSunStyle)
TYPE F77lamch(char *f77what, F77_INTEGER len)
#elif defined(StringStructPtr)
TYPE F77lamch(F77_CHAR *f77what)
#else
TYPE F77lamch(F77_CHAR f77what)
#endif
{
   char cwhat;

   cwhat = ATL_F2C_TransChar(f77what);
   switch(cwhat)
   {
@multidef nm
   EPSILON BASE PRECISION MANTDIG MINEXP MAXEXP UNDERTHRESH OVERTHRESH
   SAFMIN ROUND
@endmultidef
@whiledef le e b p n m l u o s r
   case '@(le)':
   case '@up@(le)':
      return(ATL_la@up@(nm));
   @undef nm
@endwhile
   default:
     return(0.0);
   }
   return(0.0);
}
@ROUT IEEECK
      INTEGER          FUNCTION IEEECK( ISPEC, ZERO, ONE )
*
*  -- LAPACK auxiliary routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     June 30, 1998
*
*     .. Scalar Arguments ..
      INTEGER            ISPEC
      REAL               ONE, ZERO
*     ..
*
*  Purpose
*  =======
*
*  IEEECK is called from the ILAENV to verify that Infinity and
*  possibly NaN arithmetic is safe (i.e. will not trap).
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*          Specifies whether to test just for inifinity arithmetic
*          or whether to test for infinity and NaN arithmetic.
*          = 0: Verify infinity arithmetic only.
*          = 1: Verify infinity and NaN arithmetic.
*
*  ZERO    (input) REAL
*          Must contain the value 0.0
*          This is passed to prevent the compiler from optimizing
*          away this code.
*
*  ONE     (input) REAL
*          Must contain the value 1.0
*          This is passed to prevent the compiler from optimizing
*          away this code.
*
*  RETURN VALUE:  INTEGER
*          = 0:  Arithmetic failed to produce the correct answers
*          = 1:  Arithmetic produced the correct answers
*
*     .. Local Scalars ..
      REAL               NAN1, NAN2, NAN3, NAN4, NAN5, NAN6, NEGINF,
     $                   NEGZRO, NEWZRO, POSINF
*     ..
*     .. Executable Statements ..
      IEEECK = 1
*
      POSINF = ONE / ZERO
      IF( POSINF.LE.ONE ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      NEGINF = -ONE / ZERO
      IF( NEGINF.GE.ZERO ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      NEGZRO = ONE / ( NEGINF+ONE )
      IF( NEGZRO.NE.ZERO ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      NEGINF = ONE / NEGZRO
      IF( NEGINF.GE.ZERO ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      NEWZRO = NEGZRO + ZERO
      IF( NEWZRO.NE.ZERO ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      POSINF = ONE / NEWZRO
      IF( POSINF.LE.ONE ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      NEGINF = NEGINF*POSINF
      IF( NEGINF.GE.ZERO ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      POSINF = POSINF*POSINF
      IF( POSINF.LE.ONE ) THEN
         IEEECK = 0
         RETURN
      END IF
*
*
*
*
*     Return if we were only asked to check infinity arithmetic
*
      IF( ISPEC.EQ.0 )
     $   RETURN
*
      NAN1 = POSINF + NEGINF
*
      NAN2 = POSINF / NEGINF
*
      NAN3 = POSINF / POSINF
*
      NAN4 = POSINF*ZERO
*
      NAN5 = NEGINF*NEGZRO
*
      NAN6 = NAN5*0.0
*
      IF( NAN1.EQ.NAN1 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      IF( NAN2.EQ.NAN2 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      IF( NAN3.EQ.NAN3 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      IF( NAN4.EQ.NAN4 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      IF( NAN5.EQ.NAN5 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      IF( NAN6.EQ.NAN6 ) THEN
         IEEECK = 0
         RETURN
      END IF
*
      RETURN
      END
@ROUT ILAENV
      INTEGER          FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3,
     $                 N4 )
*
*  -- LAPACK auxiliary routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     June 30, 1999
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      CHARACTER*( * )    NAME, OPTS
      INTEGER            ISPEC, N1, N2, N3, N4
*     ..
*
*  Purpose
*  =======
*
*  ILAENV is called from the LAPACK routines to choose problem-dependent
*  parameters for the local environment.  See ISPEC for a description of
*  the parameters.
*
*  This version provides a set of parameters which should give good,
*  but not optimal, performance on many of the currently available
*  computers.  Users are encouraged to modify this subroutine to set
*  the tuning parameters for their particular machine using the option
*  and problem size information in the arguments.
*
*  This routine will not function correctly if it is converted to all
*  lower case.  Converting it to all upper case is allowed.
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*          Specifies the parameter to be returned as the value of
*          ILAENV.
*          = 1: the optimal blocksize; if this value is 1, an unblocked
*               algorithm will give the best performance.
*          = 2: the minimum block size for which the block routine
*               should be used; if the usable block size is less than
*               this value, an unblocked routine should be used.
*          = 3: the crossover point (in a block routine, for N less
*               than this value, an unblocked routine should be used)
*          = 4: the number of shifts, used in the nonsymmetric
*               eigenvalue routines
*          = 5: the minimum column dimension for blocking to be used;
*               rectangular blocks must have dimension at least k by m,
*               where k is given by ILAENV(2,...) and m by ILAENV(5,...)
*          = 6: the crossover point for the SVD (when reducing an m by n
*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
*               this value, a QR factorization is used first to reduce
*               the matrix to a triangular form.)
*          = 7: the number of processors
*          = 8: the crossover point for the multishift QR and QZ methods
*               for nonsymmetric eigenvalue problems.
*          = 9: maximum size of the subproblems at the bottom of the
*               computation tree in the divide-and-conquer algorithm
*               (used by xGELSD and xGESDD)
*          =10: ieee NaN arithmetic can be trusted not to trap
*          =11: infinity arithmetic can be trusted not to trap
*
*  NAME    (input) CHARACTER*(*)
*          The name of the calling subroutine, in either upper case or
*          lower case.
*
*  OPTS    (input) CHARACTER*(*)
*          The character options to the subroutine NAME, concatenated
*          into a single character string.  For example, UPLO = 'U',
*          TRANS = 'T', and DIAG = 'N' for a triangular routine would
*          be specified as OPTS = 'UTN'.
*
*  N1      (input) INTEGER
*  N2      (input) INTEGER
*  N3      (input) INTEGER
*  N4      (input) INTEGER
*          Problem dimensions for the subroutine NAME; these may not all
*          be required.
*
* (ILAENV) (output) INTEGER
*          >= 0: the value of the parameter specified by ISPEC
*          < 0:  if ILAENV = -k, the k-th argument had an illegal value.
*
*  Further Details
*  ===============
*
*  The following conventions have been used when calling ILAENV from the
*  LAPACK routines:
*  1)  OPTS is a concatenation of all of the character options to
*      subroutine NAME, in the same order that they appear in the
*      argument list for NAME, even if they are not used in determining
*      the value of the parameter specified by ISPEC.
*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
*      that they appear in the argument list for NAME.  N1 is used
*      first, N2 second, and so on, and unused problem dimensions are
*      passed a value of -1.
*  3)  The parameter value returned by ILAENV is checked for validity in
*      the calling subroutine.  For example, ILAENV is used to retrieve
*      the optimal blocksize for STRTRI as follows:
*
*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
*      IF( NB.LE.1 ) NB = MAX( 1, N )
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            CNAME, SNAME, SREAL, DREAL, SCPLX, DCPLX
      CHARACTER*1        C1
      CHARACTER*2        C2, C4
      CHARACTER*3        C3
      CHARACTER*6        SUBNAM
      INTEGER            I, IC, IZ
      INTEGER            IROUT, IOPTS, ITMP, IOPT0
@multidef rt 
   getrf geqrf ormqr rorgen cungen gehrd gebrd getri potrf sytrf sytrd hetrf
   hetrd hegst hbgst hpgst spgst sbgst sygst stebz
   gbtrf pbtrf trtri lauum
@endmultidef
@declare "      integer " y y
   @whiledef rt
      @define rt2 @@(rt)@
      LA@(rt)
   @endwhile
   LAupper LAlower LAleft LAright LAunit LAnonunit
@enddeclare
@define i @1@
@whiledef rt2
      data LA@(rt2) /@(i)/
   @iexp i @(i) 2 *
@endwhile
      data LAupper    /1/
      data LAlower    /2/
      data LAright    /4/
      data LAleft     /8/
      data LAunit     /16/
      data LAnonunit  /32/
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            IEEECK
      EXTERNAL           IEEECK, LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL ATL_F77WRAP_ILAENV
*     ..
*     .. Executable Statements ..
      C1 = NAME(1:1)

*     Convert NAME to upper case if the first character is lower case.
*
      ILAENV = 1
      C1 = NAME(1:1)
      SREAL = LSAME(c1, 'S')
      DREAL = LSAME(c1, 'D')
      SCPLX = LSAME(c1, 'C')
      DCPLX = LSAME(c1, 'Z')
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1:1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN
*
*        ASCII character set
*
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 10 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.97 .AND. IC.LE.122 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   10       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN
*
*        EBCDIC character set
*
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $       ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN
            SUBNAM( 1:1 ) = CHAR( IC+64 )
            DO 20 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $             ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $             ( IC.GE.162 .AND. IC.LE.169 ) )
     $            SUBNAM( I:I ) = CHAR( IC+64 )
   20       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN
*
*        Prime machines:  ASCII+128
*
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 30 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.225 .AND. IC.LE.250 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   30       CONTINUE
         END IF
      END IF
*
      C1 = SUBNAM( 1:1 )
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2:3 )
      C3 = SUBNAM( 4:6 )
      C4 = C3( 2:3 )
*
*     Translate F77 string name into ATLAS's enumerated type
*
      iopt0 = 0
      irout = 0
      if ( C2.EQ.'GE' ) then
         if ( c3.eq.'TRF') then
            irout = lagetrf
         else if (c3 .eq. 'QRF') then
            irout = lageqrf
            iopt0 = laright + laupper
         else if (c3 .eq. 'RQF') then
            irout = lageqrf
            iopt0 = laleft  + laupper
         else if (c3 .eq. 'LQF') then
            irout = lageqrf
            iopt0 = laleft  + lalower
         else if (c3 .eq. 'QLF') then
            irout = lageqrf
            iopt0 = laright + lalower
         else if (c3 .eq. 'HRD') then
            irout = lagehrd
         else if (c3 .eq. 'BRD') then
            irout = lagebrd
         else if (c3 .eq. 'TRI') then
            irout = lagetri
         endif
      else if (c2 .eq. 'PO') then
         if (c3 .eq. 'TRF') then
            irout = lapotrf
         endif
      else if (c2 .eq. 'SY') then
         if (c3 .eq. 'TRF') then
            irout = lasytrf
         else if (c3 .eq. 'TRD') then
            irout = lasytrd
         else if (c3 .eq. 'GST') then
            irout= lasygst
         end if
      else if (cname .and. c2.eq.'HE') then
         if (c3 .eq. 'TRF') then
            irout = lahetrf
         else if (c3 .eq. 'TRD') then
            irout = lahetrd
         else if (c3 .eq. 'GST') then
            irout = lahegst
         endif
      else if (sname .and. c2.eq.'OR') then
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               irout = larorgen
            endif
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF (C4.EQ.'QR') THEN
               irout = laormqr
               iopt0 = laright + laupper
            ELSE IF (C4.EQ.'QL') THEN
               irout = laormqr
               iopt0 = laright + lalower
            ELSE IF (C4.EQ.'RQ') THEN
               irout = laormqr
               iopt0 = laleft  + laupper
            ELSE IF (C4.EQ.'LQ') THEN
               irout = laormqr
               iopt0 = laleft  + lalower
            ELSE IF(C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' ) THEN
               irout = larorgen
            endif
         endif
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               irout = lacungen
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF (C4.EQ.'QR') THEN
               irout = laormqr
               iopt0 = laright + laupper
            ELSE IF (C4.EQ.'QL') THEN
               irout = laormqr
               iopt0 = laright + lalower
            ELSE IF (C4.EQ.'RQ') THEN
               irout = laormqr
               iopt0 = laleft  + laupper
            ELSE IF (C4.EQ.'LQ') THEN
               irout = laormqr
               iopt0 = laleft  + lalower
            ELSE IF( C4.EQ.'HR' .OR. C4.EQ.'TR' .OR. C4.EQ.'BR' ) THEN
               irout = lacungen
            END IF
         END IF
      ELSE IF( C2.EQ.'GB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            irout = lagbtrf
         endif
      ELSE IF( C2.EQ.'PB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            irout = lapbtrf
         endif
      ELSE IF( C2.EQ.'TR' ) THEN
         IF( C3.EQ.'TRI' ) THEN
            irout = latrtri
         endif
      ELSE IF( C2.EQ.'LA' ) THEN
         IF( C3.EQ.'UUM' ) THEN
            irout = lalauum
         endif
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN
         IF( C3.EQ.'EBZ' ) THEN
            irout = lastebz
         endif
      end if
@beginskip
*
*     Signal error if name translation has failed if using ISPEC that expect
*     known names.  ISPECs that don't examine names are: 4-16
*
      if ( irout.eq.0 .and. (ISPEC.lt.4 .or. ISPEC.gt.16) ) then
         CALL XERBLA( 'ILAENV', 2 )
         ILAENV = 0
         RETURN
      endif
@endskip
*
*     Translate character OPTS string to ATLAS's enumerated bitfield.
*     OPTS presently unused in ILAENV, so we presently don't translate them,
*     but instead just plug in the data type.
*     If a given routine actually uses opts, we need to look exactly
*     which options it takes, and do per-routine translation here.
*     IOPT0 is additional flags we use to distinguish between QR variants
*
      IOPTS = 0
      if (C1 .eq. 'S') then
         IOPTS = 2**27
      else if (C1 .eq. 'D') then
         IOPTS = 2**28
      else if (C1 .eq. 'C') then
         IOPTS = 2**29
      else if (C1 .eq. 'Z') then
         IOPTS = 2**30
      end if
      IOPTS = IOPTS + iopt0
      CALL ATL_F77WRAP_ILAENV(ISPEC, IROUT, IOPTS, N1, N2, N3, N4, ITMP)
      IlAENV = ITMP
@beginskip
      EXTERNAL ATL_F77WRAP_SGETNB, ATL_F77WRAP_DGETNB,
     $         ATL_F77WRAP_CGETNB, ATL_F77WRAP_ZGETNB
*     ..
*     .. Executable Statements ..
*
      GO TO ( 100, 100, 100, 400, 500, 600, 700, 800, 900, 1000,
     $        1100 ) ISPEC
*
*     Invalid value for ISPEC
*
      ILAENV = -1
      RETURN
*
  100 CONTINUE
*
*     Convert NAME to upper case if the first character is lower case.
*
      ILAENV = 1
      C1 = NAME(1:1)
      SREAL = LSAME(c1, 'S')
      DREAL = LSAME(c1, 'D')
      SCPLX = LSAME(c1, 'C')
      DCPLX = LSAME(c1, 'Z')
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1:1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN
*
*        ASCII character set
*
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 10 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.97 .AND. IC.LE.122 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   10       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN
*
*        EBCDIC character set
*
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $       ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN
            SUBNAM( 1:1 ) = CHAR( IC+64 )
            DO 20 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $             ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $             ( IC.GE.162 .AND. IC.LE.169 ) )
     $            SUBNAM( I:I ) = CHAR( IC+64 )
   20       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN
*
*        Prime machines:  ASCII+128
*
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 30 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.225 .AND. IC.LE.250 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   30       CONTINUE
         END IF
      END IF
*
      C1 = SUBNAM( 1:1 )
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2:3 )
      C3 = SUBNAM( 4:6 )
      C4 = C3( 2:3 )
*
      GO TO ( 110, 200, 300 ) ISPEC
*
  110 CONTINUE
*
*     ISPEC = 1:  block size
*
*     ATLAS sets default blocking factor to the internal blocking factor of
*     GEMM.  For particular routines, we then examine input parameters to
*     see if we should reduce it (for instance, to ensure that we don't
*     spend too much time in the unblocked level-2 portion of the algorithm).
*     Note that the recursive routines provided by ATLAS 
*     (presently, LU & Cholesky) do not need this value.
*
      NB = 60
      if (SREAL) then
         CALL ATL_F77WRAP_SGETNB(NB)
      else if (DREAL) then
         CALL ATL_F77WRAP_DGETNB(NB)
      else if (SCPLX) then
         CALL ATL_F77WRAP_CGETNB(NB)
      else if (DCPLX) then
         CALL ATL_F77WRAP_ZGETNB(NB)
      endif
      ATLNB = NB
*    
*     Find minimum dimension of problem: don't want NB bigger than that
*
      MN = N1
      IF (N2 .gt. 0) THEN
         IF (MN .gt. N2) MN = N2
         if (N3 .gt. 0) then
            if (MN .gt. N3) MN = N3
            if (N4 .gt. 0) then
               if (MN .gt. N4) MN = N4
            end if
         end if
      END IF
*
*     Make sure NB is not close to size of entire dimension, unless smallest
*     dimension is so small you might as well use unblocked code the whole way
*
      if (MN .le. 3) then
         NB = MN;
      else if (NB*5 .gt. MN) then
         if (MN .lt. 16) then
            if (MN .lt. 8) then
               NB = 2
            else
               NB = 4
            end if
         else
           NB = (MN / 4)
           if (NB .gt. 4) then
              NB = (NB/4)*4
           endif
         end if
      end if
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = NB
*
*        QR requires extra flops for blocking, so restrain total NB
*
         ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $            C3.EQ.'QLF' ) THEN
            IF (NB .GT. 80) then
               IF( SNAME ) THEN
                  NB = 60
               ELSE
                  NB = 40
               END IF
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF (NB .GT. 80) then
               IF( SNAME ) THEN
                  NB = 60
               ELSE
                  NB = 40
               END IF
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF (NB .GT. 80) then
               IF( SNAME ) THEN
                  NB = 60
               ELSE
                  NB = 40
               END IF
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
               NB = NB
         END IF
      ELSE IF( C2.EQ.'PO' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = NB
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = NB
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            IF (NB .GT. 80) then
               IF( SNAME ) THEN
                  NB = 60
               ELSE
                  NB = 40
               END IF
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN
            NB = NB
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = NB
         ELSE IF( C3.EQ.'TRD' ) THEN
            IF (NB .GT. 80) then
               IF( SNAME ) THEN
                  NB = 60
               ELSE
                  NB = 40
               END IF
            END IF
         ELSE IF( C3.EQ.'GST' ) THEN
            NB = NB
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               IF (NB .GT. 80) NB = 60
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               IF (NB .GT. 80) NB = 60
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               IF (NB .GT. 80) NB = 40
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               IF (NB .GT. 80) NB = 40
            END IF
         END IF
      ELSE IF( C2.EQ.'GB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               nb = nb
            ELSE
               nb = nb
            END IF
         END IF
      ELSE IF( C2.EQ.'PB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               IF( N2.LE.64 ) THEN
                  NB = nb
               ELSE
                  NB = nb
               END IF
            ELSE
               IF( N2.LE.64 ) THEN
                  NB = nb
               ELSE
                  NB = nb
               END IF
            END IF
         END IF
      ELSE IF( C2.EQ.'TR' ) THEN
         IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NB = nb
            ELSE
               NB = nb
            END IF
         END IF
      ELSE IF( C2.EQ.'LA' ) THEN
         IF( C3.EQ.'UUM' ) THEN
            IF( SNAME ) THEN
               NB = nb
            ELSE
               NB = nb
            END IF
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN
         IF( C3.EQ.'EBZ' ) THEN
            NB = 1
         END IF
      END IF
*
      ILAENV = NB
      RETURN
*
  200 CONTINUE
*
*     ISPEC = 2:  minimum block size
*
      NBMIN = 2
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 8
            ELSE
               NBMIN = 8
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      END IF
      ILAENV = NBMIN
      RETURN
*
  300 CONTINUE
*
*     ISPEC = 3:  crossover point
*
      NX = 0
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NX = 32
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NX = 32
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      END IF
      ILAENV = NX
      RETURN
*
  400 CONTINUE
*
*     ISPEC = 4:  number of shifts (used by xHSEQR)
*
      ILAENV = 6
      RETURN
*
  500 CONTINUE
*
*     ISPEC = 5:  minimum column dimension (not used)
*
      ILAENV = 2
      RETURN
*
  600 CONTINUE 
*
*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
*
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 )
      RETURN
*
  700 CONTINUE
*
*     ISPEC = 7:  number of processors (not used)
*
      ILAENV = 1
      RETURN
*
  800 CONTINUE
*
*     ISPEC = 8:  crossover point for multishift (used by xHSEQR)
*
      ILAENV = 50
      RETURN
*
  900 CONTINUE
*
*     ISPEC = 9:  maximum size of the subproblems at the bottom of the
*                 computation tree in the divide-and-conquer algorithm
*                 (used by xGELSD and xGESDD)
*
      ILAENV = 25
      RETURN
*
 1000 CONTINUE
*
*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap
*
C     ILAENV = 0
      ILAENV = 1
      IF( ILAENV.EQ.1 ) THEN
         ILAENV = IEEECK( 0, 0.0, 1.0 ) 
      END IF
      RETURN
*
 1100 CONTINUE
*
*     ISPEC = 11: infinity arithmetic can be trusted not to trap
*
C     ILAENV = 0
      ILAENV = 1
      IF( ILAENV.EQ.1 ) THEN
         ILAENV = IEEECK( 1, 0.0, 1.0 ) 
      END IF
@endskip
      RETURN
*
*     End of ILAENV
*
      END
@ROUT POSV
      SUBROUTINE @(pre)POSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
*
*  -- LAPACK driver routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      CHARACTER UPLO
      INTEGER   INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      @(type) A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)POSV computes the solution to a @(comtyp) system of linear equations
*     A * X = B,
*  where A is an N-by-N @(hesy) positive definite matrix and X and B
*  are N-by-NRHS matrices.
*
*  The Cholesky decomposition is used to factor A as
*     A = U**@(HT)* U,  if UPLO = 'U', or
*     A = L * L**@(HT),  if UPLO = 'L',
*  where U is an upper triangular matrix and  L is a lower triangular
*  matrix.  The factored form of A is then used to solve the system of
*  equations A * X = B.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The number of linear equations, i.e., the order of the
*          matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the @(hesy) matrix A.  If UPLO = 'U', the leading
*          N-by-N upper triangular part of A contains the upper
*          triangular part of the matrix A, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading N-by-N lower triangular part of A contains the lower
*          triangular part of the matrix A, and the strictly upper
*          triangular part of A is not referenced.
*
*          On exit, if INFO = 0, the factor U or L from the Cholesky
*          factorization A = U**@(HT)*U or A = L*L**@(HT).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  B       (input/output) @(type) array, dimension (LDB,NRHS)
*          On entry, the N-by-NRHS right hand side matrix B.
*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, the leading minor of order i of A is not
*                positive definite, so the factorization could not be
*                completed, and the solution has not been computed.
*
*  =====================================================================
*
*     ..
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      INTEGER            IUPLO
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)POSV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( .NOT.LSAME( UPLO, 'U' ) .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)POSV ', -INFO )
         RETURN
      END IF

      IF ( LSAME(UPLO, 'U') ) THEN
         IUPLO = ATLASUPPER
      ELSE
         IUPLO = ATLASLOWER
      ENDIF

      CALL ATL_F77WRAP_@(pre)POSV( IUPLO, N, NRHS, A, LDA, B, LDB, INFO )

      RETURN
      END
@ROUT POTRF
      SUBROUTINE @(pre)POTRF( UPLO, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      CHARACTER UPLO
      INTEGER   INFO, LDA, N
*     ..
*     .. Array Arguments ..
      @(type) A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
@TYPE DCPLX SCPLX
   @define shap @Hermition@
   @define T @H@
*  @(pre)POTRF computes the Cholesky factorization of a complex Hermitian
*  positive definite matrix A.
*
*  The factorization has the form
*     A = U**H * U,  if UPLO = 'U', or
*     A = L  * L**H,  if UPLO = 'L',
*  where U is an upper triangular matrix and L is lower triangular.
@TYPE SREAL DREAL
   @define shap @symmetric@
   @define T @T@
*  @(pre)POTRF computes the Cholesky factorization of a real symmetric
*  positive definite matrix A.
*
*  The factorization has the form
*     A = U**T * U,  if UPLO = 'U', or
*     A = L  * L**T,  if UPLO = 'L',
*  where U is an upper triangular matrix and L is lower triangular.
@TYPE !
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the @(shap) matrix A.  If UPLO = 'U', the leading
*          N-by-N upper triangular part of A contains the upper
*          triangular part of the matrix A, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading N-by-N lower triangular part of A contains the lower
*          triangular part of the matrix A, and the strictly upper
*          triangular part of A is not referenced.
*
*          On exit, if INFO = 0, the factor U or L from the Cholesky
*          factorization A = U**@(T)*U or A = L*L**@(T).
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, the leading minor of order i is not
*                positive definite, and the factorization could not be
*                completed.
*
*  =====================================================================
*
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
      INTEGER            IUPLO
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)POTRF', -INFO )
         RETURN
      END IF

      IF (UPPER) THEN
         IUPLO = ATLASUPPER
      ELSE
         IUPLO = ATLASLOWER
      ENDIF

      CALL ATL_F77WRAP_@(pre)POTRF( IUPLO, N, A, LDA, INFO )

      RETURN
      END
@ROUT POTRS
      SUBROUTINE @(pre)POTRS( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      CHARACTER UPLO
      INTEGER   INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      @(type) A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)POTRS solves a system of linear equations A*X = B with a @(hesy)
*  positive definite matrix A using the Cholesky factorization
*  A = U**@(HT)*U or A = L*L**@(HT) computed by @(pre)POTRF.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input) @(type) array, dimension (LDA,N)
*          The triangular factor U or L from the Cholesky factorization
*          A = U**H*U or A = L*L**H, as computed by ZPOTRF.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  B       (input/output) @(type) array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
      INTEGER            IUPLO
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)POTRS
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)POTRS', -INFO )
         RETURN
      END IF

      IF (UPPER) THEN
         IUPLO = ATLASUPPER
      ELSE
         IUPLO = ATLASLOWER
      ENDIF

      CALL ATL_F77WRAP_@(pre)POTRS( IUPLO, N, NRHS, A, LDA, B, LDB )

      RETURN
      END
@ROUT GETRS
      SUBROUTINE @(pre)GETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      CHARACTER TRANS
      INTEGER   INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER IPIV( * )
      @(type) A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)GETRS solves a system of linear equations
@TYPE SCPLX DCPLX
*     A * X = B,  A**T * X = B,  or  A**H * X = B
@TYPE SREAL DREAL
*     A * X = B  or  A' * X = B
@TYPE SREAL DREAL SCPLX DCPLX
*  with a general N-by-N matrix A using the LU factorization computed
*  by @(pre)GETRF.
*
*  Arguments
*  =========
*
*  TRANS   (input) CHARACTER*1
*          Specifies the form of the system of equations:
*          = 'N':  A * X = B     (No transpose)
*          = 'T':  A**T * X = B  (Transpose)
*          = 'C':  A**H * X = B  (Conjugate transpose)
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input) @(type) array, dimension (LDA,N)
*          The factors L and U from the factorization A = P*L*U
*          as computed by @(pre)GETRF.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices from @(pre)GETRF; for 1<=i<=N, row i of the
*          matrix was interchanged with row IPIV(i).
*
*  B       (input/output) @(type) array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      LOGICAL NOTRAN
      INTEGER ITRAN
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)GETRS
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NOTRAN = LSAME( TRANS, 'N' )
      IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) .AND. .NOT.
     $    LSAME( TRANS, 'C' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -8
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)GETRS', -INFO )
         RETURN
      END IF

      IF (NOTRAN) THEN
         ITRAN = ATLASNOTRANS
@TYPE SCPLX DCPLX
      ELSE IF ( LSAME(TRANS, 'C') ) THEN
         ITRAN = ATLASCONJTRANS
@TYPE !
      ELSE
         ITRAN = ATLASTRANS
      ENDIF

      CALL ATL_F77WRAP_@(pre)GETRS( ITRAN, N, NRHS, A, LDA, IPIV, B, LDB )

      RETURN
      END
@ROUT GESV
      SUBROUTINE @(pre)GESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
*
*  -- LAPACK driver routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993 
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      INTEGER INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER IPIV( * )
      @(type) A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)GESV computes the solution to a @(comtyp) system of linear equations
*     A * X = B,
*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
*
*  The LU decomposition with partial pivoting and row interchanges is
*  used to factor A as
*     A = P * L * U,
*  where P is a permutation matrix, L is unit lower triangular, and U is
*  upper triangular.  The factored form of A is then used to solve the
*  system of equations A * X = B.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The number of linear equations, i.e., the order of the
*          matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the N-by-N coefficient matrix A.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (output) INTEGER array, dimension (N)
*          The pivot indices that define the permutation matrix P;
*          row i of the matrix was interchanged with row IPIV(i).
*
*  B       (input/output) @(type) array, dimension (LDB,NRHS)
*          On entry, the N-by-NRHS matrix of right hand side matrix B.
*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
*                has been completed, but the factor U is exactly
*                singular, so the solution could not be computed.
*
*  =====================================================================
*
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)GESV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( N.LT.0 ) THEN
         INFO = -1
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)GESV ', -INFO )
         RETURN
      END IF
      
      CALL ATL_F77WRAP_@(pre)GESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )

      RETURN
      END
@ROUT GETRF
      SUBROUTINE @(pre)GETRF( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
@extract -b @(topd)/gen.inc what=f77lp @(cw99)
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      @(type) A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)GETRF computes an LU factorization of a general M-by-N matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the M-by-N matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
*                has been completed, but the factor U is exactly
*                singular, and division by zero will occur if it is used
*                to solve a system of equations.
*
*  =====================================================================
*
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)GETRF
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)GETRF', -INFO )
         RETURN
      END IF

      CALL ATL_F77WRAP_@(pre)GETRF( M, N, A, LDA, IPIV, INFO )

      RETURN
      END
@ROUT TRTRI
      SUBROUTINE @(pre)TRTRI( UPLO, DIAG, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
@extract -b @(topd)/gen.inc what=f77lp @(sw01)
*     .. Scalar Arguments ..
      CHARACTER          DIAG, UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      @(type)    A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)TRTRI computes the inverse of an upper or lower triangular
*  matrix A.
*
*  This is the Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  A is upper triangular;
*          = 'L':  A is lower triangular.
*
*  DIAG    (input) CHARACTER*1
*          = 'N':  A is non-unit triangular;
*          = 'U':  A is unit triangular.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the triangular matrix A.  If UPLO = 'U', the
*          leading N-by-N upper triangular part of the array A contains
*          the upper triangular matrix, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading N-by-N lower triangular part of the array A contains
*          the lower triangular matrix, and the strictly upper
*          triangular part of A is not referenced.  If DIAG = 'U', the
*          diagonal elements of A are also not referenced and are
*          assumed to be 1.
*          On exit, the (triangular) inverse of the original matrix, in
*          the same storage format.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
*               matrix is singular and its inverse can not be computed.
*
*  =====================================================================
*
*     .. Parameters ..
      @(type)   ONE, ZERO
@TYPE SREAL DREAL
      PARAMETER          ( ONE = @(one), ZERO = @(zero) )
@TYPE SCPLX DCPLX
      PARAMETER          ( ONE = @(one),
     $                     ZERO = @(zero) )
@TYPE !
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      LOGICAL            NOUNIT, UPPER
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)TRTRI
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      NOUNIT = LSAME( DIAG, 'N' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)TRTRI', -INFO )
         RETURN
      END IF

      IF (UPPER) THEN
         IUPLO = ATLASUPPER
      ELSE
         IUPLO = ATLASLOWER
      ENDIF

      IF (NOUNIT) THEN
         IDIAG = ATLASNONUNIT
      ELSE
         IDIAG = ATLASUNIT
      ENDIF

      CALL ATL_F77WRAP_@(pre)TRTRI( IUPLO, IDIAG, N, A, LDA, INFO )

      RETURN
      END
@ROUT POTRI
      SUBROUTINE @(pre)POTRI( UPLO, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
@extract -b @(topd)/gen.inc what=f77lp @(cw01)
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      @(type)         A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
@TYPE SREAL DREAL
*  @(pre)POTRI computes the inverse of a real symmetric positive definite
*  matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
*  computed by @(pre)POTRF.
@TYPE SCPLX DCPLX
*  @(pre)POTRI computes the inverse of a complex Hermitian positive definite
*  matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
*  computed by @(pre)POTRF.
@TYPE !
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
@TYPE DCPLX SCPLX
*          On entry, the triangular factor U or L from the Cholesky
*          factorization A = U**H*U or A = L*L**H, as computed by
*          @(pre)POTRF.
*          On exit, the upper or lower triangle of the (Hermitian)
*          inverse of A, overwriting the input factor U or L.
@TYPE DREAL SREAL
*          On entry, the triangular factor U or L from the Cholesky
*          factorization A = U**T*U or A = L*L**T, as computed by
*          @(pre)POTRF.
*          On exit, the upper or lower triangle of the (symmetric)
*          inverse of A, overwriting the input factor U or L.
@TYPE !
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, the (i,i) element of the factor U or L is
*                zero, and the inverse could not be computed.
*
*  =====================================================================
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ZLAUUM, ZTRTRI
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( .NOT.LSAME( UPLO, 'U' ) .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)POTRI', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Invert the triangular Cholesky factor U or L.
*
      CALL @(pre)TRTRI( UPLO, 'Non-unit', N, A, LDA, INFO )
      IF( INFO.GT.0 )
     $   RETURN
*
*     Form inv(U)*inv(U)' or inv(L)'*inv(L).
*
      CALL @(pre)LAUUM( UPLO, N, A, LDA, INFO )
*
      RETURN
*
*     End of @(pre)POTRI
*
      END
@ROUT GETRI
      SUBROUTINE @(pre)GETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     June 30, 1999
@extract -b @(topd)/gen.inc what=f77lp @(cw01)
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      @(type) A( LDA, * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)GETRI computes the inverse of a matrix using the LU factorization
*  computed by @(pre)GETRF.
*
*  This method inverts U and then computes inv(A) by solving the system
*  inv(A)*L = inv(U) for inv(A).
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the factors L and U from the factorization
*          A = P*L*U as computed by @(pre)GETRF.
*          On exit, if INFO = 0, the inverse of the original matrix A.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices from ZGETRF; for 1<=i<=N, row i of the
*          matrix was interchanged with row IPIV(i).
*
*  WORK    (workspace/output) @(type) array, dimension (LWORK)
*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.  LWORK >= max(1,N).
*          For optimal performance LWORK >= N*NB, where NB is
*          the optimal blocksize returned by ILAENV.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
*                singular and its inverse could not be computed.
*
*  =====================================================================
*
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)GETRI
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      LQUERY = ( LWORK.EQ.-1 )
      IF( N.LT.0 ) THEN
         INFO = -1
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -3
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)GETRI', -INFO )
         RETURN
      END IF
*
      CALL ATL_F77WRAP_@(pre)GETRI(N, A, LDA, IPIV, WORK, LWORK, INFO)
*
      RETURN
*
*     End of @(pre)GETRI
*
      END
@ROUT LAUUM
      SUBROUTINE @(pre)LAUUM( UPLO, N, A, LDA, INFO )
*
*  -- LAPACK auxiliary routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
@extract -b @(topd)/gen.inc what=f77lp @(cw01)
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      @(type)         A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)LAUUM computes the product U * U' or L' * L, where the triangular
*  factor U or L is stored in the upper or lower triangular part of
*  the array A.
*
*  If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
*  overwriting the factor U in A.
*  If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
*  overwriting the factor L in A.
*
*  This is the blocked form of the algorithm, calling Level 3 BLAS.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          Specifies whether the triangular factor stored in the array A
*          is upper or lower triangular:
*          = 'U':  Upper triangular
*          = 'L':  Lower triangular
*
*  N       (input) INTEGER
*          The order of the triangular factor U or L.  N >= 0.
*
*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
*          On entry, the triangular factor U or L.
*          On exit, if UPLO = 'U', the upper triangle of A is
*          overwritten with the upper triangle of the product U * U';
*          if UPLO = 'L', the lower triangle of A is overwritten with
*          the lower triangle of the product L' * L.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*
*  =====================================================================
*
*    .. Parameters ..
@extract -b @(incd)/f77.inc what=enums
*
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ATL_F77WRAP_@(pre)LAUUM
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)LAUUM', -INFO )
         RETURN
      END IF
*
      IF (UPPER) THEN
         IUPLO = ATLASUPPER
      ELSE
         IUPLO = ATLASLOWER
      ENDIF
      CALL ATL_F77WRAP_@(pre)LAUUM( IUPLO, N, A, LDA, INFO )
*
      RETURN
*
*     End of @(pre)LAUUM
*
      END
@ROUT geqrf
   @define qr @qr@
@ROUT geqlf
   @define qr @ql@
@ROUT gerqf
   @define qr @rq@
@ROUT gelqf
   @define qr @lq@
@ROUT geqrf geqlf gerqf gelqf
@TYPE SREAL DREAL
   @define orth @orthogonal@
   @define T @T@
@TYPE SCPLX DCPLX
   @define T @H@
   @define orth @unitary@
@TYPE !
      SUBROUTINE @(pre)@up@(@rout)( M, N, A, LDA, TAU, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 3.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2006
*
*  -- Modified by R. Clint Whaley for ATLAS Fortran77 LAPACK interface, 2009
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, M, N
*     ..
*     .. Array Arguments ..
      @(type) A( LDA, * ), TAU( * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)@up@(@rout) computes a @up@(qr) factorization of a @(comtyp) M-by-N matrix A:
@ROUT gelqf `*  A = L * Q.`
@ROUT gerqf `*  A = R * Q.`
@ROUT geqlf `*  A = Q * L.`
@ROUT geqrf `*  A = Q * R.`
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
*          On entry, the M-by-N matrix A.
@ROUT gelqf 
*          On exit, the elements on and below the diagonal of the array
*          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
*          lower triangular if m <= n); the elements above the diagonal,
*          with the array TAU, represent the @(orth) matrix Q as a
*          product of elementary reflectors (see Further Details).
@ROUT geqlf
*          On exit,
*          if m >= n, the lower triangle of the subarray
*          A(m-n+1:m,1:n) contains the N-by-N lower triangular matrix L;
*          if m <= n, the elements on and below the (n-m)-th
*          superdiagonal contain the M-by-N lower trapezoidal matrix L;
*          the remaining elements, with the array TAU, represent the
*          @(orth) matrix Q as a product of elementary reflectors
*          (see Further Details).
@ROUT gerqf
*          On exit,
*          if m <= n, the upper triangle of the subarray
*          A(1:m,n-m+1:n) contains the M-by-M upper triangular matrix R;
*          if m >= n, the elements on and above the (m-n)-th subdiagonal
*          contain the M-by-N upper trapezoidal matrix R;
*          the remaining elements, with the array TAU, represent the
*          @(orth) matrix Q as a product of min(m,n) elementary
*          reflectors (see Further Details).
@ROUT geqrf
*          On exit, the elements on and above the diagonal of the array
*          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
*          upper triangular if m >= n); the elements below the diagonal,
*          with the array TAU, represent the @(orth) matrix Q as a
*          product of min(m,n) elementary reflectors (see Further
*          Details).
@ROUT geqrf geqlf gerqf gelqf
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  TAU     (output) @(type) array, dimension (min(M,N))
*          The scalar factors of the elementary reflectors (see Further
*          Details).
*
*  WORK    (workspace/output) @(type) array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.  LWORK >= max(1,N).
*          For optimum performance LWORK >= N*NB, where NB is
*          the optimal blocksize.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  Further Details
*  ===============
*
*  The matrix Q is represented as a product of elementary reflectors
*
@ROUT gelqf `*     Q = H(k)**@(T) . . . H(2)**@(T) H(1)**@(T), where k = min(m,n).`
@ROUT gerqf `*     Q = H(1)**@(T) H(2)**@(T) . . . H(k)**@(T), where k = min(m,n).`
@ROUT geqlf `*     Q = H(k) . . . H(2) H(1), where k = min(m,n).`
@ROUT geqrf `*     Q = H(1) H(2) . . . H(k), where k = min(m,n).`
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v**@(T)
*
@TYPE SCPLX DCPLX
*  where tau is a complex scalar, and v is a complex vector with
   @ROUT gelqf
*  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
*  A(i,i+1:n), and tau in TAU(i).
   @ROUT geqlf
*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
   @ROUT geqrf
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
*  and tau in TAU(i).
   @ROUT gerqf
*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
*  exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
   @ROUT geqrf geqlf gerqf gelqf
@TYPE SREAL DREAL
*  where tau is a real scalar, and v is a real vector with
   @ROUT gelqf
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
*  and tau in TAU(i).
   @ROUT geqlf
*  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
*  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
   @ROUT geqrf
*  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
*  and tau in TAU(i).
   @ROUT geqlf
*  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
*  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
   @ROUT geqrf geqlf gerqf gelqf
@TYPE !
*
*  =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, IB, IINFO, IWS, K, LDWORK, LWKOPT, NB,
     $                   NBMIN, NX
*     ..
*     .. External Subroutines ..
      EXTERNAL           XERBLA, ZGEQR2, ZLARFB, ZLARFT
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)@(@rout)', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      K = MIN( M, N )
      IF( K.EQ.0 ) THEN
         WORK( 1 ) = 1
         RETURN
      END IF
*
      CALL ATL_F77WRAP_@(pre)@up@(@rout)(M, N, A, LDA, TAU, WORK, LWORK, INFO)
*
      RETURN
*
*     End of @(pre)@up@(@rout)
*
      END
@ROUT gels

      SUBROUTINE @(pre)GELS( TRANS, M, N, NRHS, A, LDA, B, LDB, WORK, LWORK,
     $                  INFO )
*
*  -- LAPACK driver routine (version 3.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2006
*
*  -- Modified by R. Clint Whaley for ATLAS Fortran77 LAPACK interface, 2010
*
*     .. Scalar Arguments ..
      CHARACTER          TRANS
      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS
*     ..
*     .. Array Arguments ..
      @(type)   A( LDA, * ), B( LDB, * ), WORK( * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)GELS solves overdetermined or underdetermined real linear systems
*  involving an M-by-N matrix A, or its transpose, using a QR or LQ
*  factorization of A.  It is assumed that A has full rank.
*
*  The following options are provided:
*
*  1. If TRANS = 'N' and m >= n:  find the least squares solution of
*     an overdetermined system, i.e., solve the least squares problem
*                  minimize || B - A*X ||.
*
*  2. If TRANS = 'N' and m < n:  find the minimum norm solution of
*     an underdetermined system A * X = B.
*
*  3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
*     an undetermined system A**T * X = B.
*
*  4. If TRANS = 'T' and m < n:  find the least squares solution of
*     an overdetermined system, i.e., solve the least squares problem
*                  minimize || B - A**T * X ||.
*
*  Several right hand side vectors b and solution vectors x can be
*  handled in a single call; they are stored as the columns of the
*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
*  matrix X.
*
*  Arguments
*  =========
*
*  TRANS   (input) CHARACTER*1
*          = 'N': the linear system involves A;
*          = 'T': the linear system involves A**T.
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of
*          columns of the matrices B and X. NRHS >=0.
*
*  A       (input/output) @(type) array, dimension (LDA,N)
*          On entry, the M-by-N matrix A.
*          On exit,
*            if M >= N, A is overwritten by details of its QR
*                       factorization as returned by DGEQRF;
*            if M <  N, A is overwritten by details of its LQ
*                       factorization as returned by DGELQF.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  B       (input/output) @(type) array, dimension (LDB,NRHS)
*          On entry, the matrix B of right hand side vectors, stored
*          columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
*          if TRANS = 'T'.
*          On exit, if INFO = 0, B is overwritten by the solution
*          vectors, stored columnwise:
*          if TRANS = 'N' and m >= n, rows 1 to n of B contain the least
*          squares solution vectors; the residual sum of squares for the
*          solution in each column is given by the sum of squares of
*          elements N+1 to M in that column;
*          if TRANS = 'N' and m < n, rows 1 to N of B contain the
*          minimum norm solution vectors;
*          if TRANS = 'T' and m >= n, rows 1 to M of B contain the
*          minimum norm solution vectors;
*          if TRANS = 'T' and m < n, rows 1 to M of B contain the
*          least squares solution vectors; the residual sum of squares
*          for the solution in each column is given by the sum of
*          squares of elements M+1 to N in that column.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B. LDB >= MAX(1,M,N).
*
*  WORK    (workspace/output) @(type) array, dimension (MAX(1,LWORK))
*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.
*          LWORK >= max( 1, MN + max( MN, NRHS ) ).
*          For optimal performance,
*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).
*          where MN = min(M,N) and NB is the optimum block size.
*
*          If LWORK = -1, then a workspace query is assumed; the routine
*          only calculates the optimal size of the WORK array, returns
*          this value as the first entry of the WORK array, and no error
*          message related to LWORK is issued by XERBLA.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO =  i, the i-th diagonal element of the
*                triangular factor of A is zero, so that A does not have
*                full rank; the least squares solution could not be
*                computed.
*
*  =====================================================================
*
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     ..
*     .. Local Scalars ..
      LOGICAL            LQUERY
      INTEGER            ITRANS
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           ATL_F77WRAP_@(pre)GELS, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          DBLE, MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input arguments.
*
      INFO = 0
      MN = MIN( M, N )
      LQUERY = ( LWORK.EQ.-1 )
@TYPE SREAL DREAL
      IF( .NOT.( LSAME( TRANS, 'N' ) .OR. LSAME( TRANS, 'T' ) ) ) THEN
@TYPE SCPLX DCPLX
      IF( .NOT.( LSAME( TRANS, 'N' ) .OR. LSAME( TRANS, 'C' ) ) ) THEN
@TYPE !
         INFO = -1
      ELSE IF( M.LT.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LDB.LT.MAX( 1, M, N ) ) THEN
         INFO = -8
      ELSE IF( LWORK.LT.-1 )THEN
         INFO = -10
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( '@(pre)GELS ', -INFO )
         RETURN
      END IF

      IF (LSAME(TRANS, 'N')) THEN
         ITRANS = ATLASNOTRANS
      ELSE
@TYPE SREAL DREAL `         ITRANS = ATLASTRANS`
@TYPE SCPLX DCPLX `         ITRANS = ATLASCONJTRANS`
      END IF 

      CALL ATL_F77WRAP_@(pre)GELS(ITRANS, M, N, NRHS, A, LDA, B, LDB, 
     $                       WORK, LWORK, INFO)
*
*     End of @(pre)GELS
*
      END
@ROUT lamc3
      @(type) FUNCTION @(pre)LAMC3( A, B )
*
*  -- LAPACK auxiliary routine (version 3.2) --
*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
*     November 2006
*     Modified by R. Clint Whaley for inclusion in ATLAS Dec 2009.
*
*     .. Scalar Arguments ..
      @(type) A, B
*     ..
*
*  Purpose
*  =======
*
*  @(pre)LAMC3  is intended to force  A  and  B  to be stored prior to doing
*  the addition of  A  and  B ,  for use in situations where optimizers
*  might hold one of these in a register.
*
*  Arguments
*  =========
*
*  A       (input) @(type)
*  B       (input) @(type)
*          The values A and B.
*
* =====================================================================
*
*     .. Executable Statements ..
*
      @(pre)LAMC3 = A + B
*
      RETURN
*
*     End of @(pre)LAMC3
*
      END
@ROUT larft
      SUBROUTINE @(pre)LARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
      IMPLICIT NONE
*
*  -- LAPACK auxiliary routine (version 3.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2006
*
*     .. Scalar Arguments ..
      CHARACTER          DIRECT, STOREV
      INTEGER            K, LDT, LDV, N
*     ..
*     .. Array Arguments ..
      @(type)   T( LDT, * ), TAU( * ), V( LDV, * )
*     ..
*
*  Purpose
*  =======
*
*  @(pre)LARFT forms the triangular factor T of a @(type) block reflector H
*  of order n, which is defined as a product of k elementary reflectors.
*
*  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
*
*  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
*
*  If STOREV = 'C', the vector which defines the elementary reflector
*  H(i) is stored in the i-th column of the array V, and
*
@TYPE SREAL DREAL `*     H  =  I - V * T * V**T`
@TYPE SCPLX DCPLX `*     H  =  I - V * T * V**H`
*
*  If STOREV = 'R', the vector which defines the elementary reflector
*  H(i) is stored in the i-th row of the array V, and
*
@TYPE SREAL DREAL `*     H  =  I - V**T * T * V`
@TYPE SCPLX DCPLX `*     H  =  I - V**H * T * V`
*
*  Arguments
*  =========
*
*  DIRECT  (input) CHARACTER*1
*          Specifies the order in which the elementary reflectors are
*          multiplied to form the block reflector:
*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
*
*  STOREV  (input) CHARACTER*1
*          Specifies how the vectors which define the elementary
*          reflectors are stored (see also Further Details):
*          = 'C': columnwise
*          = 'R': rowwise
*
*  N       (input) INTEGER
*          The order of the block reflector H. N >= 0.
*
*  K       (input) INTEGER
*          The order of the triangular factor T (= the number of
*          elementary reflectors). K >= 1.
*
*  V       (input/output) @(type) array, dimension
*                               (LDV,K) if STOREV = 'C'
*                               (LDV,N) if STOREV = 'R'
*          The matrix V. See further details.
*
*  LDV     (input) INTEGER
*          The leading dimension of the array V.
*          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
*
*  TAU     (input) @(type) array, dimension (K)
*          TAU(i) must contain the scalar factor of the elementary
*          reflector H(i).
*
*  T       (output) @(type) array, dimension (LDT,K)
*          The k by k triangular factor T of the block reflector.
*          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
*          lower triangular. The rest of the array is not used.
*
*  LDT     (input) INTEGER
*          The leading dimension of the array T. LDT >= K.
*
*  Further Details
*  ===============
*
*  The shape of the matrix V and the storage of the vectors which define
*  the H(i) is best illustrated by the following example with n = 5 and
*  k = 3. The elements equal to 1 are not stored; the corresponding
*  array elements are modified but restored on exit. The rest of the
*  array is not used.
*
*  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
*
*               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
*                   ( v1  1    )                     (     1 v2 v2 v2 )
*                   ( v1 v2  1 )                     (        1 v3 v3 )
*                   ( v1 v2 v3 )
*                   ( v1 v2 v3 )
*
*  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
*
*               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
*                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
*                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
*                   (     1 v3 )
*                   (        1 )
*
*  =====================================================================
*
@ROUT larfb
      SUBROUTINE @(pre)LARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
     $                   T, LDT, C, LDC, WORK, LDWORK )
      IMPLICIT NONE
*
*  -- LAPACK auxiliary routine (version 3.2) --
*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2006
*     Modified by R. Clint Whaley for inclusion in ATLAS Dec 2009.
*
*     .. Scalar Arguments ..
      CHARACTER          DIRECT, SIDE, STOREV, TRANS
      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
*     ..
*     .. Array Arguments ..
      @(type) C( LDC, * ), T( LDT, * ), V( LDV, * ),
     $        WORK( LDWORK, * )
*     ..
*
*  Purpose
*  =======
*
@TYPE DREAL SREAL
*  @(pre)LARFB applies a real block reflector H or its transpose H' to a
*  real m by n matrix C, from either the left or the right.
@TYPE DCPLX SCPLX
*  @(pre)LARFB applies a complex block reflector H or its conjugate transpose 
*  to a complex m by n matrix C, from either the left or the right.
@TYPE !
*
*  Arguments
*  =========
*
*  SIDE    (input) CHARACTER*1
@TYPE DREAL SREAL
*          = 'L': apply H or H**T from the Left
*          = 'R': apply H or H**T from the Right
@TYPE DCPLX SCPLX
*          = 'L': apply H or H**H from the Left
*          = 'R': apply H or H**H from the Right
@TYPE !
*
*  TRANS   (input) CHARACTER*1
@TYPE DREAL SREAL
*          = 'N': apply H (No transpose)
*          = 'T': apply H**T (Transpose)
@TYPE DCPLX SCPLX
*          = 'N': apply H (No transpose)
*          = 'C': apply H**H (Conjugate transpose)
@TYPE !
*
*  DIRECT  (input) CHARACTER*1
*          Indicates how H is formed from a product of elementary
*          reflectors
*          = 'F': H = H(1) H(2) . . . H(k) (Forward)
*          = 'B': H = H(k) . . . H(2) H(1) (Backward)
*
*  STOREV  (input) CHARACTER*1
*          Indicates how the vectors which define the elementary
*          reflectors are stored:
*          = 'C': Columnwise
*          = 'R': Rowwise
*
*  M       (input) INTEGER
*          The number of rows of the matrix C.
*
*  N       (input) INTEGER
*          The number of columns of the matrix C.
*
*  K       (input) INTEGER
*          The order of the matrix T (= the number of elementary
*          reflectors whose product defines the block reflector).
*
*  V       (input) @(type) array, dimension
*                                (LDV,K) if STOREV = 'C'
*                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
*                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
*          The matrix V. See further details.
*
*  LDV     (input) INTEGER
*          The leading dimension of the array V.
*          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
*          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
*          if STOREV = 'R', LDV >= K.
*
*  T       (input) @(type) array, dimension (LDT,K)
*          The triangular k by k matrix T in the representation of the
*          block reflector.
*
*  LDT     (input) INTEGER
*          The leading dimension of the array T. LDT >= K.
*
*  C       (input/output) @(type) array, dimension (LDC,N)
*          On entry, the m by n matrix C.
*          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
*
*  LDC     (input) INTEGER
*          The leading dimension of the array C. LDC >= max(1,M).
*
*  WORK    (workspace) @(type) array, dimension (LDWORK,K)
*
*  LDWORK  (input) INTEGER
*          The leading dimension of the array WORK.
*          If SIDE = 'L', LDWORK >= max(1,N);
*          if SIDE = 'R', LDWORK >= max(1,M).
*
*  =====================================================================
*
@ROUT larft larfb
*     .. Parameters ..
      @extract -b @(incd)/f77.inc what=enums
*     .. Local variables ..
      integer iside, itrans, idirect, istore
*     ..
*     .. Executable Statements ..
*
*     Quick return if possible
*
@ROUT larft
      IF (N .LE.0) RETURN
@ROUT larfb
      IF( M.LE.0 .OR. N.LE.0 )
     $   RETURN
      if (side.eq.'R' .OR. side.eq.'r') then
         iside = atlasright
      else
         iside = atlasleft
      endif
      if (trans.eq.'N' .OR. trans.eq.'n') then
         itrans = atlasnotrans
      else
@TYPE SCPLX DCPLX `         itrans = atlasconjtrans`
@TYPE SREAL DREAL `         itrans = atlastrans`
      endif
@ROUT larft larfb
      if (direct.eq.'F' .OR. direct.eq.'f') then
         idirect = 1
      else
         idirect = 2
      endif
      if (storev.eq.'R' .OR. storev.eq.'r') then
         istore = 1
      else
         istore = 2
      endif

@ROUT larfb
      call atl_f77wrap_@(pre)larfb(iside, itrans, idirect, istore, M, N, K,
     $                        V, ldv, T, ldt, C, ldc, work, ldwork)
@ROUT larft
      call atl_f77wrap_@(pre)larft(idirect, istore, N, K, V, ldv, 
     $                        TAU, T, ldt)
@ROUT larft larfb
*
*
      RETURN
*
*     End of @(pre)@up@(@rout)
*
      END
@ROUT Make.Flp
include Make.inc
mySRCdir = $(SRCdir)/interfaces/lapack/F77/src

all :
	$(MAKE) lib
	- $(MAKE) tlib
clean : dclean sclean zclean cclean iclean \
        dtclean stclean ztclean ctclean itclean
ptlib : tlib
@define ptdef @@
@define ptdef @-DATL_USEPTHREADS@
@define lib @@
@define lib @PT@
@define pt @@
@whiledef pt t
@(pt)lib : @(pt)reflapack.grd d@(pt)lib s@(pt)lib z@(pt)lib c@(pt)lib

@beginskip
   @multidef irt ATL_f77wrap_i@(pt)laenv
   @multidef irt icmax1 izmax1 ilaver iparmq lsamen ilaenv
   @declare "i@(pt)laobj = " y y
      @whiledef irt
         @(irt).o
         @define rt2 @@(irt)@
      @endwhile
   @enddeclare
@endskip

   @whiledef pre z c d s
      @addkeys ptyp=@(pre)
      @declare "@(pre)@(pt)obj = " y y
         ieeeck.o ATL_f77wrap_i@(pt)laenv.o ilaenv.o
         ATL_f77wrap_@(pre)getnb.o
         @(pre)potri.o
         @ptyp d s
            @(pre)lamch.o @(pre)lamc3.o
         @ptyp !
         @multidef rt larfb larft
         @multidef rt @(pt)geqrf @(pt)geqlf @(pt)gerqf @(pt)gelqf @(pt)gels
         @multidef rt @(pt)getrf getrs lauum getri trtri
         @whiledef rt posv potrf potrs @(pt)gesv 
            @(pre)@(rt).o
            ATL_f77wrap_@(pre)@(rt).o
         @endwhile
      @enddeclare
      @killkeys ptyp
   @endwhile

i@(pt)clean :
	rm -f $(i@(pt)laobj) ieeeck.o
   @whiledef pre z c d s
@(pre)@(pt)clean :
	rm -f $(@(pre)@(pt)obj) @(pre)@(pt)lib.grd reflapack.grd
@(pre)@(pt)lib : @(pre)@(pt)lib.grd 
@(pre)@(pt)lib.grd : $(@(pre)@(pt)obj)
	$(ARCHIVER) $(ARFLAGS) $(@(lib)LAPACKlib) $(@(pre)@(pt)obj)
	$(RANLIB) $(@(lib)LAPACKlib)
	touch @(pre)@(pt)lib.grd
   @endwhile

   @multidef typ DCPLX SCPLX DREAL SREAL
   @whiledef pre z c d s
      @whiledef rt potri
@(pre)@(pt)@(rt).o : $(mySRCdir)/@(pre)@(rt).f
	$(F77) -o $@ @(ptdef) -c $(F77FLAGS) $(mySRCdir)/@(pre)@(rt).f
      @endwhile
      @multidef rt geqrf geqlf gerqf gelqf larfb larft gels
      @whiledef rt posv potrf potrs gesv getrf getrs trtri lauum getri
@(pre)@(pt)@(rt).o : $(mySRCdir)/@(pre)@(rt).f
	$(F77) -o $@ @(ptdef) -c $(F77FLAGS) $(mySRCdir)/@(pre)@(rt).f
ATL_f77wrap_@(pre)@(pt)@(rt).o : $(mySRCdir)/f77wrap/ATL_f77wrap_@(rt).c
	$(KC) $(KCFLAGS) -o $@ @(ptdef) -c -D@(typ) $(mySRCdir)/f77wrap/ATL_f77wrap_@(rt).c
      @endwhile
      @whiledef rt getnb
ATL_f77wrap_@(pre)@(pt)@(rt).o : $(mySRCdir)/f77wrap/ATL_f77wrap_@(rt).c
	$(KC) $(KCFLAGS) -o $@ @(ptdef) -c -D@(typ) $(mySRCdir)/f77wrap/ATL_f77wrap_@(rt).c
      @endwhile
      @undef typ

   @endwhile
ATL_f77wrap_i@(pt)laenv.o : $(mySRCdir)/f77wrap/ATL_f77wrap_ilaenv.c
	$(KC) $(KCFLAGS) -o $@ @(ptdef) -c $(mySRCdir)/f77wrap/ATL_f77wrap_ilaenv.c
@(pt)reflarebuild :    # force rebuild of netlib lapack
	rm -f $(FLAdir)/lapack_$(ARCH).a
	$(MAKE) @(pt)reflabuild
@(pt)reflapack.grd : 
	if [ -d "$(FLAdir)" ]; then \
           $(MAKE) @(pt)reflabuild ; \
        fi
	touch reflapack.grd
@(pt)reflabuild : $(FLAdir)/lapack_$(ARCH).a
	mkdir flapack 
	cd flapack ; $(ARCHIVER) x $(FLAdir)/lapack_$(ARCH).a
	cd flapack ; rm -f ?posv.o ?potrf.o ?potrs.o ?gesv.o ?getrf.o ?getrs.o \
           ?potri.o ?lauum.o ?getri.o ?trtri.o ieeeck.o ilaenv.o [s,d]lamch.o \
           ?geqrf.o ?gerqf.o ?geqlf.o ?gelqf.o ?larfb.o ?larft.o ?gels.o \
           xerbla.o lsame.o
	cd flapack ; $(ARCHIVER) $(ARFLAGS) $(@(lib)LAPACKlib) *.o
	rm -rf flapack
	$(RANLIB) $(@(lib)LAPACKlib)
   @undef ptdef
   @undef lib
@endwhile

makeincex = $(FLAdir)/make.inc.example
$(FLAdir)/make.inc : $(makeincex)
	rm -f $(FLAdir)/make.inc
	cat $(makeincex) | sed -e 's@PLAT *=.*@PLAT = _$(ARCH)@' \
         -e 's@^FORTRAN *=.*@FORTRAN = $(F77)@' \
         -e 's@^OPTS *=.*@OPTS = $(F77FLAGS)@' \
         -e 's@^NOOPT *=.*@NOOPT = $(F77FLAGS) $(F77NOOPT)@' \
         -e 's@^LOADER *=.*@LOADER = $(F77)@' \
         -e 's@^LOADOPTS *=.*@LOADOPTS = $(F77FLAGS)@' \
         -e 's@^TIMER *=.*@TIMER = NONE@' \
         > $(FLAdir)/make.inc

$(FLAdir)/lapack_$(ARCH).a : $(FLAdir)/make.inc
	cd $(FLAdir) ; $(PMAKE) lib
	if [ -f $(FLAdir)/liblapack.a ]; then \
           ln -s $(FLAdir)/liblapack.a $(FLAdir)/lapack_$(ARCH).a ; \
        fi

@multidef typ DREAL SREAL
@whiledef pre d s
@(pre)lamch.o : $(mySRCdir)/lamch.c
	$(KC) $(KCFLAGS) -o $@ -c -D@(typ) $(mySRCdir)/lamch.c
@(pre)lamc3.o : $(mySRCdir)/@(pre)lamc3.f
	$(F77) $(F77FLAGS) $(F77NOOPT) -o $@ -c $(mySRCdir)/@(pre)lamc3.f
   @undef typ
@endwhile

ieeeck.o : $(mySRCdir)/ieeeck.f
	$(F77) -o $@ -c $(F77FLAGS) $(mySRCdir)/ieeeck.f
ilaenv.o : $(mySRCdir)/ilaenv.f
	$(F77) -o $@ -c $(F77FLAGS) $(mySRCdir)/ilaenv.f

@ROUT Make.ext
basd = /home/rwhaley/Base/ATLAS
basf = $(basd)/atlas-fint.base
ext = extract3.0 -b $(basf) -langF -lapack1 -lnlen71 -llwarn1

@declare "fil = " y y 
   ilaenv.f
   @whiledef pre z c d s
      @multidef rt geqrf geqlf gerqf gelqf larfb larft
      @whiledef rt posv potrf potrs gesv getrf getrs trtri lauum getri potri
         @(pre)@(rt).f
      @endwhile
   @endwhile
@enddeclare

all : $(fil)

ilaenv.f : $(basf)
	$(ext) -o $@ rout=$* type=none
@multidef type DCPLX SCPLX DREAL SREAL
@whiledef pre z c d s
   @multidef rt geqrf geqlf gerqf gelqf larfb larft
   @whiledef rt posv potrf potrs gesv getrf getrs trtri lauum getri potri
@(pre)@(rt).f : $(basf)
	$(ext) -o $@ rout=@(rt) type=@(type)
   @endwhile
   @undef type
@endwhile
