@extract -b @(topd)/gen.inc what=crsetup
@extract -b @(topd)/gen.inc what=cw @(cw03)
@ROUT atlas_pkblas.h
#ifndef ATLAS_PKBLAS_H
#define ATLAS_PKBLAS_H

#include "atlas_misc.h"
#ifndef ATL_NOL3
#include "atlas_lvl3.h"
#endif

#define CBLAS_ENUM_ONLY
#include "cblas.h"
#undef CBLAS_ENUM_ONLY

enum PACK_UPLO {PackUpper=121, PackLower=122, PackGen=123};

#define PACK_ORDER CBLAS_ORDER
   #define PackRowMajor CblasRowMajor
   #define PackColMajor CblasColMajor
#define PACK_TRANS CBLAS_TRANSPOSE
   #define PackNoTrans CblasNoTrans
   #define PackTrans CblasTrans
   #define PackConjTrans CblasConjTrans
   #define PackConj AtlasConj
#define PACK_DIAG CBLAS_DIAG
   #define PackNonUnit CblasNonUnit
   #define PackUnit CblasUnit
#define PACK_SIDE CBLAS_SIDE
   #define PackLeft  CblasLeft
   #define PackRight CblasRight

#ifndef ATL_pkMaxMalloc
   #define ATL_pkMaxMalloc ATL_MaxMalloc
#endif

#ifdef TCPLX
   #define MindexPL(I_,J_,lda_) \
      ( (((J_)*(((size_t)(lda_))+(lda_)-(J_)-1))) + (I_)+(I_) )
   #define MindexPU(I_,J_,lda_) \
      ( (((((size_t)(lda_))+(lda_)+(J_)-1)*(J_))) + (I_)+(I_) )
#else
   #define MindexPL(I_,J_,lda_) \
      ( (((J_)*(((size_t)(lda_))+(lda_)-(J_)-1))>>1) + (I_) )
   #define MindexPU(I_,J_,lda_) \
      ( (((((size_t)(lda_))+(lda_)+(J_)-1)*(J_))>>1) + (I_) )
#endif
#define MindexP(uplo_,I_,J_,lda_) \
   ( (uplo_) == PackUpper ? MindexPU(I_,J_,lda_) : \
     ( (uplo_) == PackLower ? MindexPL(I_,J_,lda_) : \
                              (((J_)*((size_t)(lda_))+(I_))SHIFT) ) )
#define Mpld(uplo_,J_,lda_) (uplo_) == PackUpper ? (lda_)+(J_) : \
              ( (uplo_) == PackLower ? (lda_)-(J_) : (lda_) )


@multidef sca double* float* double float
@multidef typ double float double float
@whiledef pre z c d s
void ATL_@(pre)gpmm(const enum PACK_UPLO UA, const enum PACK_TRANS TA,
               const enum PACK_UPLO UB, const enum PACK_TRANS TB,
               const enum PACK_UPLO UC,
               const int M, const int N, const int K, const @(sca) alpha,
               const @(typ) *A, const int IA, const int JA, const int lda,
               const @(typ) *B, const int IB, const int JB, const int ldb,
               const @(sca) beta, @(typ) *C, const int IC, const int JC,
               const int ldc); 
void ATL_@(pre)prankK(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                      const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
                      const int M, const int N, const int K, int R,
                      const SCALAR alpha, const TYPE *A, int lda,
                      const TYPE *B, int ldb, const SCALAR beta,
                      const enum PACK_UPLO UC, TYPE *C, int ldc);
int ATL_@(pre)pmmJIKF(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                 const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
                 const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb,
                 const SCALAR beta, const enum PACK_UPLO UC,
                 TYPE *C, const int ldc);
int ATL_@(pre)pmmJIK(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
                const int M, const int N, const int K, const @(sca) alpha,
                const @(typ) *A, const int lda, const @(typ) *B, const int ldb,
                const @(sca) beta, const enum PACK_UPLO UC,
                @(typ) *C, const int ldc);
void ATL_@(pre)pcol2blkF(const int M, const int N, const @(sca) alpha,
                    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkTF(const int M, const int N, const @(sca) alpha,
                     const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blk_a1(const int M, const int N, const @(sca) alpha,
                      const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blk_aX(const int M, const int N, const @(sca) alpha,
                      const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkT_a1(const int M, const int N, const @(sca) alpha,
                       const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkT_aX(const int M, const int N, const @(sca) alpha,
                       const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pputblk(const int M, const int N, const TYPE *V, TYPE *C,
                  int ldc, int ldcinc, const SCALAR beta);
void ATL_@(pre)pputblk_diag
   (const int M, const int N, const @(typ) *V, const enum ATLAS_UPLO UC,
    @(typ) *C, int ldc, int ldcinc, const @(sca) alpha, const @(sca) beta);
void ATL_@(pre)pputblk_aX
   (const int M, const int N, const @(typ) *V, @(typ) *C, int ldc, int ldcinc,
    const @(sca) alpha, const @(sca) beta);
void ATL_@(pre)sprk(const enum PACK_UPLO UA, const enum PACK_TRANS TA,
               const enum ATLAS_UPLO UC, const int CP,
               const int N, const int K, const @(sca) alpha,
               const @(typ) *A, const int IA, const int JA, const int lda,
               const @(sca) beta, 
               @(typ) *C, const int IC, const int JC, const int ldc);
void ATL_@(pre)hprk(const enum PACK_UPLO UA, const enum PACK_TRANS TA,
               const enum ATLAS_UPLO UC, const int CP,
               const int N, const int K, const @(typ) alpha,
               const @(typ) *A, const int IA, const int JA, const int lda,
               const @(typ) beta, 
               @(typ) *C, const int IC, const int JC, const int ldc);
@multidef r2 pr   ph
@whiledef rt sprk hprk
void ATL_@(pre)@(rt)_rK(const enum PACK_UPLO UA, const enum PACK_TRANS TA,
                  const enum ATLAS_UPLO UC, const int CP,
                  const int N, const int K, int R, const @(sca) alpha,
                  const @(typ) *A, int lda, const @(sca) beta,
                  @(typ) *C, const int ldc);
int ATL_@(pre)@(r2)k_kmm(const enum ATLAS_UPLO UC, const enum PACK_UPLO UA,
                 const enum ATLAS_TRANS TA, const int N, const int K,
                 const @(sca) alpha, const @(typ) *A, const int lda,
                 const @(sca) beta, const int CP, @(typ) *C, const int ldc);
   @undef r2
@endwhile

   @undef typ
   @undef sca
@endwhile
@multidef sca double* float*
@multidef typ double float
@whiledef pre z c
   @whiledef al a1 aX
void ATL_@(pre)pcol2blk_@(al)_blk
   (const int blk, const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkT_@(al)_blk
   (const int blk, const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
   @endwhile
void ATL_@(pre)prow2blkTF_blk
   (const int blk, const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blkF_blk
   (const int blk, const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
   @define blkdef @const int blk, @
   @define blkdef @@
   @define blksuf @_blk@
   @define blksuf @@
   @whiledef blksuf
void ATL_@(pre)pcol2blkConjF@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blkConj_a1@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blkConj_aX@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blk_aXi0@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)pcol2blkConj_aXi0@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc,@(typ)*V);
void ATL_@(pre)prow2blkHF@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkH_a1@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkH_aX@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkH_aXi0@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
void ATL_@(pre)prow2blkT_aXi0@(blksuf)
   (@(blkdef)const int M, const int N, const @(sca) alpha,
    const @(typ) *A, int lda, const int ldainc, @(typ) *V);
      @undef blkdef
   @endwhile

@whiledef tt H T
   @whiledef nm a1 aX aXi0
void ATL_@(pre)prow2blk@(tt)_KB_@(nm)
   (const int mb, const int nb, const SCALAR alpha, const TYPE *A, int lda,
    const int ldainc, TYPE *V);
   @endwhile
@endwhile
   @undef typ
   @undef sca
@endwhile

#endif
@ROUT ATL_pcol2blk ATL_prow2blkT
#include "atlas_pkblas.h"
@ROUT ATL_cpcol2blk ATL_cprow2blkT
#include "atlas_pkblas.h"
#ifdef Conj_
   #if defined(ALPHA1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = *(A_); \
         *(ip_) = -((A_)[1]); \
      }
   #elif defined(ALPHAXI0)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = ralpha * *(A_); \
         *(ip_) = calpha * (A_)[1]; \
      }
   #elif defined(ALPHAX)
      #define scalcp(A_, rp_, ip_) \
      { \
         ra = *(A_); ia = (A_)[1]; \
         *(rp_) = ralpha * ra + ialpha * ia; \
         *(ip_) = ialpha * ra - ralpha * ia; \
      }
   #endif
#else
   #if defined(ALPHA1)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = *(A_); \
         *(ip_) = (A_)[1]; \
      }
   #elif defined(ALPHAXI0)
      #define scalcp(A_, rp_, ip_) \
      { \
         *(rp_) = ralpha * *(A_); \
         *(ip_) = ralpha * (A_)[1]; \
      }
   #elif defined(ALPHAX)
      #define scalcp(A_, rp_, ip_) \
      { \
         ra = *(A_); ia = (A_)[1]; \
         *(rp_) = ralpha * ra - ialpha * ia; \
         *(ip_) = ialpha * ra + ralpha * ia; \
      }
   #endif
#endif
@ROUT ATL_cpcol2blk
#ifdef Conj_
   #define dcol2blkF_a1   Mjoin(PATL,col2blkConj2_a1)
   #define dcol2blkF_aX   Mjoin(PATL,col2blkConj2_aX)
   #define dcol2blkF_aXi0 Mjoin(PATL,col2blkConj2_aXi0)
   #define pcol2blk Mjoin(Mjoin(PATL,pcol2blkConj),NM)
   #define pcol2blkF Mjoin(PATL,pcol2blkConjF)
#else
   #define dcol2blkF_a1   Mjoin(PATL,col2blk2_a1)
   #define dcol2blkF_aX   Mjoin(PATL,col2blk2_aX)
   #define dcol2blkF_aXi0 Mjoin(PATL,col2blk2_aXi0)
   #define pcol2blk Mjoin(Mjoin(PATL,pcol2blk),NM)
   #define pcol2blkF Mjoin(PATL,pcol2blkF)
#endif
@ROUT ATL_cprow2blkT
#ifdef Conj_
   #define prow2blkT Mjoin(Mjoin(PATL,prow2blkH),NM)
   #define prow2blkTF Mjoin(PATL,prow2blkHF)
   #define prow2blk_KB Mjoin(Mjoin(PATL,prow2blkH_KB),NM)
#else
   #define prow2blkT Mjoin(Mjoin(PATL,prow2blkT),NM)
   #define prow2blkTF Mjoin(PATL,prow2blkTF)
   #define prow2blk_KB Mjoin(Mjoin(PATL,prow2blkT_KB),NM)
#endif
@ROUT ATL_pcol2blk
void Mjoin(Mjoin(PATL,pcol2blk),NM)
   (const int M, const int N, const TYPE alpha, const TYPE *A, int lda,
    const int ldainc, TYPE *V)
/*
 * Given a packed matrix A, copies N columns starting at A into
 * block-major column panel
 *    ldainc =  0 : General
 *    ldainc =  1 : Upper
 *    ldainc = -1 : Lower
 * NOTE: specialize to alpha cases after it works!
 */
{
   const int kb = Mmin(M,NB);
   const int nrb = M / kb, mr = M - nrb*kb;
   int i, ib, j, J;
   const int NN = N*kb;
   TYPE *v = V + nrb*NN;

   if (ldainc)
   {
      if (ldainc == -1) lda--;
      ATL_assert(N <= NB);
      for (j=0; j != N; j++)
      {
         for (ib=nrb; ib; ib--)
         {
            for (i=0; i < kb; i++) V[i] = ATL_MulByALPHA(A[i]);
            V += NN;
            A += kb;
         }
         if (mr)
         {
            for (i=0; i < mr; i++) v[i] = ATL_MulByALPHA(A[i]);
            v += mr;
         }
         V += kb - nrb*NN;
         A += lda - nrb*kb;
         lda += ldainc;
      }
   }
   else Mjoin(Mjoin(PATL,col2blk),NM)(M, N, A, lda, V, alpha);
}

@ROUT ATL_pcol2blk
#ifdef ALPHA1
void Mjoin(PATL,pcol2blkF)
   (const int M, const int N, const SCALAR alpha, const TYPE *A, int lda,
    const int ldainc, TYPE *V)
/*
 * Copies entire MxN matrix to block major format
 */
{
   int j, jb;
   const int incV = ATL_MulByNB(M);
   const enum PACK_UPLO UA = (ldainc == 1) ? PackUpper : 
      ( (lda == -1) ? PackLower : PackGen );
   void (*col2blk)(const int M, const int N, const SCALAR alpha, const TYPE *A,
                   int lda, const int ldainc, TYPE *V);

   if (ldainc)
   {
      if (alpha == ATL_rone) col2blk = Mjoin(PATL,pcol2blk_a1);
      else col2blk = Mjoin(PATL,pcol2blk_aX);
   
      for (j=0; j < N; j += NB)
      {
         jb = N-j;
         jb = Mmin(jb, NB);
         col2blk(M, jb, alpha, A+MindexP(UA,0,j,lda), Mpld(UA,j,lda), ldainc,V);
         V += incV;
      }
   }
   else if (alpha == ATL_rone)
      Mjoin(PATL,col2blk2_a1)(M, N, A, lda, V, alpha);
   else
      Mjoin(PATL,col2blk2_aX)(M, N, A, lda, V, alpha);
}
#endif
@ROUT ATL_cpcol2blk

#ifdef ALPHA1
void Mjoin(pcol2blkF,_blk)
   (const int blk, const int M, const int N, const SCALAR alpha, const TYPE *A,
    int lda, const int ldainc, TYPE *V)
/*
 * Copies entire MxN matrix to block major format
 */
{
   int j, jb;
   const int incV = blk*(M+M);
   const enum PACK_UPLO UA = (ldainc == 1) ? PackUpper :
      ( (lda == -1) ? PackLower : PackGen );
   void (*col2blk)(const int blk, const int M, const int N, const SCALAR alpha,
                   const TYPE *A, int lda, const int ldainc, TYPE *V);

#ifdef Conj_
   if (alpha[1] == ATL_rzero)
   {
      if (*alpha == ATL_rone) col2blk = Mjoin(Mjoin(PATL,pcol2blkConj_a1),_blk);
      else col2blk = Mjoin(Mjoin(PATL,pcol2blkConj_aXi0),_blk);
   }
   else col2blk = Mjoin(Mjoin(PATL,pcol2blkConj_aX),_blk);
#else
   if (alpha[1] == ATL_rzero)
   {
      if (*alpha == ATL_rone) col2blk = Mjoin(Mjoin(PATL,pcol2blk_a1),_blk);
      else col2blk = Mjoin(Mjoin(PATL,pcol2blk_aXi0),_blk);
   }
   else col2blk = Mjoin(Mjoin(PATL,pcol2blk_aX),_blk);
#endif

   for (j=0; j < N; j += blk)
   {
      jb = N-j;
      jb = Mmin(jb, blk);
      col2blk(blk, M, jb, alpha, A+MindexP(UA,0,j,lda), Mpld(UA,j,lda),
              ldainc, V);
      V += incV;
   }
}

void pcol2blkF
   (const int M, const int N, const SCALAR alpha, const TYPE *A, int lda,
    const int ldainc, TYPE *V)
{
   if (ldainc) Mjoin(pcol2blkF,_blk)(NB, M, N, alpha, A, lda, ldainc, V);
   else if (alpha[1] == ATL_rzero)
   {
      if (*alpha == ATL_rone) dcol2blkF_a1(M, N, A, lda, V, alpha);
      else dcol2blkF_aXi0(M, N, A, lda, V, alpha);
   }
   else dcol2blkF_aX(M, N, A, lda, V, alpha);
}
#endif

void Mjoin(pcol2blk,_blk)(const int blk, const int M, const int N,
                          const SCALAR alpha, const TYPE *A, int lda,
                          const int ldainc, TYPE *V)
/*
 * Given a packed matrix A, copies N columns starting at A into
 * block-major column panel
 *    ldainc =  0 : General
 *    ldainc =  1 : Upper
 *    ldainc = -1 : Lower
 * NOTE: specialize to alpha cases after it works!
 */
{
   const int kb = Mmin(M,blk);
   const int nrb = M / kb, mr = M - nrb*kb;
   const int nv = kb*N, nvv = mr*N;
   const int NN = nv+nv - kb;
   const int ldainc2 = ldainc+ldainc, M2 = M+M;
   int i, ib, j, J;
   TYPE *v = V + nrb*(NN+kb);
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      const register TYPE ralpha=(*alpha), ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   if (ldainc == -1) lda--;
   lda += lda;
   ATL_assert(N <= blk);
   for (j=0; j != N; j++)
   {
      for (ib=nrb; ib; ib--)
      {
         for (i=0; i < kb; i++, A += 2, V++) scalcp(A, V+nv, V);
         V += NN;
      }
      if (mr)
      {
         for (i=0; i < mr; i++, A += 2, v++) scalcp(A, v+nvv, v);
      }
      V += kb - nrb*(NN+kb);
      A += lda - M2;
      lda += ldainc2;
   }
}

void pcol2blk(const int M, const int N, const SCALAR alpha, const TYPE *A,
              int lda, const int ldainc, TYPE *V)
{
   if (ldainc) Mjoin(pcol2blk,_blk)(NB, M, N, alpha, A, lda, ldainc, V);
#ifdef Conj_
   else Mjoin(Mjoin(PATL,col2blkConj),NM)(M, N, A, lda, V, alpha);
#else
   else Mjoin(Mjoin(PATL,col2blk),NM)(M, N, A, lda, V, alpha);
#endif
}
@ROUT ATL_prow2blkT
void Mjoin(Mjoin(PATL,prow2blkT),NM)
   (const int M, const int N, const TYPE alpha, const TYPE *A, int lda,
    const int ldainc, TYPE *V)
/*
 * Given a packed Upper matrix A, copies & transposes M rows starting at A into
 * block-major row panel
 *    ldainc =  0 : General rectangular
 *    ldainc =  1 : Upper
 *    ldainc = -1 : Lower
 * NOTE: specialize to alpha cases after it works!
 */
{
   const int kb = Mmin(NB,N);
   const int ncb = N / kb, nr = N - ncb*kb;
   const int incV = kb*M - kb;
   int jb, i, j;
   TYPE *v;

   if (ldainc)
   {
      if (ldainc == -1) lda--;
      for (jb=ncb; jb; jb--)
      {
         for (j=kb; j; j--)
         {
            v = V++;
            for (i=0; i != M; i++, v += kb) *v = ATL_MulByALPHA(A[i]);
            A += lda;
            lda += ldainc;
         }
         V += incV;
      }
      for (j=nr; j; j--)
      {
         v = V++;
         for (i=0; i != M; i++, v += nr) *v = ATL_MulByALPHA(A[i]);
         A += lda;
         lda += ldainc;
      }
   }
   else Mjoin(Mjoin(PATL,row2blkT),NM)(N, M, A, lda, V, alpha);
}

#ifdef ALPHA1
/*
 * These two routines copy an mbxnb section of a matrix A to a block-major
 * nbxmb matrix V (A is transposed in the copy)
 */
static void ATL_prow2blk_KB_a1(const int mb, const int nb, const SCALAR alpha,
                               const TYPE *A, int lda, const int ldainc,TYPE *V)
{
   TYPE *v;
   int i, j;

   if (ldainc == -1) lda--;
   for (j=nb; j; j--)
   {
      v = V++;
      for (i=0; i != mb; i++, v += nb) *v = A[i];
      A += lda;
      lda += ldainc;
   }
}
static void ATL_prow2blk_KB_aX(const int mb, const int nb, const SCALAR alpha,
                               const TYPE *A, int lda, const int ldainc, TYPE *V)
{
   TYPE *v;
   int i, j;

   if (ldainc == -1) lda--;
   for (j=nb; j; j--)
   {
      v = V++;
      for (i=0; i != mb; i++, v += nb) *v = alpha * A[i];
      A += lda;
      lda += ldainc;
   }
}

void Mjoin(PATL,prow2blkTF)(const int M, const int N, const SCALAR alpha,
                            const TYPE *A, int lda, const int ldainc, TYPE *V)
{
   const int mb = Mmin(NB,M), nMb = ATL_DivByNB(M);
   const int m = ATL_MulByNB(nMb), n = ATL_MulByNB(ATL_DivByNB(N));
   const int nr = N - n, mr = M - m;
   const int incVm = ATL_MulByNB(N), incVV = ATL_MulByNB(mr);
   int i, j, ib, jb;
   const enum PACK_UPLO UA = (ldainc == 1) ? PackUpper : 
      ( (ldainc == -1) ? PackLower : PackGen );
   TYPE *v, *vv = V+nMb*incVm;
   void (*row2blk)(const int M, const int N, const TYPE alpha, const TYPE *A,
                   int lda, const int ldainc, TYPE *V);

   if (ldainc)
   {
      if (alpha == ATL_rone) row2blk = ATL_prow2blk_KB_a1;
      else row2blk = ATL_prow2blk_KB_aX;

      for (j=0; j < n; j += NB)
      {
         for (v=V, i=0; i < m; i += NB, v += incVm)
            row2blk(NB, NB, alpha, A+MindexP(UA,i,j,lda), Mpld(UA,j,lda),
                    ldainc, v);
         if (mr)
         {
            row2blk(mr, NB, alpha, A+MindexP(UA,m,j,lda), Mpld(UA,j,lda),
                    ldainc, vv);
            vv += incVV;
         }
         V += NBNB;
      }
      if (nr)
      {
         for (v=V, i=0; i < m; i += NB, v += incVm)
            row2blk(NB, nr, alpha, A+MindexP(UA,i,n,lda), Mpld(UA,n,lda),
                    ldainc, v);
         if (mr)
            row2blk(mr, nr, alpha, A+MindexP(UA,m,n,lda), Mpld(UA,n,lda),
                    ldainc, vv);
      }
   }
   else if (SCALAR_IS_ONE(alpha))
      Mjoin(PATL,row2blkT2_a1)(M, N, A, lda, V, alpha);
   else
      Mjoin(PATL,row2blkT2_aX)(M, N, A, lda, V, alpha);
}
#endif

@ROUT ATL_cprow2blkT
void prow2blk_KB(const int mb, const int nb, const SCALAR alpha, const TYPE *A,
                 int lda, const int ldainc, TYPE *V)
/*
 * This routine used by full copy to copy one mbxnb block of a matrix A to
 * block-major nbxmb storage (A is transposed during the copy)
 */
{
   TYPE *v;
   const int mn = mb * nb, ldainc2 = ldainc+ldainc;
   int i, j;
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      register const TYPE ralpha=(*alpha), ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   if (ldainc == -1) lda--;
   lda -= mb;
   lda += lda;
   for (j=nb; j; j--)
   {
      v = V++;
      for (i=0; i != mb; i++, v += nb, A += 2) scalcp(A, v+mn, v);
      A += lda;
      lda += ldainc2;
   }
}

void Mjoin(prow2blkT,_blk)(const int blk, const int M, const int N,
                           const SCALAR alpha, const TYPE *A, int lda,
                           const int ldainc, TYPE *V)
/*
 * Given a packed Upper matrix A, copies & transposes M rows starting at A into
 * block-major row panel
 *    ldainc =  0 : General rectangular
 *    ldainc =  1 : Upper
 *    ldainc = -1 : Lower
 */
{
   const int kb = Mmin(blk,N);
   const int ncb = N / kb, nr = N - ncb*kb;
   const int incV = kb*M - kb;
   const int VN = kb*M, vn = nr*M;
   int jb, i, j;
   TYPE *v;
   #ifdef ALPHAXI0
      #ifdef Conj_
         const register TYPE ralpha = *alpha, calpha = -ralpha;
      #else
         const register TYPE ralpha = *alpha;
      #endif
   #elif defined(ALPHAX)
      register const TYPE ralpha=(*alpha), ialpha = alpha[1];
      register TYPE ra, ia;
   #endif

   if (ldainc == -1) lda--;
   lda -= M;
   lda += lda;
   for (jb=ncb; jb; jb--)
   {
      for (j=kb; j; j--)
      {
         v = V++;
         for (i=0; i != M; i++, v += kb, A += 2) scalcp(A, v+VN, v);
         A += lda;
         lda += ldainc;
      }
      V += incV;
   }
   for (j=nr; j; j--)
   {
      v = V++;
      for (i=0; i != M; i++, v += nr, A += 2) scalcp(A, v+vn, v);
      A += lda;
      lda += ldainc;
   }
}

void prow2blkT(const int M, const int N, const SCALAR alpha, const TYPE *A,
               int lda, const int ldainc, TYPE *V)
{
   if (ldainc) Mjoin(prow2blkT,_blk)(NB, M, N, alpha, A, lda, ldainc, V);
#ifdef Conj_
   else Mjoin(Mjoin(PATL,row2blkC),NM)(N, M, A, lda, V, alpha);
#else
   else Mjoin(Mjoin(PATL,row2blkT),NM)(N, M, A, lda, V, alpha);
#endif
}
#ifdef ALPHA1
#ifdef Conj_
   #define dr2bT2_a1   Mjoin(PATL,row2blkC2_a1)
   #define dr2bT2_aXi0 Mjoin(PATL,row2blkC2_aXi0)
   #define dr2bT2_aX   Mjoin(PATL,row2blkC2_aX)
   #define ATL_row2blk_KB_a1   Mjoin(Mjoin(PATL,prow2blkH_KB),_a1)
   #define ATL_row2blk_KB_aXi0 Mjoin(Mjoin(PATL,prow2blkH_KB),_aXi0)
   #define ATL_row2blk_KB_aX   Mjoin(Mjoin(PATL,prow2blkH_KB),_aX)
#else
   #define dr2bT2_a1   Mjoin(PATL,row2blkT2_a1)
   #define dr2bT2_aXi0 Mjoin(PATL,row2blkT2_aXi0)
   #define dr2bT2_aX   Mjoin(PATL,row2blkT2_aX)
   #define ATL_row2blk_KB_a1   Mjoin(Mjoin(PATL,prow2blkT_KB),_a1)
   #define ATL_row2blk_KB_aXi0 Mjoin(Mjoin(PATL,prow2blkT_KB),_aXi0)
   #define ATL_row2blk_KB_aX   Mjoin(Mjoin(PATL,prow2blkT_KB),_aX)
#endif
void Mjoin(prow2blkTF,_blk)
   (const int blk, const int M, const int N, const SCALAR alpha,
    const TYPE *A, int lda, const int ldainc, TYPE *V)
{
   const int mb = Mmin(blk,M), nMb = M/blk;
   const int m = blk*nMb, n = blk*(N/blk);
   const int nr = N - n, mr = M - m;
   const int incVm = blk*(N+N), incVV = blk*(mr+mr), nbnb=(blk*blk)<<1;
   int i, j, ib, jb;
   const enum PACK_UPLO UA = (ldainc == 1) ? PackUpper : 
      ( (ldainc == -1) ? PackLower : PackGen );
   TYPE *v, *vv = V+nMb*incVm;
   void (*row2blk)(const int M, const int N, const SCALAR alpha, const TYPE *A,
                   int lda, const int ldainc, TYPE *V);

   if (alpha[1] == ATL_rzero)
   {
      if (*alpha == ATL_rone) row2blk = ATL_row2blk_KB_a1;
      else row2blk = ATL_row2blk_KB_aXi0;
   }
   else row2blk = ATL_row2blk_KB_aX;

   for (j=0; j < n; j += blk)
   {
      for (v=V, i=0; i < m; i += blk, v += incVm)
         row2blk(blk, blk, alpha, A+MindexP(UA,i,j,lda), Mpld(UA,j,lda),
                 ldainc, v);
      if (mr)
      {
         row2blk(mr, blk, alpha, A+MindexP(UA,m,j,lda), Mpld(UA,j,lda),
                 ldainc, vv);
         vv += incVV;
      }
      V += nbnb;
   }
   if (nr)
   {
      for (v=V, i=0; i < m; i += blk, v += incVm)
         row2blk(blk, nr, alpha, A+MindexP(UA,i,n,lda), Mpld(UA,n,lda),
                 ldainc, v);
      if (mr)
         row2blk(mr, nr, alpha, A+MindexP(UA,m,n,lda), Mpld(UA,n,lda),
                 ldainc, vv);
   }
}

void prow2blkTF(const int M, const int N, const SCALAR alpha, const TYPE *A,
                int lda, const int ldainc, TYPE *V)
{
   if (ldainc) Mjoin(prow2blkTF,_blk)(NB, M, N, alpha, A, lda, ldainc, V);
   else if (alpha[1] == ATL_rzero)
   {
      if (*alpha == ATL_rone) dr2bT2_a1(M, N, A, lda, V, alpha);
      else dr2bT2_aXi0(M, N, A, lda, V, alpha);
   }
   else dr2bT2_aX(M, N, A, lda, V, alpha);
}
#endif
@ROUT ATL_pputblk ATL_cpputblk
#include "atlas_pkblas.h"

void Mjoin(PATL,pputblk)(const int M, const int N, const TYPE *V, TYPE *C,
                         int ldc, int ldcinc, const SCALAR beta)
/*
 * Given a MxN block-major block V, copy to a packed C
 *    ldcinc =  0 : General rectangular
 *    ldcinc =  1 : Upper
 *    ldcinc = -1 : Lower
 */
@ROUT ATL_pputblk
{
   int i, j;

   if (!ldcinc && 0)
   {
      Mjoin(PATL,putblk_bX)(M, N, (TYPE*)V, C, ldc, beta);
      return;
   }
   ldc -= M;
   if (ldcinc == -1) ldc--;
   if (beta == 0.0)
   {
      for (j=N; j; j--)
      {
         for (i=M; i; i--) *C++ = *V++;
         C += ldc;
         ldc += ldcinc;
      }
   }
   else if (beta == 1.0)
   {
      for (j=N; j; j--)
      {
         for (i=M; i; i--) *C++ += *V++;
         C += ldc;
         ldc += ldcinc;
      }
   }
   else
   {
      for (j=N; j; j--)
      {
         for (i=M; i; i--, C++) *C = *C * beta + *V++;
         C += ldc;
         ldc += ldcinc;
      }
   }
}
@ROUT ATL_cpputblk
{
   int i, j;
   const int mn = M*N;
   const register TYPE rbeta = *beta, ibeta = beta[1];
   register TYPE rc, ic, t0;

   if (ldcinc == -1) ldc--;
   ldc -= M;
   ldc += ldc;
   if (ibeta == ATL_rzero)
   {
      if (rbeta == ATL_rzero)
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--, C += 2)
            {
               *C = V[mn];
               C[1] = *V++;
            }
            C += ldc;
            ldc += ldcinc;
         }
      }
      else if (rbeta == ATL_rone)
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--, C += 2)
            {
               *C += V[mn];
               C[1] += *V++;
            }
            C += ldc;
            ldc += ldcinc;
         }
      }
      else /* beta real X */
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--, C += 2)
            {
               *C = *C * rbeta + V[mn];
               C[1] = C[1] * rbeta + *V++;
            }
            C += ldc;
            ldc += ldcinc;
         }
      }
   }
   else /* beta = complex X */
   {
      for (j=N; j; j--)
      {
         for (i=M; i; i--, C += 2)
         {
            t0 = rc = *C; ic = C[1];
            rc = rc * rbeta - ic * ibeta;
            ic = t0 * ibeta + ic * rbeta;
            rc += V[mn];
            ic += *V++;
            *C = rc;
            C[1] = ic;
         }
         C += ldc;
         ldc += ldcinc;
      }
   }
}
@ROUT ATL_pputblk_aX ATL_cpputblk_aX
#include "atlas_pkblas.h"
void Mjoin(PATL,pputblk_diag)
   (const int M, const int N, const TYPE *V, const enum ATLAS_UPLO UC,
    TYPE *C, int ldc, int ldcinc, const SCALAR alpha, const SCALAR beta) 
/*
 * Copies only the Upper or Lower portion of V to C
 */
@ROUT ATL_pputblk_aX
{
   int i, j;

   if (UC == AtlasUpper)
   {
      if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = -V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = alpha * V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
      }
      else if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] += V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] -= V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] += alpha * V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
      }
      else
      {
         if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = beta*C[i] + V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = beta*C[i] - V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               for (i=0; i <= j; i++) C[i] = beta*C[i] + alpha * V[i];
               C += ldc;
               V += M;
               ldc += ldcinc;
            }
         }
      }
   }
   else
   {
      if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = -V[i];
               C += ldc;
               V += M;
            }
         }
         else if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = V[i];
               C += ldc;
               V += M;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = alpha * V[i];
               C += ldc;
               V += M;
            }
         }
      }
      else if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] -= V[i];
               C += ldc;
               V += M;
            }
         }
         else if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] += V[i];
               C += ldc;
               V += M;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] += alpha * V[i];
               C += ldc;
               V += M;
            }
         }
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = beta*C[i] - V[i];
               C += ldc;
               V += M;
            }
         }
         else if (SCALAR_IS_ONE(alpha))
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = beta*C[i] + V[i];
               C += ldc;
               V += M;
            }
         }
         else
         {
            for (j=0; j < N; j++)
            {
               ldc += ldcinc;
               for (i=j; i < M; i++) C[i] = beta*C[i] + alpha * V[i];
               C += ldc;
               V += M;
            }
         }
      }
   }
}
@ROUT ATL_cpputblk_aX
/*
 * NOTE: specialize alpha, beta cases once it works!
 */
{
   int i, j, k;
   const int mn = M*N;
   const register TYPE rbeta=(*beta), ibeta=beta[1];
   const register TYPE ralpha=(*alpha), ialpha=alpha[1];
   register TYPE rc, ic, rv, iv, t0;

   if (UC == AtlasUpper)
   {
      ldc += ldc;
      ldcinc += ldcinc;
      for (j=0; j < N; j++)
      {
         for (i=0; i <= j; i++)
         {
            k = i+i;
            rc = C[k];
            ic = C[k+1];
            t0 = rv = V[i+mn];
            iv = V[i];
            rv = ralpha * rv - ialpha *iv;
            iv = ialpha * t0 + ralpha * iv;
            t0 = rc;
            rc = rbeta * rc - ibeta * ic;
            ic = ibeta * t0 + rbeta * ic;
            rc += rv;
            ic += iv;
            C[k] = rc;
            C[k+1] = ic;
         }
         C += ldc;
         V += M;
         ldc += ldcinc;
      }
   }
   else
   {
      ldc += ldc;
      ldcinc += ldcinc;
      for (j=0; j < N; j++)
      {
         ldc += ldcinc;
         for (i=j; i < M; i++)
         {
            k = i+i;
            rc = C[k];
            ic = C[k+1];
            t0 = rv = V[i+mn];
            iv = V[i];
            rv = ralpha * rv - ialpha *iv;
            iv = ialpha * t0 + ralpha * iv;
            t0 = rc;
            rc = rbeta * rc - ibeta * ic;
            ic = ibeta * t0 + rbeta * ic;
            rc += rv;
            ic += iv;
            C[k] = rc;
            C[k+1] = ic;
         }
         C += ldc;
         V += M;
      }
   }
}

void Mjoin(PATL,pputblk_aX)(const int M, const int N, const TYPE *V,
                            TYPE *C, int ldc, int ldcinc,
                            const SCALAR alpha, const SCALAR beta)
/*
 * Given a MxN block-major block V, copy to a packed C
 *    ldcinc =  0 : General rectangular
 *    ldcinc =  1 : Upper
 *    ldcinc = -1 : Lower
 * NOTE: specialize alpha,beta once it works!
 */
{
   int i, j, k;
   const int mn = M*N;
   const register TYPE rbeta=(*beta), ibeta=beta[1];
   const register TYPE ralpha=(*alpha), ialpha=alpha[1];
   register TYPE rc, ic, rv, iv, t0;

   ldc -= M;
   if (ldcinc == -1) ldc--;
   ldc += ldc;
   ldcinc += ldcinc;
   for (j=N; j; j--)
   {
      for (i=M; i; i--, C += 2, V++)
      {
         rc = *C;
         ic = C[1];
         t0 = rv = V[mn];
         iv = *V;
         rv = ralpha * rv - ialpha *iv;
         iv = ialpha * t0 + ralpha * iv;
         t0 = rc;
         rc = rbeta * rc - ibeta * ic;
         ic = ibeta * t0 + rbeta * ic;
         rc += rv;
         ic += iv;
         *C = rc;
         C[1] = ic;
      }
      C += ldc;
      ldc += ldcinc;
   }
}
@ROUT ATL_pputblk_aX
void Mjoin(PATL,pputblk_aX)(const int M, const int N, const TYPE *V,
                            TYPE *C, int ldc, int ldcinc,
                            const SCALAR alpha, const SCALAR beta)
/*
 * Given a MxN block-major block V, copy to a packed C
 *    ldcinc =  0 : General rectangular
 *    ldcinc =  1 : Upper
 *    ldcinc = -1 : Lower
 */
{
   int i, j;

   if (!ldcinc && 0)
   {
      Mjoin(PATL,putblk_bX)(M, N, (TYPE*)V, C, ldc, beta);
      return;
   }
   ldc -= M;
   if (ldcinc == -1) ldc--;
   if (beta == 0.0)
   {
      if (alpha == 1.0)
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--) *C++ = *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
      else
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--) *C++ = alpha * *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
   }
   else if (beta == 1.0)
   {
      if (alpha == 1.0)
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--) *C++ += *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
      else
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--) *C++ += alpha * *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
   }
   else
   {
      if (alpha == 1.0)
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--, C++) *C = *C * beta + *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
      else
      {
         for (j=N; j; j--)
         {
            for (i=M; i; i--, C++) *C = *C * beta + alpha * *V++;
            C += ldc;
            ldc += ldcinc;
         }
      }
   }
}
@ROUT ATL_cprk_kmm ATL_phk_kmm ATL_cpmmJIK
#define ATL_NOL3
@ROUT ATL_pmmJIK ATL_prk_kmm ATL_cprk_kmm ATL_cpmmJIK ATL_phk_kmm
#include "atlas_pkblas.h"
@ROUT ATL_cprk_kmm ATL_cpmmJIK ATL_phk_kmm
/*
 * Get NB defined to call the real matmul
 */
#ifdef SCPLX
   #undef SCPLX
   #define SREAL
   #include "atlas_lvl3.h"
   #undef SREAL
   #define SCPLX
#elif defined DCPLX
   #undef DCPLX
   #define DREAL
   #include "atlas_lvl3.h"
   #undef DREAL
   #define DCPLX
#endif

/*
 * Can't use standard include file, since we are doing inter-type calls,
 * so dump explicit headers here
 */
@whiledef be X 1 0
void NBmm_b@(be)(const int M, const int N, const int K, const TYPE alpha,
             const TYPE *A, const int lda, const TYPE *B, const int ldb,
             const TYPE beta, TYPE *C, const int ldc);
void Mjoin(PATLU,pNBmm_b@(be))
   (const int M, const int N, const int K, const TYPE alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const TYPE beta, TYPE *C, const int ldc);
void Mjoin(PATLU,pMBmm_b@(be))
   (const int M, const int N, const int K, const TYPE alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const TYPE beta, TYPE *C, const int ldc);
void Mjoin(PATLU,pKBmm_b@(be))
   (const int M, const int N, const int K, const TYPE alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const TYPE beta, TYPE *C, const int ldc);
@endwhile
void Mjoin(PATLU,pKBmm)
   (const int M, const int N, const int K, const TYPE alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const TYPE beta, TYPE *C, const int ldc);

@multidef bet0 ATL_rnone ATL_rzero
@multidef bet1 ATL_rone ATL_rzero
@multidef be0  X 0
@multidef be1  1 0
@whiledef be   1 0
static void ATL_gNBmm_b@(be)
   (const int M, const int N, const int K, const TYPE alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const TYPE beta, TYPE *C, const int ldc)
/*
 * ALPHA is known to be 1 (handled by copy)
 * BETA is known to be @(be); we handle actual BETA in putblk phase
 */
{
   if (M == MB && N == NB && K == KB)
   {
      NBmm_b@(be0)(M, N, K, ATL_rone, A, lda, B, ldb, @(bet0), C+NBNB, ldc);
      NBmm_b@(be1)(M, N, K, ATL_rone, A, lda, B+NBNB, ldb, @(bet1), C, ldc);
      NBmm_bX(M, N, K, ATL_rone, A+NBNB, lda, B+NBNB, ldb, ATL_rnone,
              C+NBNB, ldc);
      NBmm_b1(M, N, K, ATL_rone, A+NBNB, lda, B, ldb, ATL_rone, C, ldc);
   }
   else if (M != MB)
   {
      if (N == NB && K == KB)
      {
         Mjoin(PATLU,pMBmm_b@(be0))(M, N, K, ATL_rone, A, lda, B, ldb,
                               @(bet0), C+M*N, ldc);
         Mjoin(PATLU,pMBmm_b@(be1))(M, N, K, ATL_rone, A, lda, B+NBNB, ldb,
                               @(bet1), C, ldc);
         Mjoin(PATLU,pMBmm_bX)(M, N, K, ATL_rone, A+M*K, lda, B+NBNB, ldb,
                               ATL_rnone, C+M*N, ldc);
         Mjoin(PATLU,pMBmm_b1)(M, N, K, ATL_rone, A+M*K, lda, B, ldb,
                               ATL_rone, C, ldc);
      }
      else
      {
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A, lda, B, ldb,
                            @(bet0), C+M*N, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A, lda, B+N*K, ldb,
                            @(bet1), C, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A+M*K, lda, B+N*K, ldb,
                            ATL_rnone, C+M*N, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A+M*K, lda, B, ldb,
                            ATL_rone, C, ldc);
      }
   }
   else if (N != NB)  /* ib is full */
   {
      if (K == KB)
      {
         Mjoin(PATLU,pNBmm_b@(be0))(M, N, K, ATL_rone, A, lda, B, ldb,
                               @(bet0), C+M*N, ldc);
         Mjoin(PATLU,pNBmm_b@(be1))(M, N, K, ATL_rone, A, lda, B+N*K, ldb,
                               @(bet1), C, ldc);
         Mjoin(PATLU,pNBmm_bX)(M, N, K, ATL_rone, A+M*K, lda, B+N*K, ldb,
                               ATL_rnone, C+M*N, ldc);
         Mjoin(PATLU,pNBmm_b1)(M, N, K, ATL_rone, A+M*K, lda, B, ldb,
                               ATL_rone, C, ldc);
      }
      else
      {
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A, lda, B, ldb,
                            @(bet0), C+M*N, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A, lda, B+N*K, ldb,
                            @(bet1), C, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A+M*K, lda, B+N*K, ldb,
                            ATL_rnone, C+M*N, ldc);
         Mjoin(PATLU,pKBmm)(M, N, K, ATL_rone, A+M*K, lda, B, ldb,
                            ATL_rone, C, ldc);
      }
   }
   else  /* ib and jb are full */
   {
         Mjoin(PATLU,pKBmm_b@(be0))(M, N, K, ATL_rone, A, lda, B, ldb,
                               @(bet0), C+M*N, ldc);
         Mjoin(PATLU,pKBmm_b@(be1))(M, N, K, ATL_rone, A, lda, B+N*K, ldb,
                               @(bet1), C, ldc);
         Mjoin(PATLU,pKBmm_bX)(M, N, K, ATL_rone, A+M*K, lda, B+N*K, ldb,
                               ATL_rnone, C+M*N, ldc);
         Mjoin(PATLU,pKBmm_b1)(M, N, K, ATL_rone, A+M*K, lda, B, ldb,
                               ATL_rone, C, ldc);
   }
}

@undef bet0
@undef bet1
@undef be0
@undef be1
@endwhile
@ROUT ATL_prk_kmm
static void ATL_gNBmm_bX(const int M, const int N, const int K, SCALAR alpha,
                         const TYPE *A, const int lda, const TYPE *B,
                         const int ldb, const SCALAR beta, TYPE *C,
                         const int ldc)
{
   if (M == MB && N == NB && K == KB)
      NBmm_bX(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   else if (M != MB)
   {
      if (N == NB && K == KB)
         Mjoin(PATL,pMBmm_bX)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else Mjoin(PATL,pKBmm)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else if (N != NB)  /* ib is full */
   {
      if (K == KB)
         Mjoin(PATL,pNBmm_bX)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else Mjoin(PATL,pKBmm)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else  /* ib and jb are full */
      Mjoin(PATL,pKBmm_bX)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
}

@ROUT ATL_pmmJIK ATL_prk_kmm
static void ATL_gNBmm(const int M, const int N, const int K, SCALAR alpha,
                      const TYPE *A, const int lda, const TYPE *B,
                      const int ldb, const SCALAR beta, TYPE *C,
                      const int ldc)
/* 
 * BETA is known to be 0 or 1
 */
{
   if (M == MB && N == NB && K == KB)
   {
      if (beta == ATL_rone)
         NBmm_b1(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         NBmm_b0(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else if (M != MB)
   {
      if (N == NB && K == KB)
      {
         if (beta == ATL_rone)
            Mjoin(PATL,pMBmm_b1)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         else
            Mjoin(PATL,pMBmm_b0)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      }
      else Mjoin(PATL,pKBmm)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else if (N != NB)  /* ib is full */
   {
      if (K == KB)
      {
         if (beta == ATL_rone)
            Mjoin(PATL,pNBmm_b1)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
         else
            Mjoin(PATL,pNBmm_b0)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      }
      else Mjoin(PATL,pKBmm)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else  /* ib and jb are full */
   {
      if (beta == ATL_rone)
         Mjoin(PATL,pKBmm_b1)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      else
         Mjoin(PATL,pKBmm_b0)(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
}

@ROUT ATL_pmmJIK ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
#define ATL_pmmJIKF      Mjoin(PATL,pmmJIKF)
#define ATL_pmmJIK       Mjoin(PATL,pmmJIK)
#define ATL_prow2blkTF   Mjoin(PATL,prow2blkTF)
#define ATL_pcol2blkF    Mjoin(PATL,pcol2blkF)
#define ATL_pcol2blk     Mjoin(PATL,pcol2blk_a1)
#define ATL_pcol2blk_aX  Mjoin(PATL,pcol2blk_aX)
#define ATL_prow2blkT    Mjoin(PATL,prow2blkT_a1)
#define ATL_prow2blkT_aX Mjoin(PATL,prow2blkT_aX)
#define ATL_pputblk      Mjoin(PATL,pputblk)
#define KBmm            Mjoin(PATL,pKBmm)
@ROUT ATL_pmmJIK

int ATL_pmmJIK(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
               const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
               const int M, const int N, const int K, const SCALAR alpha,
               const TYPE *A, const int lda, const TYPE *B, const int ldb,
               const SCALAR beta, const enum PACK_UPLO UC,
               TYPE *C, const int ldc)
/*
 * Special packed matmul, calls dense gemm kernel using at most
 * K*NB + 2*NB*NB space.  $B$ is copied only once, but $A$ is copied
 * ceil(N/NB) times.  However, $A$ should start in-cache for kernel call.
 */

{
   const int nKb = ATL_DivByNB(K), kb = K - ATL_MulByNB(nKb);
   const int incK = ATL_MulByNB(K);
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldbinc = (UB == AtlasUpper) ? 1 : ((UB == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC == AtlasUpper) ? 1 : ((UC == AtlasLower) ? -1 : 0);
   int ib, jb, i, j, k;
   void *vC;
   TYPE *pC, *pA, *pB;
   NBMM0 pNBmm, pNBmm0;

   vC = malloc(ATL_Cachelen + ATL_MulBySize(NBNB+NBNB+incK));
   if (!vC) return(-1);
   pC = ATL_AlignPtr(vC);
   pA = pC + NBNB;
   pB = pA + NBNB;

/*
 * Loop over column panels of $B$
 */
   for (j=0; j < N; j += NB)
   {
      jb = N - j;
      jb = Mmin(jb, NB);
/*
 *    Copy column-panel of B to block-major storage
 */
      if (alpha == 1.0)
      {
         if (TB == AtlasNoTrans)
            ATL_pcol2blk(K, jb, alpha, B+MindexP(UB,0,j,ldb), Mpld(UB,j,ldb), 
                         ldbinc, pB);
         else /* TB == AtlasTrans */
            ATL_prow2blkT(jb, K, alpha, B+MindexP(UB,j,0,ldb), ldb, ldbinc, pB);
      }
      else if (TB == AtlasNoTrans)
         ATL_pcol2blk_aX(K, jb, alpha, B+MindexP(UB,0,j,ldb), Mpld(UB,j,ldb), 
                         ldbinc, pB);
      else /* TB == AtlasTrans */
         ATL_prow2blkT_aX(jb, K, alpha, B+MindexP(UB,j,0,ldb), ldb, ldbinc, pB);
/*
 *    Loop over row-panels of A
 */
      for (i=0; i < M; i += MB)
      {
         ib = M - i;
         ib = Mmin(ib, MB);
         if (jb != NB || ib != MB)
         {
            pNBmm0 = pNBmm = ATL_gNBmm;
            if (ib != NB && jb != NB) Mjoin(PATL,gezero)(MB, NB, pC, MB);
         }
         else
         {
            pNBmm = NBmm;
            pNBmm0 = NBmm_b0;
         }
/*
 *       Handle full blocks of K
 */
         if (nKb)
         {
            if (TA == AtlasNoTrans)
               ATL_prow2blkT(ib, NB, 1.0, A+MindexP(UA,i,0,lda),
                             lda, ldainc, pA);
            else
               ATL_pcol2blk(NB, ib, 1.0, A+MindexP(UA,0,i,lda),
                            Mpld(UA,i,lda), ldainc, pA);
            pNBmm0(ib, jb, NB, ATL_rone, pA, NB, pB, NB, ATL_rzero, pC, ib);
            for (k=1; k != nKb; k++)
            {
               if (TA == AtlasNoTrans)
                  ATL_prow2blkT(ib, NB, 1.0, A+MindexP(UA,i,ATL_MulByNB(k),lda),
                                Mpld(UA,ATL_MulByNB(k),lda), ldainc, pA);
               else
                  ATL_pcol2blk(NB, ib, 1.0, A+MindexP(UA,ATL_MulByNB(k),i,lda),
                               Mpld(UA,i,lda), ldainc, pA);
               pNBmm(ib, jb, NB, ATL_rone, pA, NB, pB+jb*NB*k, NB,
                     ATL_rone, pC, ib);
            }
            if (kb)
            {
               if (TA == AtlasNoTrans)
                  ATL_prow2blkT(ib, kb, 1.0, 
                                A+MindexP(UA,i,ATL_MulByNB(nKb),lda),
                                Mpld(UA,ATL_MulByNB(nKb),lda), ldainc, pA);
               else
                  ATL_pcol2blk(kb, ib, 1.0, 
                               A+MindexP(UA,ATL_MulByNB(nKb),i,lda),
                               Mpld(UA,i,lda), ldainc, pA);
               ATL_gNBmm(ib, jb, kb, ATL_rone, pA, kb, pB+jb*NB*nKb, kb,
                         ATL_rone, pC, ib);
            }
         }
         else if (kb)
         {
            Mjoin(PATL,gezero)(ib, jb, pC, ib);
            if (TA == AtlasNoTrans)
               ATL_prow2blkT(ib, kb, 1.0, A+MindexP(UA,i,0,lda),
                             lda, ldainc, pA);
            else
               ATL_pcol2blk(kb, ib, 1.0, A+MindexP(UA,0,i,lda),
                            Mpld(UA,i,lda), ldainc, pA);
            ATL_gNBmm(ib, jb, kb, ATL_rone, pA, kb, pB, kb, ATL_rzero, pC, ib);
         }
         ATL_pputblk(ib, jb, pC, C+MindexP(UC,i,j,ldc), Mpld(UC,j,ldc),
                     ldcinc, beta);
      }
   }
   free(vC);
   return(0);
}
int ATL_pmmJIKF(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
                const int M, const int N, const int K, const SCALAR alpha,
                const TYPE *A, const int lda, const TYPE *B, const int ldb,
                const SCALAR beta, const enum PACK_UPLO UC,
                TYPE *C, const int ldc)
/*
 * Special packed matmul, calls dense gemm kernel using at most
 * M*K + K*NB + NB*NB space.  If this exceeds ATL_pkMaxMalloc or fails,
 * operates using at most 2*K*NB + NB*NB.  If this fails, returns non-zero.
 * If full space is malloced, both matrices are copied exactly once.  If
 * the smaller space is used, $A$ will be copied ceil(N/NB) times.
 */
{
   const int nKb = ATL_DivByNB(K), kb = K - ATL_MulByNB(nKb);
   const int incK = ATL_MulByNB(K);
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldbinc = (UB == AtlasUpper) ? 1 : ((UB == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC == AtlasUpper) ? 1 : ((UC == AtlasLower) ? -1 : 0);
   int ib, jb, i, j, k;
   void *vC=NULL;
   TYPE *pC, *pA, *pB, *pA0;
   NBMM0 pNBmm, pNBmm0;
   void (*A2blk)(const int M, const int N, const TYPE alpha, const TYPE *A,
                 int lda, const int ldainc, TYPE *V);

   i = ATL_Cachelen + ATL_MulBySize(NBNB+ATL_MulByNB(K)+M*K);
   if (i <= ATL_pkMaxMalloc) vC = malloc(i);
   if (!vC)
   {
      vC = malloc(ATL_Cachelen + ATL_MulBySize(NBNB+ATL_MulByNB(K+K)));
      if (TA == AtlasNoTrans) A2blk = ATL_prow2blkT;
      else A2blk = ATL_pcol2blk;
   }
   else A2blk = NULL;

   if (!vC) return(-1);
   pC = ATL_AlignPtr(vC);
   pB = pC + NBNB;
   pA = pB + ATL_MulByNB(K);

/*
 * If we've got the space, copy all of A up front
 */
   if (!A2blk)
   {
      if (TA == AtlasNoTrans) 
         ATL_prow2blkTF(M, K, ATL_rone, A, lda, ldainc, pA);
      else ATL_pcol2blkF(K, M, ATL_rone, A, lda, ldainc, pA);
      pA -= ATL_MulByNB(K);
   }
   pA0 = pA;
/*
 * Loop over column panels of $B$
 */
   for (j=0; j < N; j += NB)
   {
      jb = N - j;
      jb = Mmin(jb, NB);
/*
 *    Copy column-panel of B to block-major storage
 */
      if (alpha == 1.0)
      {
         if (TB == AtlasNoTrans)
            ATL_pcol2blk(K, jb, alpha, B+MindexP(UB,0,j,ldb), Mpld(UB,j,ldb), 
                         ldbinc, pB);
         else /* TB == AtlasTrans */
            ATL_prow2blkT(jb, K, alpha, B+MindexP(UB,j,0,ldb), ldb, ldbinc, pB);
      }
      else if (TB == AtlasNoTrans)
         ATL_pcol2blk_aX(K, jb, alpha, B+MindexP(UB,0,j,ldb), Mpld(UB,j,ldb), 
                         ldbinc, pB);
      else /* TB == AtlasTrans */
         ATL_prow2blkT_aX(jb, K, alpha, B+MindexP(UB,j,0,ldb), ldb, ldbinc, pB);
/*
 *    Loop over row-panels of A
 */
      for (i=0; i < M; i += MB)
      {
         ib = M - i;
         ib = Mmin(ib, MB);
         if (A2blk)
         {
            if (TA == AtlasNoTrans)
               ATL_prow2blkT(ib, K, ATL_rone, A+MindexP(UA,i,0,lda), lda,
                             ldainc, pA);
            else /* TA == AtlasTrans */
               ATL_pcol2blk(K, ib, ATL_rone, A+MindexP(UA,0,i,lda),
                            Mpld(UA,i,lda), ldainc, pA);
         }
         else pA += ATL_MulByNB(K);
         if (jb != NB || ib != MB)
         {
            pNBmm0 = pNBmm = ATL_gNBmm;
            if (ib != NB && jb != NB) Mjoin(PATL,gezero)(MB, NB, pC, MB);
         }
         else
         {
            pNBmm = NBmm;
            pNBmm0 = NBmm_b0;
         }
/*
 *       Handle full blocks of K
 */
         if (nKb)
         {
            pNBmm0(ib, jb, NB, ATL_rone, pA, NB, pB, NB, ATL_rzero, pC, ib);
            for (k=1; k != nKb; k++)
            {
               pNBmm(ib, jb, NB, ATL_rone, pA+ib*NB*k, NB, pB+jb*NB*k, NB,
                     ATL_rone, pC, ib);
            }
            if (kb)
               ATL_gNBmm(ib, jb, kb, ATL_rone, pA+ib*NB*nKb, kb,
                         pB+jb*NB*nKb, kb, ATL_rone, pC, ib);
         }
         else if (kb)
         {
            Mjoin(PATL,gezero)(ib, jb, pC, ib);
            ATL_gNBmm(ib, jb, kb, ATL_rone, pA, kb, pB, kb, ATL_rzero, pC, ib);
         }
         ATL_pputblk(ib, jb, pC, C+MindexP(UC,i,j,ldc), Mpld(UC,j,ldc),
                     ldcinc, beta);
      }
      pA = pA0;
   }
   free(vC);
   return(0);
}

@ROUT ATL_prankK
#include "atlas_pkblas.h"

void Mjoin(PATL,prankK)
   (const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
    const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
    const int M, const int N, const int K, int R, const SCALAR alpha,
    const TYPE *A, int lda, const TYPE *B, int ldb,
    const SCALAR beta0, const enum PACK_UPLO UC, TYPE *C, int ldc)
/*
 * This routine performs a packed matrix multiply by doing ceil(K/R)
 * rank-R updates of C.  This is primarily done for CacheEdge, but
 * is also useful to auto-reduce R until enough workspace may be allocated.
 */
{
   int k=0, kb;
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldbinc = (UB == AtlasUpper) ? 1 : ((UB == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC == AtlasUpper) ? 1 : ((UC == AtlasLower) ? -1 : 0);
   #ifdef TCPLX
      TYPE beta[2];
   #else
      TYPE beta = beta0;
   #endif
   int (*ATL_mm)(const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                 const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
                 const int M, const int N, const int K, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *B, const int ldb,
                 const SCALAR beta, const enum PACK_UPLO UC,
                 TYPE *C, const int ldc);

   #ifdef TCPLX
      beta[0] = *beta0;
      beta[1] = beta0[1];
   #endif
   ATL_mm = Mjoin(PATL,pmmJIKF);
   R = Mmin(R, K);
   do
   {
      kb = K - k;
      kb = Mmin(R, kb);
/*
 *    If we can't do the rank-R update, reduce R and/or use a lower-memory
 *    algorithm until we can
 */
      if (ATL_mm(UA, TA, UB, TB, M, N, kb, alpha, A, lda, B, ldb, beta, 
                 UC, C, ldc))
      {
         kb = (R>>1);
         kb = ATL_DivByNB(kb);
         if (kb) R = ATL_MulByNB(kb);
         else
         {
            if (ATL_mm != Mjoin(PATL,pmmJIK)) ATL_mm = Mjoin(PATL,pmmJIK);
            else
            {
               ATL_assert(R > 1);
               R = (R>>1);
            }
         }
      }
      else
      {
         #ifdef TREAL
            beta = ATL_rone;
         #else
            *beta = ATL_rone;
            beta[1] = ATL_rzero;
         #endif
         if (TA == AtlasNoTrans)
         {
            A += MindexP(UA, 0, R, lda);
            lda = Mpld(UA, R, lda);
         }
         else A += MindexP(UA, R, 0, lda);
         if (TB == AtlasNoTrans) B += MindexP(UB, R, 0, ldb);
         else
         {
            B += MindexP(UB, 0, R, ldb);
            ldb = Mpld(UB, R, ldb);
         }
         k += R;
      }
   }
   while(k < K);
}
@ROUT ATL_sprk_rK
   @define rt @sprk@
   @define rk @prk@
   @define Trans_   @AtlasTrans@
@ROUT ATL_hprk_rK
   @define rt @hprk@
   @define rk @phk@
   @define Trans_   @AtlasConjTrans@
@ROUT ATL_sprk_rK ATL_hprk_rK
   @define NoTrans_ @AtlasNoTrans@
#include "atlas_pkblas.h"

static void ATL_rk_recUN
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta, TYPE *C, const int ldc)
/*
 * For upper notrans matrix, use recursion to reduce N until enough memory
 * can be allocated
 */
{
   int Nright, Nleft;
   const enum PACK_UPLO UC2 = (CP ? (enum PACK_UPLO)UC : PackGen);
   if (Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, K, alpha, A, lda, beta, CP, C, ldc))
   {
      Nleft = N >> 1;
      #ifdef NB
         if (Nleft > NB) Nleft = ATL_MulByNB(ATL_DivByNB(Nleft));
      #endif
      Nright = N - Nleft;
      ATL_rk_recUN(UA, TA, UC, CP, Nleft, K, alpha, A, lda, beta, C, ldc);
      Mjoin(PATL,gpmm)(PackGen, TA, PackGen, @(Trans_), CP ? PackUpper:PackGen, 
                       Nleft, Nright, K, alpha, A, 0, 0, lda, 
                       A+(Nleft SHIFT), 0, 0, lda, beta, 
                       C+MindexP(UC2,0,Nleft,ldc), 0, 0, Mpld(UC2,Nleft,ldc));
      ATL_rk_recUN(UA, TA, UC, CP, Nright, K, alpha, A+(Nleft SHIFT), lda, 
                  beta, C+MindexP(UC2,Nleft,Nleft,ldc), Mpld(UC2,Nleft,ldc));
   }
}

static void ATL_rk_recUT
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta, TYPE *C, const int ldc)
/*
 * For upper trans matrix, use recursion to reduce N until enough memory
 * can be allocated
 */
{
   int Nright, Nleft;
   const enum PACK_UPLO UC2 = (CP ? (enum PACK_UPLO)UC : PackGen);
   if (Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, K, alpha, A, lda, beta, CP, C, ldc))
   {
      Nleft = N >> 1;
      #ifdef NB
         if (Nleft > NB) Nleft = ATL_MulByNB(ATL_DivByNB(Nleft));
      #endif
      Nright = N - Nleft;
      ATL_rk_recUT(UA, TA, UC, CP, Nleft, K, alpha, A, lda, beta, C, ldc);
      Mjoin(PATL,gpmm)(PackGen, TA, PackGen, @(NoTrans_), CP?PackUpper:PackGen, 
                       Nleft, Nright, K, alpha, A, 0, 0, lda, 
                       A+Nleft*(lda SHIFT), 0, 0, lda, beta, 
                       C+MindexP(UC2,0,Nleft,ldc), 0, 0, Mpld(UC2,Nleft,ldc));
      ATL_rk_recUT(UA, TA, UC, CP, Nright, K, alpha, A+(Nleft SHIFT)*lda, lda, 
                  beta, C+MindexP(UC2,Nleft,Nleft,ldc), Mpld(UC2,Nleft,ldc));
   }
}

static void ATL_rk_recLN
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta, TYPE *C, const int ldc)
/*
 * For lower notrans matrix, use recursion to reduce N until enough memory
 * can be allocated
 */
{
   int Nright, Nleft;
   const enum PACK_UPLO UC2 = (CP ? (enum PACK_UPLO)UC : PackGen);
   if (Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, K, alpha, A, lda, beta, CP, C, ldc))
   {
      Nleft = N >> 1;
      #ifdef NB
         if (Nleft > NB) Nleft = ATL_MulByNB(ATL_DivByNB(Nleft));
      #endif
      Nright = N - Nleft;
      ATL_rk_recLN(UA, TA, UC, CP, Nleft, K, alpha, A, lda, beta, C, ldc);
      Mjoin(PATL,gpmm)(PackGen, TA, PackGen, @(Trans_), CP ? PackLower:PackGen, 
                       Nright, Nleft, K, alpha, A+(Nleft SHIFT), 0, 0, lda, 
                       A, 0, 0, lda, beta, 
                       C+MindexP(UC2,Nleft,0,ldc), 0, 0, ldc);
      ATL_rk_recLN(UA, TA, UC, CP, Nright, K, alpha, A+(Nleft SHIFT), lda, 
                   beta, C+MindexP(UC2,Nleft,Nleft,ldc), Mpld(UC2,Nleft,ldc));
   }
}
static void ATL_rk_recLT
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta, TYPE *C, const int ldc)
/*
 * For lower notrans matrix, use recursion to reduce N until enough memory
 * can be allocated
 */
{
   int Nright, Nleft;
   const enum PACK_UPLO UC2 = (CP ? (enum PACK_UPLO)UC : PackGen);
   if (Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, K, alpha, A, lda, beta, CP, C, ldc))
   {
      Nleft = N >> 1;
      #ifdef NB
         if (Nleft > NB) Nleft = ATL_MulByNB(ATL_DivByNB(Nleft));
      #endif
      Nright = N - Nleft;
      ATL_rk_recLT(UA, TA, UC, CP, Nleft, K, alpha, A, lda, beta, C, ldc);
      Mjoin(PATL,gpmm)(PackGen, TA, PackGen, @(NoTrans_), CP?PackLower:PackGen, 
                       Nright, Nleft, K, alpha, A+lda*(Nleft SHIFT), 0, 0, lda, 
                       A, 0, 0, lda, beta, 
                       C+MindexP(UC2,Nleft,0,ldc), 0, 0, ldc);
      ATL_rk_recLT(UA, TA, UC, CP, Nright, K, alpha, A+lda*(Nleft SHIFT), lda, 
                   beta, C+MindexP(UC2,Nleft,Nleft,ldc), Mpld(UC2,Nleft,ldc));
   }
}

void Mjoin(PATL,@(rt)_rK)
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, int R, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta0, TYPE *C, const int ldc)
/*
 * This routine does the packed symmetric rank-K update by doing ceil(K/R)
 * rank-R updates of C.  This primarily done for CacheEdge, but is also
 * useful to auto-reduce R until enough workspace may be allocated.
 */
{
   const enum PACK_UPLO UC2 = ((CP) ? (enum PACK_UPLO)UC : PackGen);
   int k=0, kb, ierr;
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC2 == AtlasUpper) ? 1 : ((UC2 == AtlasLower) ? -1 : 0);
   #ifdef TREAL
      TYPE beta = beta0;
   #else
      TYPE beta[2];
      *beta = *beta0;
      beta[1] = beta0[1];
   #endif

   if (R < NB) R = NB<<4;
   if ((K - R) < 2*NB) R = K;
   do
   {
      kb = K - k;
      if (kb - R < 2*NB) R = kb;
      kb = Mmin(R, kb);
/*
 *    If we can't do the rank-R update, reduce R until we can, or R = 1
 */
      ierr = Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, kb, alpha,
                                 A, lda, beta, CP, C, ldc);
      if (ierr && R <= NB*8)
      {
         if (UC == AtlasUpper)
         {
            if (TA == AtlasNoTrans)
               ATL_rk_recUN(UA, TA, UC, CP, N, kb, alpha, A, lda, beta, C, ldc);
            else
               ATL_rk_recUT(UA, TA, UC, CP, N, kb, alpha, A, lda, beta, C, ldc);
         }
         else
         {
            if (TA == AtlasNoTrans)
               ATL_rk_recLN(UA, TA, UC, CP, N, kb, alpha, A, lda, beta, C, ldc);
            else
               ATL_rk_recLT(UA, TA, UC, CP, N, kb, alpha, A, lda, beta, C, ldc);
         }
         ierr = 0;
      }
      if (ierr)
      {
         R = Mmin(NB*8, R>>1);
         ATL_assert(R);
      }
/*
 *    Subsequent updates use beta = 1
 */
      else
      {
         #ifdef TREAL
            beta = ATL_rone;
         #else
            *beta = ATL_rone;
            beta[1] = ATL_rzero;
         #endif
         if (TA == AtlasNoTrans)
         {
            A += MindexP(UA, 0, R, lda);
            lda = Mpld(UA, R, lda);
         }
         else A += MindexP(UA, R, 0, lda);
         k += R;
      }
   }
   while(k < K);
}
@beginskip
void Mjoin(PATL,@(rt)_rK)
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
    const int N, const int K, int R, const SCALAR alpha,
    const TYPE *A, int lda, const SCALAR beta0, TYPE *C, const int ldc)
/*
 * This routine does the packed symmetric rank-K update by doing ceil(K/R)
 * rank-R updates of C.  This primarily done for CacheEdge, but is also
 * useful to auto-reduce R until enough workspace may be allocated.
 */
{
   const enum PACK_UPLO UC2 = ((CP) ? (enum PACK_UPLO)UC : PackGen);
   int k=0, kb;
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC2 == AtlasUpper) ? 1 : ((UC2 == AtlasLower) ? -1 : 0);
   #ifdef TREAL
      TYPE beta = beta0;
   #else
      TYPE beta[2];
      *beta = *beta0;
      beta[1] = beta0[1];
   #endif

   if ((K - R) < 2*NB) R = K;
   do
   {
      kb = K - k;
      if (kb - R < 2*NB) R = kb;
      kb = Mmin(R, kb);
/*
 *    If we can't do the rank-R update, reduce R until we can, or R = 1
 */
      if (Mjoin(PATL,@(rk)_kmm)(UC, UA, TA, N, kb, alpha, 
                              A, lda, beta, CP, C, ldc))
      {
         kb = (R>>1);
         kb = ATL_DivByNB(kb);
         if (kb) R = ATL_MulByNB(kb);
         else
         {
            ATL_assert(R > 1);
            R = (R>>1);
         }
      }
/*
 *    Subsequent updates use beta = 1
 */
      else
      {
         #ifdef TREAL
            beta = ATL_rone;
         #else
            *beta = ATL_rone;
            beta[1] = ATL_rzero;
         #endif
         if (TA == AtlasNoTrans)
         {
            A += MindexP(UA, 0, R, lda);
            lda = Mpld(UA, R, lda);
         }
         else A += MindexP(UA, R, 0, lda);
         k += R;
      }
   }
   while(k < K);
}
@endskip
@ROUT ATL_sprk
   @define rt @sprk@
@ROUT ATL_hprk
   @define rt @hprk@
@ROUT ATL_sprk ATL_hprk
#include "atlas_pkblas.h"
#include "atlas_cacheedge.h"
void Mjoin(PATL,@(rt))
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum ATLAS_UPLO UC, const int CP,
@ROUT ATL_hprk
    const int N, const int K, const TYPE alpha0,
    const TYPE *A, const int IA, const int JA, const int lda,
    const TYPE beta0, TYPE *C, const int IC, const int JC, const int ldc)
@ROUT ATL_sprk
    const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int IA, const int JA, const int lda,
    const SCALAR beta, TYPE *C, const int IC, const int JC, const int ldc)
@ROUT ATL_sprk ATL_hprk
{
   const enum PACK_UPLO UC2 = ((CP) ? (enum PACK_UPLO)UC : PackGen);
   int j;
   #ifdef CacheEdge
      static const int CE_K = ((ATL_DivBySize(CacheEdge SHIFT)-(NBNB SHIFT)) /
                                           (NB*(NB+NB)))*NB;
   #else
      #define CE_K K
   #endif
@ROUT ATL_hprk
   TYPE beta[2], alpha[2];
   beta[0] = beta0;   beta[1] = ATL_rzero;
   alpha[0] = alpha0; alpha[1] = ATL_rzero;
@ROUT ATL_sprk ATL_hprk

   if ((!N) || ((SCALAR_IS_ZERO(alpha) || (!K)) && (SCALAR_IS_ONE(beta))))
      return;
   if (!K || SCALAR_IS_ZERO(alpha))
   {
      if (UC == CblasLower)
      {
         for (j=0; j != N; j++)
            Mjoin(PATL,scal)(N-j, beta, C+MindexP(UC2,IC+j,JC+j,ldc), 1);
      }
      else /* UC == CblasUpper */
      {
         for (j=0; j != N; j++)
            Mjoin(PATL,scal)(j+1, beta, C+MindexP(UC2,IC,JC+j,ldc), 1);
      }
@ROUT ATL_hprk
      if (*beta != ATL_rzero)
         for (j=0; j < N; j++)
            C[MindexP(UC2,IC+j,JC+j,ldc)+1] = ATL_rzero;
@ROUT ATL_sprk ATL_hprk
      return;
   }
   Mjoin(PATL,@(rt)_rK)(UA, TA, UC, CP, N, K, CE_K, alpha, A, lda, beta, C, ldc);
}
@ROUT ATL_gpmm
#include "atlas_pkblas.h"
#include "atlas_cacheedge.h"

@beginskip
static int MindexP(const enum ATLAS_UPLO uplo, const int I, const int J,
                   const int lda)
{
   int iret;
   if (uplo == AtlasUpper) iret = MindexPU(I, J, lda);
   else if (uplo == AtlasLower) iret = MindexPL(I, J, lda);
   else iret = J*lda + I;
   return(iret);
}

@endskip
void Mjoin(PATL,gpmm)
   (const enum PACK_UPLO UA, const enum PACK_TRANS TA,
    const enum PACK_UPLO UB, const enum PACK_TRANS TB, const enum PACK_UPLO UC,
    const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int IA, const int JA, const int lda,
    const TYPE *B, const int IB, const int JB, const int ldb,
    const SCALAR beta, TYPE *C, const int IC, const int JC, const int ldc)
{
   int j;
   #ifdef CacheEdge
      static const int CE_K = ((ATL_DivBySize(CacheEdge)-(NBNB SHIFT)) /
                                           (NB*(NB+NB)))*NB;
   #else
      #define CE_K K
   #endif
   if (!M || !N) return;
   if (!K || SCALAR_IS_ZERO(alpha))
   {
      for (j=0; j != N; j++)
         Mjoin(PATL,scal)(M, beta, C+MindexP(UC,IC,JC+j,ldc), 1);
      return;
   }
/*
 * Packed gpmm not yet implemented for complex, 
 * so die if not really a dense gemm
 */
   #ifdef TCPLX
      ATL_assert (UA == PackGen && UB == PackGen && UC == PackGen);
      Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   #else
   Mjoin(PATL,prankK)(UA, TA, UB, TB, M, N, K, CE_K, alpha, 
          A+MindexP(UA,IA,JA,lda), Mpld(UA,JA,lda), B+MindexP(UB,IB,JB,ldb),
          Mpld(UB,JB,ldb), beta, UC, C+MindexP(UC,IB,JB,ldc), Mpld(UC,JC,ldc));
   #endif
}
@beginskip
{
   TYPE *pA, *pB, *pC;
   void ge2tp(const enum PACK_UPLO uplo, int M, int N, const TYPE *A, int lda,
              TYPE *P, int ldp);
   void tp2ge(const enum PACK_UPLO uplo, int M, int N, const TYPE *P, int ldp,
              TYPE *A, int lda);

   if (UA != PackGen)
   {
      pA = malloc(lda*lda*ATL_sizeof);
      ATL_assert(pA);
      tp2ge(UA, lda, lda, A, lda, pA, lda);
   }
   else pA = (TYPE*) A;
   if (UB != PackGen)
   {
      pB = malloc(ldb*ldb*ATL_sizeof);
      ATL_assert(pB);
      tp2ge(UB, ldb, ldb, B, ldb, pB, ldb);
   }
   else pB = (TYPE*) B;
   if (UC != PackGen)
   {
      pC = malloc(ldc*ldc*ATL_sizeof);
      ATL_assert(pC);
      tp2ge(UC, ldc, ldc, C, ldc, pC, ldc);
   }
   else pC = (TYPE*) C;
/*   if (UA == PackGen && UB == PackGen && UC == PackGen) */
   Mjoin(PATL,gemm)(TA, TB, M, N, K, alpha, pA+IA+JA*lda, lda, pB+IB+JB*ldb,
                    ldb, beta, pC+IB+JB*ldc, ldc);
   if (pC != C)
      ge2tp(UC, ldc, ldc, pC, ldc, C, ldc);
}
@endskip
@ROUT ATL_prk_kmm 
   @define nbnb @NBNB@
   @define one  @ATL_rone@
   @define zero @ATL_rzero@
   @define ldc @ldcc@
   @define cc  @c@
   @define bet @cbeta@
@ROUT ATL_cprk_kmm ATL_phk_kmm
   @define ldc @ib@
   @define nbnb @NBNB2@
   @define one @one@
   @define zero @zero@
   @define cc  @pC@
   @define bet @ATL_rzero@
#define pNBmm  ATL_gNBmm_b1
#define pNBmm0 ATL_gNBmm_b0
#define ATL_gNBmm ATL_gNBmm_b1
@ROUT  ATL_phk_kmm
int Mjoin(PATL,phk_kmm)(const enum ATLAS_UPLO UC,
@ROUT ATL_prk_kmm ATL_cprk_kmm
int Mjoin(PATL,prk_kmm)(const enum ATLAS_UPLO UC,
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
                        const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
                        const int N, const int K, const SCALAR alpha, 
                        const TYPE *A, const int lda, const SCALAR beta,
                        const int CP, TYPE *C, const int ldc)
/*
 * If CP == 0, then C is a general rectangular matrix.
 * If CP != 0, then C is packed matrix.
 * In both cases, UC tells what portion of the matrix to update.
 * Performs a syrk/sprk by calling the gemm kernel directly
 */
{
   const enum PACK_UPLO UC2 = ((CP) ? (enum PACK_UPLO)UC : PackGen);
   const int nKb = ATL_DivByNB(K), kb = K - ATL_MulByNB(nKb);
   const int KK = K - kb;
   const int incK = ATL_MulByNB(K)SHIFT;
   const int ldainc = (UA == AtlasUpper) ? 1 : ((UA == AtlasLower) ? -1 : 0);
   const int ldcinc = (UC2 == AtlasUpper) ? 1 : ((UC2 == AtlasLower) ? -1 : 0);
@ROUT ATL_prk_kmm
   const int BUFC = (CP || K >= (NB*12) || (alpha != ATL_rone));
   int ldcc;
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
   int i, j, k, ib, jb, iend;
   void *vC=NULL;
   TYPE *pC, *pA, *pB, *c;
@ROUT ATL_cprk_kmm ATL_phk_kmm
   const int K2 = K + K;
   const TYPE one[2] = {ATL_rone, ATL_rzero}; 
@skip   zero[2] = {ATL_rzero, ATL_rzero};
@ROUT ATL_prk_kmm
   TYPE cbeta;
   NBMM0 pNBmm, pNBmm0;
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm

@ROUT ATL_phk_kmm
/*
 * Grab enough space for NBxNB C workspace and all of A, a panel of B,
 * and copy all of A.  If this is too much, we will reduce K in outer routine
 * until malloc succeeds
 */
   i = ATL_Cachelen + ATL_MulBySize(NBNB+(N+NB)*K);
   if (i <= ATL_pkMaxMalloc || K <= NB) vC = malloc(i);
   if (!vC) return(-1);
   pC = ATL_AlignPtr(vC);
   pB = pC + @(nbnb);
   pA = pB + incK;
   if (TA == AtlasNoTrans)
      Mjoin(ATL_prow2blkTF,_blk)(NB, N, K, @(one), A, lda, ldainc, pA);
   else
      Mjoin(Mjoin(PATL,pcol2blkConjF),_blk)(NB, K, N, @(one), A,lda,ldainc,pA);
@ROUT ATL_prk_kmm ATL_cprk_kmm
/*
 * Grab enough space for NBxNB C workspace and all of A, and copy all of A.
 * If this is too much, we will reduce K in outer routine until malloc succeeds
 */
   i = ATL_Cachelen + ATL_MulBySize(NBNB+N*K);
   if (i <= ATL_pkMaxMalloc || K <= NB) vC = malloc(i);
   if (!vC) return(-1);
   pC = ATL_AlignPtr(vC);
   pB = pC + @(nbnb);
@ROUT ATL_prk_kmm
   if (TA == AtlasNoTrans)
      ATL_prow2blkTF(N, K, @(one), A, lda, ldainc, pB);
   else ATL_pcol2blkF(K, N, @(one), A, lda, ldainc, pB);
@ROUT ATL_cprk_kmm
   if (TA == AtlasNoTrans)
      Mjoin(ATL_prow2blkTF,_blk)(NB, N, K, @(one), A, lda, ldainc, pB);
   else Mjoin(ATL_pcol2blkF,_blk)(NB, K, N, @(one), A, lda, ldainc, pB);
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
/*
 * Loop over column panels of $C$
 */
   for (j=0; j < N; j += NB)
   {
      jb = N-j;
      jb = Mmin(jb, NB);
@ROUT ATL_phk_kmm
/*
 *    Conjugate row-panel of A to create col-panel of B
 */
      pA = pC + NBNB2 + incK + j*(K2);
      for (i=0; i < K; i += NB)
      {
         ib = K - i;
         ib = Mmin(ib, NB);
         iend = ib * jb;
         Mjoin(PATLU,cpsc)(iend, -(*alpha), pA, 1, pB, 1);
         Mjoin(PATLU,cpsc)(iend, *alpha, pA+iend, 1, pB+iend, 1);
         pA += iend+iend;
         pB += iend+iend;
      }
      pB = pC + NBNB2;
@skip      for (i=0; i < jb; i++)
@skip         Mjoin(PATL,moveConj)(K, alpha, pA+K2*i, 1, pB+K2*i, 1);
      
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
/*
 *    Loop over row panels of $C$
 */
      iend   = (UC == AtlasUpper) ? j+1 : N;
      for (i=((UC == AtlasUpper) ? 0 : j); i < iend; i += NB)
      {
@ROUT ATL_phk_kmm
         pA = pC + NBNB2 + incK + i*K2;
@ROUT ATL_prk_kmm ATL_cprk_kmm
         pA = pC + @(nbnb) + i*(K SHIFT);
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
         ib = N-i;
         ib = Mmin(ib, NB);
@ROUT ATL_prk_kmm
         if (ib == NB && jb == NB)
         {
            pNBmm = NBmm;
            if (BUFC || i == j)
            {
               c = pC;
               ldcc = ib;
               pNBmm0 = NBmm_b0;
               cbeta = ATL_rzero;
            }
            else
            {
               c = C+i+j*ldc;
               ldcc = ldc;
               if (beta == ATL_rone) pNBmm0 = NBmm;
               else if (beta == ATL_rzero) pNBmm0 = NBmm_b0;
               else pNBmm0 = NBmm_bX;
               cbeta = beta;
            }
         }
         else /* if (ib != NB || jb != NB) */
         {
            pNBmm0 = pNBmm = ATL_gNBmm;
            if (BUFC || i == j)
            {
               c = pC;
               ldcc = ib;
               cbeta = ATL_rzero;
               Mjoin(PATL,gezero)(ib, jb, @(cc), @(ldc));
            }
            else
            {
               c = C+i+j*ldc;
               ldcc = ldc;
               cbeta = beta;
               if (beta == ATL_rzero)
                  Mjoin(PATL,gezero)(ib, jb, @(cc), @(ldc));
               else if (beta != ATL_rone) pNBmm0 = ATL_gNBmm_bX;
            }
         }
@ROUT ATL_cprk_kmm ATL_phk_kmm
         if (ib != NB || jb != NB)
            Mjoin(PATL,gezero)(ib, jb, pC, ib);
@ROUT ATL_cprk_kmm ATL_phk_kmm ATL_prk_kmm
         if (nKb)
         {
            pNBmm0(ib, jb, NB, ATL_rone, pA, NB, pB, NB, @(bet), @(cc), @(ldc));
            for (k=NB; k != KK; k += NB)
               pNBmm(ib, jb, NB, ATL_rone, pA+ib*(k SHIFT), NB, pB+jb*(k SHIFT),
                     NB, ATL_rone, @(cc), @(ldc));
            if (kb)
               ATL_gNBmm(ib, jb, kb, ATL_rone, pA+ib*(KK SHIFT), kb, 
                         pB+jb*(KK SHIFT), kb, ATL_rone, @(cc), @(ldc));
         }
         else if (kb)
         {
@ROUT ATL_cprk_kmm ATL_phk_kmm
            if (ib == NB && jb == NB) Mjoin(PATL,gezero)(ib, jb, pC, ib);
            ATL_gNBmm(ib,jb,kb, ATL_rone, pA, kb, pB, kb, ATL_rzero, @(cc), @(ldc));
@ROUT ATL_prk_kmm
            if (cbeta == ATL_rzero && ib == NB && jb == NB)
               Mjoin(PATL,gezero)(ib, jb, c, ldcc);
            if (c == pC || cbeta == ATL_rzero || cbeta == ATL_rone)
               ATL_gNBmm(ib,jb,kb, ATL_rone, pA, kb, pB, kb, cbeta, 
                         @(cc), @(ldc));
            else
               ATL_gNBmm_bX(ib,jb,kb, ATL_rone, pA, kb, pB, kb, cbeta, 
                            @(cc), @(ldc));
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
         }
@ROUT ATL_phk_kmm
         if (i != j)
            Mjoin(PATL,pputblk_aX)(ib, jb, pC, C+MindexP(UC2,i,j,ldc), 
                                   Mpld(UC2,j,ldc), ldcinc, one, beta);
         else
         {
            Mjoin(PATL,pputblk_diag)(ib, jb, pC, UC, C+MindexP(UC2,i,j,ldc),
                                     Mpld(UC2,j,ldc), ldcinc, one, beta);
/*
 *          This is ugly, should specialize putblk_diag to do this.
 *          Zero out imag of main diag; fixes case for non-zero BETA, and
 *          also fixes any computational problem where answer is 0, but
 *          due to roundoff becomes non-zero
 *          NOTE: ib == jb for diag case
 */
            for (k=0; k < jb; k++)  
               C[MindexP(UC2,i+k,j+k,ldc)+1] = ATL_rzero;
         }
@ROUT ATL_prk_kmm
         if (c == pC)
         {
            if (i != j)
               Mjoin(PATL,pputblk_aX)(ib, jb, pC, C+MindexP(UC2,i,j,ldc), 
                                      Mpld(UC2,j,ldc), ldcinc, alpha, beta);
            else
               Mjoin(PATL,pputblk_diag)(ib, jb, pC, UC, C+MindexP(UC2,i,j,ldc),
                                        Mpld(UC2,j,ldc), ldcinc, alpha, beta);
         }
@ROUT ATL_cprk_kmm
         if (i != j)
            Mjoin(PATL,pputblk_aX)(ib, jb, pC, C+MindexP(UC2,i,j,ldc), 
                                   Mpld(UC2,j,ldc), ldcinc, alpha, beta);
         else
            Mjoin(PATL,pputblk_diag)(ib, jb, pC, UC, C+MindexP(UC2,i,j,ldc),
                                     Mpld(UC2,j,ldc), ldcinc, alpha, beta);
@ROUT ATL_prk_kmm ATL_cprk_kmm ATL_phk_kmm
      }
@ROUT ATL_prk_kmm ATL_cprk_kmm `      pB += incK;`
   }
@beginskip
   if (UC == AtlasUpper)
   {
/*
 *    Loop over column panels of $C$
 */
      for (j=0; j < N; j += NB)
      {
         jb = N-j;
         jb = Mmin(jb, NB);
/*
 *       Loop over row panels of $C$
 */
         for (i=0; i <= j; i += NB)
         {
            pA = pC + NBNB + i*K;
            ib = N-i;
            ib = Mmin(ib, NB);
            if (ib == NB && jb == NB)
            {
               pNBmm = NBmm;
               pNBmm0 = NBmm_b0;
            }
            else /* if (ib != NB || jb != NB) */
            {
               pNBmm0 = pNBmm = ATL_gNBmm;
               Mjoin(PATL,gezero)(ib, jb, pC, ib);
            }
            if (nKb)
            {
               pNBmm0(ib, jb, NB, ATL_rone, pA, NB, pB, NB, ATL_rzero, pC, ib);
               for (k=1; k != nKb; k++)
                  pNBmm(ib, jb, NB, ATL_rone, pA+ib*NB*k, NB, pB+jb*NB*k, NB,
                        ATL_rone, pC, ib);
               if (kb)
                  ATL_gNBmm(ib, jb, kb, ATL_rone, pA+ib*NB*nKb, kb, 
                            pB+jb*NB*nKb, kb, ATL_rone, pC, ib);
            }
            else if (kb)
            {
               if (pNBmm0 == NBmm) Mjoin(PATL,gezero)(ib, jb, pC, ib);
               ATL_gNBmm(ib,jb,kb, ATL_rone, pA, kb, pB, kb, ATL_rzero, pC, ib);
            }
            if (i != j)
               Mjoin(PATL,pputblk_aX)(ib, jb, pC, C+MindexP(UC2,i,j,ldc), 
                                      Mpld(UC2,j,ldc), ldcinc, alpha, beta);
            else
               Mjoin(PATL,pputblk_diag)(ib, jb, pC, UC, C+MindexP(UC2,i,j,ldc),
                                        Mpld(UC2,j,ldc), ldcinc, alpha, beta);
         }
         pB += incK;
      }
   }
   else /* C is 'Lower' */
   {
/*
 *    Loop over column panels of $C$
 */
      for (j=0; j < N; j += NB)
      {
         jb = N-j;
         jb = Mmin(jb, NB);
/*
 *       Loop over row panels of $C$
 */
         for (i=j; i < N; i += NB)
         {
            pA = pC + NBNB + i*K;
            ib = N-i;
            ib = Mmin(ib, NB);
            if (ib == NB && jb == NB)
            {
               pNBmm = NBmm;
               pNBmm0 = NBmm_b0;
            }
            else /* if (ib != NB || jb != NB) */
            {
               pNBmm0 = pNBmm = ATL_gNBmm;
               Mjoin(PATL,gezero)(ib, jb, pC, ib);
            }
            if (nKb)
            {
               pNBmm0(ib, jb, NB, ATL_rone, pA, NB, pB, NB, ATL_rzero, pC, ib);
               for (k=1; k != nKb; k++)
                  pNBmm(ib, jb, NB, ATL_rone, pA+ib*NB*k, NB, pB+jb*NB*k, NB,
                        ATL_rone, pC, ib);
               if (kb)
                  ATL_gNBmm(ib, jb, kb, ATL_rone, pA+ib*NB*nKb, kb, 
                            pB+jb*NB*nKb, kb, ATL_rone, pC, ib);
            }
            else if (kb)
            {
               if (pNBmm0 == NBmm) Mjoin(PATL,gezero)(ib, jb, pC, ib);
               ATL_gNBmm(ib, jb, kb, ATL_rone, pA, kb, pB, kb, ATL_rzero,pC,ib);
            }
            if (i != j)
               Mjoin(PATL,pputblk_aX)(ib, jb, pC, C+MindexP(UC2,i,j,ldc), 
                                      Mpld(UC2,j,ldc), ldcinc, alpha, beta);
            else
               Mjoin(PATL,pputblk_diag)(ib, jb, pC, UC, C+MindexP(UC2,i,j,ldc),
                                        Mpld(UC2,j,ldc), ldcinc, alpha, beta);
         }
         pB += incK;
      }
   }
@endskip
   free(vC);
   return(0);
}
@ROUT gpmmtst
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "atlas_misc.h"
#include "atlas_lvl3.h"
#include "atlas_tst.h"
#include "cblas.h"
#include "atlas_pkblas.h"

#ifndef L2SIZE
   #define L2SIZE 4194304
#endif

#ifdef ATL_DeclareSlens
F77_INTEGER ATL_Slen1, ATL_Slen2;
#endif
double time00();

#if defined(TRUST_C)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(Mjoin(cblas_,PRE),gemm) \
         (CblasColMajor, TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#elif defined(TRUST_SMALL)
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,small_mm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#else
   #define trusted_gemm(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc) \
      Mjoin(PATL,f77gemm)(TA, TB, m, n, k, al, A, lda, B, ldb, be, C, ldc)
#endif

#define test_gpmm(UA, TA, UB, TB, UC, m, n, k, al, A, IA, JA, lda, \
                  B, IB, JB, ldb, be, C, IC, JC, ldc) \
   Mjoin(PATL,gpmm)(UA, TA, UB, TB, UC, m, n, k, al, A, IA, JA, lda, \
                    B, IB, JB, ldb, beta, C, IC, JC, ldc);


void matgen(int M, int N, TYPE *A, int lda, int seed)
{
   int i, j;

#ifdef TCPLX
   M *= 2;
   lda *= 2;
#endif
   dumb_seed(seed);
   for (j=N; j; j--)
   {
      for (i=0; i != M; i++) A[i] = dumb_rand();
      A += lda;
   }
}

void ge2tp(enum PACK_UPLO uplo, int M, int N, TYPE *A, int lda,
           TYPE *P, int ldp)
{
   int i, j;

   if (uplo == PackUpper)
   {
      for (j=0; j < N; j++)
      {
         for (i=0; i <= j; i++) P[i] = A[i];
         P += ldp--;
         A += lda;
      }
   }
   else /* if (uplo == PackLower) */
   {
      assert(uplo == PackLower);
      for (j=0; j < N; j++)
      {
         for (i=j; i < N; i++) P[i] = A[i-j];
         P += ldp--;
         A += lda;
      }
   }
}

void tp2ge(enum PACK_UPLO uplo, int M, int N, TYPE *P, int ldp, TYPE *A,int lda)
{
   int i, j;

   if (uplo == PackUpper)
   {
      for (j=0; j < N; j++)
      {
         for (i=0; i <= j; i++) A[i] = P[i];
         for (i=j+1; i < N; i++) A[i] = 0.0;
         P += ldp--;
         A += lda;
      }
   }
   else /* if (uplo == PackLower) */
   {
      assert(uplo == PackLower);
      for (j=0; j < N; j++)
      {
         for (i=0; i < j; i++) A[i] = 0.0;
         for (i=j; i < N; i++) A[i] = P[i-j];
         P += ldp--;
         A += lda;
      }
   }
}

void sp2ge(enum PACK_UPLO uplo, int M, int N, TYPE *P, int ldp, TYPE *A,int lda)
{
   int i, j;

   if (uplo == PackUpper)
   {
      for (j=0; j < N; j++)
      {
         for (i=0; i <= j; i++) A[j+i*lda] = A[i+j*lda] = P[i];
         P += ldp--;
      }
   }
   else /* if (uplo == PackLower) */
   {
      assert(uplo == PackLower);
      for (j=0; j < N; j++)
      {
         for (i=j; i < N; i++) A[j+i*lda] = A[i+j*lda] = P[i-j];
         P += ldp--;
      }
   }
}

static void gpgen(enum PACK_UPLO uplo, int M, int N, TYPE *P, int ldp)
{
   int ma, mi, m;
   void matgen(int M, int N, TYPE *A, int lda, int seed);

   if (uplo == PackGen) matgen(M, N, P, ldp, (M<<16)+N*ldp);
   else
   {
      mi = Mmin(M,N);
      ma = Mmax(M,N);
      m = ((mi * (mi+1))>>1) + (ma-mi) * mi;
      matgen(m, 1, P, m, (M<<16)+N*ldp);
   }
}

int checkC(enum PACK_UPLO uplo, int M, int N, int K, int I, int J,
           TYPE *P, int ldp, TYPE *C, int ldc, SCALAR alpha, SCALAR beta)
{
   int nerr=0, ii, jj, i, j=0;
   static TYPE feps=0.0;
   TYPE maxval, f1, ferr;

   if (feps == 0.0) feps = EPS;
   #ifdef TREAL
      ferr = 2.0 * (Mabs(alpha) * 2.0*K*feps + Mabs(beta) * feps) + feps;
   #else
      f1 = Mabs(*alpha) + Mabs(alpha[1]);
      maxval = Mabs(*beta) + Mabs(beta[1]);
      ferr = 2.0 * (f1*8.0*K*feps + maxval*feps) + feps;
   #endif
   M += I;
   N += J;
   if (uplo == PackGen)
   {
      for (j=0; j != N; j++)
      {
         if (j >= J)
         {
            for (i=0; i != M SHIFT; i++)
            {
               if (i >= I)
               {
                  f1 = P[i] - C[i];
                  if (f1 < 0.0) f1 = -f1;
                  if (f1 > ferr)
                  {
                     nerr++;
                     if (f1 > maxval)
                     {
                        maxval=f1;
                        ii = i+1;
                        jj = j+1;
                     }
                  }
               }
            }
         }
         P += ldp SHIFT;
         C += ldc SHIFT;
      }
   }
/*
 * These guys will not work for complex
 */
   else if (uplo == PackUpper)
   {
      for (j=0; j < N; j++, P += ldp SHIFT, C += ldc SHIFT)
      {
         if (j < J) continue;
         for (i=0; i <= j; i++)
         {
            if (i < I) continue;
            f1 = P[i] - C[i];
            if (f1 < 0.0) f1 = -f1;
            if (f1 > ferr)
            {
               nerr++;
               if (f1 > maxval)
               {
                  maxval=f1;
                  ii = i+1;
                  jj = j+1;
               }
            }
         }
      }
   }
   else
   {
      for (j=0; j < N; j++, P += ldp SHIFT, C += ldc SHIFT)
      {
         if (j < J) continue;
         for (i=j; i < N; j++)
         {
            if (i < I) continue;
            f1 = P[i-j] - C[i];
            if (f1 < 0.0) f1 = -f1;
            if (f1 > ferr)
            {
               nerr++;
               if (f1 > maxval)
               {
                  maxval=f1;
                  ii = i+1;
                  jj = j+1;
               }
            }
         }
      }
   }
   if (maxval != 0.0)
      fprintf(stderr, "ERROR: nerr=%d, i=%d, j=%d, maxval=%e\n",
              nerr, ii,jj, maxval);
   return(nerr);
}

int mmcase(int TEST, int CACHESIZE, char UA, char TA, char UB, char TB, char UC,
           int M, int N, int K, SCALAR alpha, int IA, int JA, int lda, 
           int IB, int JB, int ldb, SCALAR beta, 
           int IC, int JC, int ldc)
{
   char *pc;
#ifdef TREAL
   char *form="%5d %c  %c  %c  %c  %c %4d %4d %4d %5.1f %4d %4d %4d %4d %4d %4d %5.1f %4d %4d %4d %6.2f %6.1f %4.2f  %3s\n";
   #define MALPH alpha
   #define MBETA beta
#else
   #define MALPH *alpha, alpha[1]
   #define MBETA *beta, beta[1]
   char *form="%5d %c  %c  %c  %c  %c %4d %4d %4d %5.1f %5.1f %4d %4d %4d %4d %4d %4d %5.1f %5.1f %4d %4d %4d %6.2f %6.1f %4.2f  %3s\n";
#endif
   int ii, jj, i, j=0, PASSED=1, nerrs;
   double t0, t1, t2, t3, mflop;
   static TYPE feps=0.0;
   static int itst=1;
   /*int *L2, nL2=(1.3*L2SIZE)/sizeof(int);*/
   enum ATLAS_TRANS TAe, TBe;
   enum PACK_UPLO UAe, UBe, UCe;
   double l2ret;
   TYPE *A, *B, *C, *pA, *pB, *pC;

fprintf(stderr, "M=%d, N=%d, K=%d, IA=%d, JA=%d, lda=%d, IB=%d, JB=%d, ldb=%d IC
=%d, JC=%d, ldc=%d\n",
        M, N, K, IA, JA, lda, IB, JB, ldb, IC, JC, ldc);

   if (UA == 'u' || UA == 'U') UAe = PackUpper;
   else if (UA == 'l' || UA == 'L') UAe = PackLower;
   else UA = PackGen;
   if (UB == 'u' || UB == 'U') UBe = PackUpper;
   else if (UB == 'l' || UB == 'L') UBe = PackLower;
   else UB = PackGen;
   if (UC == 'u' || UC == 'U') UCe = PackUpper;
   else if (UC == 'l' || UC == 'L') UCe = PackLower;
   else UC = PackGen;

   if (TA == 'n' || TA == 'N') TAe = AtlasNoTrans;
   else TAe = AtlasTrans;
   if (TB == 'n' || TB == 'N') TBe = AtlasNoTrans;
   else TBe = AtlasTrans;

/*
 * See if case needs to be skipped
 */
   if (TAe == PackNoTrans || TAe == AtlasConj)
   {
      if (IA+M <= lda && JA+K <= lda && IA >=0 && JA >= 0) return(-1);
      if (UAe == PackUpper) { if (JA+K <= lda && IA+M <= JA) return(-1); }
      else if (UAe == PackLower) { if (JA+M <= lda && IA+K <= JA) return(-1); }
   }
   else
   {
      if (IA+K <= lda && JA+M <= lda && IA >=0 && JA >= 0) return(-1);
      if (UAe == PackUpper) { if(IA >= JA+K && IA+M <= lda) return(-1); }
      else if (UAe == PackLower) { if (IA >= JA+M && IA+K <= lda) return(-1); }
   }

   if (TBe == PackNoTrans || TBe == AtlasConj)
   {
      if (IB+K <= ldb && JB+N <= ldb && IB >=0 && JB >= 0) return(-1);
      if (UBe == PackUpper) { if (JB+N <= lda && IB+N <= JB) return(-1); }
      else if (UBe == PackLower) { if (IB >= JB+N && IB+K <= ldb) return(-1); }
   }
   else
   {
      if (IB+K <= ldb && JB+M <= ldb && IB >=0 && JB >= 0) return(-1);
      if (UBe == PackUpper) { if (JB+K <= ldb && IB+N <= JB) return(-1); }
      else if (UBe == PackLower) { if (IB >= JB+K && IB+N <= ldb) return(-1); }
   }

   l2ret = ATL_flushcache( CACHESIZE );
   A = malloc(lda*lda*ATL_sizeof);
   assert(A);
   B = malloc(ldb*ldb*ATL_sizeof);
   assert(B);
   C = malloc(ldc*ldc*ATL_sizeof);
   assert(C);

   if (UAe == PackGen)
   {
      pA = A;
      matgen(lda, lda, A, lda, K*1112);
   }
   else
   {
      pA = malloc( ((lda * (lda+1))>>1)*ATL_sizeof );
      assert(pA);
      gpgen(UAe, lda, lda, pA, lda);
      tp2ge(UAe, lda, lda, pA, lda, A, lda);
   }

   if (UBe == PackGen)
   {
      pB = B;
      matgen(lda, lda, B, ldb, N*2238);
   }
   else
   {
      pB = malloc( ((ldb * (ldb+1))>>1)*ATL_sizeof );
      assert(pB);
      gpgen(UBe, ldb, ldb, pB, ldb);
      tp2ge(UBe, ldb, ldb, pB, ldb, B, ldb);
   }
   if (UCe == PackGen)
   {
      matgen(ldc, ldc, C, ldc, M*N);
      pC = malloc(ldc*ldc*ATL_sizeof);
      assert(pC);
      matgen(ldc, ldc, C, ldc, M*N);
   }
   else
   {
      pC = malloc( ((ldc * (ldc+1))>>1)*ATL_sizeof );
      assert(pC);
      gpgen(UCe, ldc, ldc, pC, ldc);
      tp2ge(UCe, ldc, ldc, pC, ldc, C, ldc);
   }

   l2ret = ATL_flushcache( -1 );

   t0 = time00();
   trusted_gemm(TAe, TBe, M, N, K, alpha, A+IA+JA*lda, lda, B+IB+JB*ldb, ldb,
                beta, C+IC+JC*ldc, ldc);
   t1 = time00() - t0;
   if (t1 <= 0.0) mflop = t1 = 0.0;
   else   /* flop rates actually 8MNK+12MN & 2MNK + 2MN, resp */
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t1*1000000.0);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t1*1000000.0);
      #endif
   if (TEST != -99)
      printf(form, itst, 'G', TA, 'G', TB, 'G', M, N, K, MALPH, IA, JA, lda, 
             IB, JB, ldb, MBETA, IC, JC, ldc, t1, mflop, 1.0, "---");

   /* invalidate L2 cache */
   l2ret = ATL_flushcache( -1 );

   t0 = time00();
   test_gpmm(UAe, TAe, UBe, TBe, UCe, M, N, K, alpha, A, IA, JA, lda,
             B, IB, JB, ldb, beta, C, IC, JC, ldc);
   t2 = time00() - t0;
   if (t2 <= 0.0) t2 = mflop = 0.0;
   else 
      #ifdef TCPLX
         mflop = ( ((8.0*M)*N)*K ) / (t2*1000000.0);
      #else
         mflop = ( ((2.0*M)*N)*K ) / (t2*1000000.0);
      #endif

   if (TEST && TEST != -99)
   {
      nerrs = checkC(UC, M, N, K, IC, JC, pC, ldc, C, ldc, alpha, beta);
      if (nerrs)
      {
         pc = "NO!";
         PASSED = 0;
      }
      else pc = "YES";
   }
   else pc = "---";
   if (t1 == t2) t3 = 1.0;
   else if (t2 != 0.0) t3 = t1/t2;
   else t3 = 0.0;
   if (TEST != -99)
      printf(form, itst++, UA, TA, UB, TB, UC, M, N, K, MALPH, IA, JA, lda, 
             IB, JB, ldb, MBETA, IC, JC, ldc, t2, mflop, t3, pc);
   l2ret = ATL_flushcache( 0 );
   return(PASSED);
}

void PrintUsage(char *name)
{
   fprintf(stderr, "USAGE: %s \n", name);
   fprintf(stderr, 
           "   -UA <nuplo> L/U/G -UB <nuplo> L/U/G -UC <nuplo> L/U/G \n");
   fprintf(stderr, "   -Atrans <ntrans> n/t/c -Btrans <ntrans> n/t/c \n");
   fprintf(stderr, "   -Diag <ndiags> N/U \n");
   fprintf(stderr, 
           "   -M <m1> <mN> <minc> -N <n1> <nN> <ninc> <k1> <kN> <kinc> \n");
   fprintf(stderr, "   -n <n> -m <m> -k <k> \n");
   fprintf(stderr, "   -ia <i> -ja <j> -ib <i> -jb <j> -ic <i> -jc <j>\n");
   fprintf(stderr, 
           "   -I[A,B,C] <i1> <iN> <iinc> -J[A,B,C] <j1> <jN> <jinc>\n");
   fprintf(stderr, 
   "   -a <nalphas> <alpha1> ... <alphaN> -b <nbetas> <beta1> ... <betaN>\n");
   fprintf(stderr, "   -Test <0/1> -F <mflops> -C <cachesize>\n");
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *TEST,
              int *nua, enum PACK_UPLO **UAS, int *nub, enum PACK_UPLO **UBS, 
              int *nuc, enum PACK_UPLO **UCS,
              int *nta, enum ATLAS_TRANS **TransA, 
              int *ntb, enum ATLAS_TRANS **TransB, int *ndiag,
              enum ATLAS_DIAG **Diag, int *M0, int *MN, int *Minc, 
              int *N0, int *NN, int *Ninc, int *K0, int *KN, int *Kinc,
              int *IA0, int *IAN, int *IAINC, int *JA0, int *JAN, int *JAINC,
              int *IB0, int *IBN, int *IBINC, int *JB0, int *JBN, int *JBINC,
              int *IC0, int *ICN, int *ICINC, int *JC0, int *JCN, int *JCINC,
              int *nalphas, TYPE **alphas, int *nbetas, TYPE **betas,
              int *LDA_IS_M, int *MFLOP, int *CACHESIZE)

{
   char ch;
   int i, j;
   int *ni, **is;
   int *nuplo;
   enum PACK_UPLO **Uplo;
/*
 * Set up defaults
 */
   *TEST = 1;
   *IA0 = *JA0 = *IB0 = *JB0 = *IC0 = *JC0 = 0;
   *IAN = *JAN = *IBN = *JBN = *ICN = *JCN = 0;
   *IAINC = *JAINC = *IBINC = *JBINC = *ICINC = *JCINC = 1;
   *M0 = *N0 = *K0 = -1;
   *nuc = *nub = *nua = *nta = *ntb = *ndiag = *nalphas = *nbetas = -1;
   *MFLOP = *LDA_IS_M = 0;
   #ifdef L2SIZE
      *CACHESIZE = L2SIZE;               /* Size of largest cache to flush */
   #else
      *CACHESIZE = 4*1024*1024;
   #endif

   for (i=1; i < nargs; i++)
   {
      switch(args[i][1])
      {
      case 'F':
         *MFLOP = atoi(args[++i]);
         break;
      case 'C':
            if( args[i+1] == NULL ) PrintUsage( args[0] );
	    *CACHESIZE = 1024*atoi(args[++i]);
            break;
      case 'U':
         if (args[i][2] == 'A')
         {
            nuplo = nua;
            Uplo = UAS;
         }
         else if (args[i][2] == 'B')
         {
            nuplo = nub;
            Uplo = UBS;
         }
         else
         {
            nuplo = nuc;
            Uplo = UCS;
         }
         *nuplo = atoi(args[++i]);
         *Uplo = malloc(*nuplo * sizeof(int));
         assert(*Uplo);
         for (j=0; j != *nuplo; j++)
         {
            ch = *args[++i];
            if (ch == 'u' || ch == 'U') (*Uplo)[j] = PackUpper;
            else if (ch == 'l' || ch == 'L') (*Uplo)[j] = PackLower;
            else  (*Uplo)[j] = PackGen;
         }
         break;
      case 'D':
         *ndiag = atoi(args[++i]);
         *Diag = malloc(*ndiag * sizeof(int));
         assert(*Diag);
         for (j=0; j != *ndiag; j++)
         {
            ch = *args[++i];
            if (ch == 'u' || ch == 'U') (*Diag)[j] = AtlasUnit;
            else if (ch == 'n' || ch == 'N') (*Diag)[j] = AtlasNonUnit;
            else PrintUsage(args[0]);
         }
         break;
      case 'A':
         *nta   = atoi(args[++i]);
         *TransA = malloc(*nta * sizeof(int));
         assert(*TransA);
         for (j=0; j != *nta; j++)
         {
            ch = *args[++i];
            if (ch == 'n' || ch == 'N') (*TransA)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransA)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransA)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'B':
         *ntb   = atoi(args[++i]);
         *TransB = malloc(*ntb * sizeof(int));
         assert(*TransB);
         for (j=0; j != *ntb; j++)
         {
            ch = *args[++i];
            if (ch == 'n' || ch == 'N') (*TransB)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransB)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransB)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'I':
         switch(args[i][2])
         {
         case 'a':
         case 'A':
            *IA0 =  atoi(args[++i]);
            *IAN =  atoi(args[++i]);
            *IAINC = atoi(args[++i]);
            break;
         case 'b':
         case 'B':
            *IB0 =  atoi(args[++i]);
            *IBN =  atoi(args[++i]);
            *IBINC = atoi(args[++i]);
            break;
         case 'c':
         case 'C':
            *IC0 =  atoi(args[++i]);
            *ICN =  atoi(args[++i]);
            *ICINC = atoi(args[++i]);
            break;
         default:
            PrintUsage(args[0]);
         }
         break;
      case 'J':
         switch(args[i][2])
         {
         case 'a':
         case 'A':
            *JA0 =  atoi(args[++i]);
            *JAN =  atoi(args[++i]);
            *JAINC = atoi(args[++i]);
            break;
         case 'b':
         case 'B':
            *JB0 =  atoi(args[++i]);
            *JBN =  atoi(args[++i]);
            *JBINC = atoi(args[++i]);
            break;
         case 'c':
         case 'C':
            *JC0 =  atoi(args[++i]);
            *JCN =  atoi(args[++i]);
            *JCINC = atoi(args[++i]);
            break;
         default:
            PrintUsage(args[0]);
         }
         break;
      case 'M':
         *M0 = atoi(args[++i]);
         *MN = atoi(args[++i]);
         *Minc = atoi(args[++i]);
         break;
      case 'N':
         *N0 = atoi(args[++i]);
         *NN = atoi(args[++i]);
         *Ninc = atoi(args[++i]);
         break;
      case 'K':
         *K0 = atoi(args[++i]);
         *KN = atoi(args[++i]);
         *Kinc = atoi(args[++i]);
         break;
      case 'T':
         *TEST = atoi(args[++i]);
         break;
      case 'i':
         switch(args[i][2])
         {
         case 'a':
         case 'A':
            *IA0 = *IAN = *IAINC = atoi(args[++i]);
            break;
         case 'b':
         case 'B':
            *IB0 = *IBN = *IBINC = atoi(args[++i]);
            break;
         case 'c':
         case 'C':
            *IC0 = *ICN = *ICINC = atoi(args[++i]);
            break;
         }
         break;
      case 'j':
         switch(args[i][2])
         {
         case 'a':
         case 'A':
            *JA0 = *JAN = *JAINC = atoi(args[++i]);
            break;
         case 'b':
         case 'B':
            *JB0 = *JBN = *JBINC = atoi(args[++i]);
            break;
         case 'c':
         case 'C':
            *JC0 = *JCN = *JCINC = atoi(args[++i]);
            break;
         }
         break;
      case 'm':
         *M0 = *MN = *Minc = atoi(args[++i]);
         break;
      case 'n':
         *N0 = *NN = *Ninc = atoi(args[++i]);
         break;
      case 'k':
         *K0 = *KN = *Kinc = atoi(args[++i]);
         break;
      case 'a':
         *nalphas = atoi(args[++i]);
         *alphas = malloc(ATL_MulBySize(*nalphas));
         assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++) (*alphas)[j] = atof(args[++i]);
         break;
      case 'b':
         *nbetas  = atoi(args[++i]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++) (*betas)[j] = atof(args[++i]);
         break;
      case 'd':
         *LDA_IS_M  = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
         break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if (*N0 == -1)
   {
      *N0 = 100;
      *NN = 1000;
      *Ninc = 100;
   }
   if (*nua == -1)
   {
      *nua = 1;
      *UAS = malloc(sizeof(int));
      assert(*UAS);
      **UAS = PackGen;
   }
   if (*nub == -1)
   {
      *nub = 1;
      *UBS = malloc(sizeof(int));
      assert(*UBS);
      **UBS = PackGen;
   }
   if (*nuc == -1)
   {
      *nuc = 1;
      *UCS = malloc(sizeof(int));
      assert(*UCS);
      **UCS = PackGen;
   }
   if (*nta == -1)
   {
      *nta = 1;
      *TransA = malloc(sizeof(int));
      assert(*TransA);
      **TransA = AtlasNoTrans;
   }
   if (*ntb == -1)
   {
      *ntb = 1;
      *TransB = malloc(sizeof(int));
      assert(*TransB);
      **TransB = AtlasNoTrans;
   }
   if (*ndiag == -1)
   {
      *ndiag = 1;
      *Diag = malloc(sizeof(int));
      assert(*Diag);
      **Diag = AtlasNonUnit;
   }
   if (*nalphas == -1)
   {
      *nalphas = 1;
      *alphas = malloc(ATL_MulBySize(1));
      assert(*alphas);
      #ifdef TREAL
         **alphas = 1.0;
      #else
         **alphas = 1.0;
         (*alphas)[1] = 0.0;
      #endif
   }
   if (*nbetas  == -1)
   {
      *nbetas  = 1;
      *betas  = malloc(ATL_MulBySize(1));
      assert(*betas );
      #ifdef TREAL
         **betas  = 1.0;
      #else
         **betas  = 1.0;
         (*betas)[1] = 0.0;
      #endif
   }
}
___main(){}
__main(){}
MAIN__(){}
_MAIN_(){}
main(int nargs, char *args[])
/*
 *  tst <tst> <# TA> <TA's> <# TB's> <TB's> <M0> <MN> <incM> <N0> <NN> <incN>
 *      <K0> <KN> <incK> <# alphas> <alphas> <# betas> <betas>
 *          
 */
{
   int IA0, IAN, IAinc, IB0, IBN, IBinc, IC0, ICN, ICinc;
   int JA0, JAN, JAinc, JB0, JBN, JBinc, JC0, JCN, JCinc;
   int M0, MN, incM, N0, NN, incN, K0, KN, incK, lda, ldb, ldc, MFLOP; 
   int i, k, m, n, im, in, ik, ita, itb, ia, ib, nTA, nTB, nalph, nbeta;
   int iua, iub, iuc, iia, iib, iic, ija, ijb, ijc;
   int itst=0, ipass=0, iskip=0, itmp, TEST, LDA_IS_M, MSAME=0, KSAME=0;
   int ndiag, nua, nub, nuc;
   TYPE *alph, *beta, *A, *B, *C, *D=NULL;
   #ifdef TREAL
      TYPE bet1 = 1.0, alp1 = -1.0;
   #else
      TYPE bet1[2] = {1.0, 0.0}, alp1[2] = {-1.0, 0.0};
   #endif
   char TA, TB, UA, UB, UC;
   enum ATLAS_SIDE *Side; 
   enum PACK_UPLO *UAs, *UBs, *UCs;
   enum ATLAS_TRANS *TransA, *TransB, TAc, TBc;
   enum ATLAS_DIAG *Diag;
   int CACHESIZE;

   GetFlags(nargs, args, &TEST, &nua, &UAs, &nub, &UBs, &nuc, &UCs, 
            &nTA, &TransA, &nTB, &TransB, &ndiag, &Diag, 
            &M0, &MN, &incM, &N0, &NN, &incN, &K0, &KN, &incK,
            &IA0, &IAN, &IAinc, &JA0, &JAN, &JAinc, 
            &IB0, &IBN, &IBinc, &JB0, &JBN, &JBinc, 
            &IC0, &ICN, &ICinc, &JC0, &JCN, &JCinc, 
            &nalph, &alph, &nbeta, &beta, &LDA_IS_M, &MFLOP,&CACHESIZE);

   if (M0 == -1)
   {
      MSAME = 1;
      M0 = MN = incM = NN;
   }
   if (K0 == -1)
   {
      KSAME = 1;
      K0 = KN = incK = NN;
   }

/*
 * Page in routs so first timing is more reliable
 */
   mmcase(-99, CACHESIZE, 'U', 'N', 'U', 'N', 'U', 100, 100, 100, 2.0, 
          0, 100, 200, 0, 100, 200, 2.0, 0, 100, 200);

#ifdef TREAL
   printf(
"\nTEST# UA TA UB TB UC    M    N    K ALPHA   IA   JA  LDA   IB   JB  LDB  BETA   IC   JC  LDC   TIME  MFLOP SpUp PASS\n");
   printf(
  "===== == == == == == ==== ==== ==== ===== ==== ==== ==== ==== ==== ==== ===== ==== ==== ==== ====== ====== ==== ====\n");
#else
   printf(
"\nTEST# UA TA UB TB UC    M    N    K    ALPHA      IA   JA  LDA   IB   JB  LDB     BETA      IC   JC  LDC   TIME  MFLOP SpUp PASS\n");
   printf(
"===== == == == == == ==== ==== ==== ===== ===== ==== ==== ==== ==== ==== ==== ===== ===== ==== ==== ==== ====== ====== ==== ====\n");
#endif
   for (iua=0; iua != nua; iua++)
   {
      if (UAs[iua] == PackUpper) UA = 'U';
      else if (UAs[iua] == PackLower) UA = 'L';
      else UA = 'G';
   for (iub=0; iub != nub; iub++)
   {
      if (UBs[iub] == PackUpper) UB = 'U';
      else if (UBs[iub] == PackLower) UB = 'L';
      else UB = 'G';
   for (iuc=0; iuc != nuc; iuc++)
   {
      if (UCs[iuc] == PackUpper) UC = 'U';
      else if (UCs[iuc] == PackLower) UC = 'L';
      else UC = 'G';
   for (im=M0; im <= MN; im += incM)
   {
      for (n=N0; n <= NN; n += incN)
      {
         if (MSAME) m = n;
         else m = im;
         for (ik=K0; ik <= KN; ik += incK)
         {
            if (KSAME) k = n;
            else k = ik;
            for (iia=IA0; iia <= IAN; iia += IAinc)
            {
            for (ija=JA0; ija <= JAN; ija += JAinc)
            {
            for (iib=IB0; iib <= IBN; iib += IBinc)
            {
            for (ijb=JB0; ijb <= JBN; ijb += JBinc)
            {
            for (iic=IC0; iic <= ICN; iic += IBinc)
            {
            for (ijc=JC0; ijc <= JCN; ijc += JBinc)
            {
            for (ita=0; ita != nTA; ita++)
            {
               if (TransA[ita] == AtlasNoTrans) TA = 'N';
               else if (TransA[ita] == AtlasTrans) TA = 'T';
               else if (TransA[ita] == AtlasConjTrans) TA = 'C';

               for (itb=0; itb != nTB; itb++)
               {
                  if (TransB[itb] == AtlasNoTrans) TB = 'N';
                  else if (TransB[itb] == AtlasTrans) TB = 'T';
                  else if (TransB[itb] == AtlasConjTrans) TB = 'C';
                  for (ia=0; ia != nalph; ia++)
                  {
                     for (ib=0; ib != nbeta; ib++)
                     {
                        itst++;
                        if (LDA_IS_M)
                        {
                           if (TA == 'n' || TA == 'N') lda = m;
                           else lda = k;
                           if (TB == 'n' || TB == 'N') ldb = k;
                           else ldb = n;
                           ldc = m;
                        }
                        else
                        {
                           if (TA == 'n' || TA == 'N') lda = MN;
                           else lda = KN;
                           if (TB == 'n' || TB == 'N') ldb = KN;
                           else ldb = NN;
                           ldc = MN;
                        }
                        lda += iia;
                        ldb += iib;
                        ldc += iic;
                        
                        #ifdef TREAL
                           itmp = mmcase(TEST, CACHESIZE, UA, TA, UB, TB, UC,
                                         m, n, k, alph[ia], iia, ija, lda, 
                                         iib, ijb, ldb, beta[ib], 
                                         iic, ijc, ldc);
                        #else
                           itmp = mmcase(TEST, CACHESIZE, UA, TA, UB, TB, UC,
                                         m, n, k, alph+(ia SHIFT), iia, ija,
                                         lda, iib, ijb, ldb, beta+(ib SHIFT),
                                         iic, ijc, ldc);
                        #endif
                        if (itmp == -1) iskip++;
                        else if (itmp) ipass++;
                        }
                     }
                  }
               }
            }
            }
            }
            }
            }
            }
         }
      }
   }
   }
   }
   }
   if (TEST)
      printf("\nNTEST=%d, NUMBER PASSED=%d, NUMBER SKIPPED=%d, NUMBER FAILURES=%d\n",
             itst, ipass, iskip, itst-ipass-iskip);
   else printf("\nDone with %d timing runs\n",itst);
   free(UAs);
   free(UBs);
   free(UCs);
   free(TransA);
   free(TransB);
   free(Diag);
   free(alph);
   free(beta);
   exit(0);
}
@ROUT ATL_cpmmJIK
int Mjoin(PATL,pmmJIK)
   (const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
    const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
    const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const SCALAR beta, const enum PACK_UPLO UC, TYPE *C, const int ldc)
{
   ATL_xerbla(0, __FILE__, "This routine not yet implemented\n");
   return(-1);
}

int Mjoin(PATL,pmmJIKF)
   (const enum PACK_UPLO UA, const enum ATLAS_TRANS TA,
    const enum PACK_UPLO UB, const enum ATLAS_TRANS TB,
    const int M, const int N, const int K, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *B, const int ldb,
    const SCALAR beta, const enum PACK_UPLO UC, TYPE *C, const int ldc)
{
   ATL_xerbla(0, __FILE__, "This routine not yet implemented\n");
   return(-1);
}
