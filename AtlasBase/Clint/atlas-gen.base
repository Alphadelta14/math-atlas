@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@extract -b @(topd)/gen.inc what=crsetup
@ROUT r1gen_sse
@extract -b @(topd)/gen.inc what=cw @(cw09)
@ROUT ! emit_mm r1gen_sse GetMul extract
@extract -b @(topd)/gen.inc what=cw @(cw00)
@ROUT emit_mm
@extract -b @(topd)/gen.inc what=cw @(cw99)
@ROUT !

@ROUT emit_mm emit_rmvT emit_head emit_r1h

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
@ROUT emit_r1h emit_head `#include "atlas_type.h"`

#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )
#define Mmin(x, y) ( (x) > (y) ? (y) : (x) )
#define Mmax(x, y) ( (x) > (y) ? (x) : (y) )
@ROUT emit_head
#define ATL_MVIsMM(iflag_) ( ((iflag_) | 8) == (iflag_) )
#define ATL_MVIsAxpy(iflag_) ( ((iflag_) | 16) == (iflag_) )
#define ATL_MVIsDot(iflag_) ( !ATL_MVIsMM(iflag_) && !ATL_MVIsAxpy(iflag_) )
#define ATL_MVNoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )
@ROUT emit_r1h
#define ATL_NoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )
@ROUT emit_mm
#define ATL_Mlcm(x_, y_, ans_) \
{ \
   if ((x_) >= (y_)) \
   { \
      (ans_) = (x_); \
      while( ((ans_)/(y_))*(y_) != (ans_) ) (ans_) += (x_); \
   } \
   else \
   { \
      (ans_) = (y_); \
      while( ((ans_)/(x_))*(x_) != (ans_) ) (ans_) += (y_); \
   } \
}

char PRE='d';
char *TYPE="double";
int MUL=1;

enum ATLAS_LOOP_ORDER {AtlasIJK=0, AtlasJIK=1};
enum ATLAS_TRANS {AtlasNoTrans=111, AtlasTrans=112, AtlasConjTrans=113};
typedef void (*KLOOPFUNC)(FILE *, char*, enum ATLAS_LOOP_ORDER, 
                          enum ATLAS_TRANS, enum ATLAS_TRANS, int, int, int, 
                          int, int, int, char*, char*, char*, char*, char*, 
                          int, int, int, int, int, int, int, int, int, 
                          char*, char*);
#define SAFE_ALPHA -3
@ROUT emit_mm emit_rmvT GetMul
int GetPower2(int n)
{
   int pwr2, i;

   if (n == 1) return(0);
   for (pwr2=0, i=1; i < n; i <<= 1, pwr2++);
   if (i != n) pwr2 = 0;
   return(pwr2);
}

#define ShiftThresh 2
char *GetDiv(int N, char *inc)
/*
 * Given a runtime variable whose name is in the string inc that you want
 * to divide by the compile-time constant N, produces the appropriate shift
 * (N is power of 2) or division (N not a power of 2).
 */
{
   static char ln[256];
   int pwr2 = GetPower2(N);
   if (N == 1) sprintf(ln, "%s", inc);
   else if (pwr2) sprintf(ln, "((%s) >> %d)", inc, pwr2);
   else sprintf(ln, "((%s) / %d)", inc, N);
   return(ln);
}

@ROUT GetMul `char *GetMul(int N, char *inc)`
@ROUT emit_mm emit_rmvT `char *GetInc(int N, char *inc)`
/*
 * let inc be a runtime variable that you wish to multiply by the 
 * compile-time constant N.  This routine attempts to use at most
 * ShiftThresh shifts and adds instead of using a multiply.  If more
 * than ShiftThresh adds are required, just uses multiply as normal.
 */
{
   static char ln0[256];
   char ln[256];
   char *p=ln;
   int i, n=N, iPLUS=0;

   if (n == 0)
   {
      ln[0] = '0';
      ln[1] = '\0';
   }
   while(n > 1)
   {
      for (i=0; n >= (1<<i); i++);
      if ( (1 << i) > n) i--;
      if (iPLUS++) *p++ = '+';
@skip      p += sprintf(p, "(%s << %d)", inc, i);
      sprintf(p, "((%s) << %d)", inc, i);
      p += strlen(p);
      n -= (1 << i);
   }
   if (n == 1)
   {
      if (iPLUS++) *p++ = '+';
      sprintf(p, "%s", inc);
   }
   if (iPLUS > ShiftThresh) sprintf(ln0, "(%d*(%s))", N, inc);
   else if (iPLUS) sprintf(ln0, "(%s)", ln);
   else sprintf(ln0, "%s", ln);
   return(ln0);
}

@ROUT emit_mm
void emit_uhead(FILE *fp, char pre, int mb, int nb, int kb, int beta)
{
   char cbet;

   if (beta == 1) cbet = '1';
   else if (beta == 0) cbet = '0';
   else cbet = 'X';

   fprintf(fp, "#define ATL_USERMM ATL_%cJIK%dx%dx%dTN%dx%dx0_a1_b%c\n",
           pre, mb, nb, kb, kb, kb, cbet);
   fprintf(fp, "#define ATL_USERMM_b1 ATL_%cJIK%dx%dx%dTN%dx%dx0_a1_b1\n",
           pre, mb, nb, kb, kb, kb);
   fprintf(fp, "#define ATL_USERMM_b0 ATL_%cJIK%dx%dx%dTN%dx%dx0_a1_b0\n",
           pre, mb, nb, kb, kb, kb);
   fprintf(fp, "#define ATL_USERMM_bX ATL_%cJIK%dx%dx%dTN%dx%dx0_a1_bX\n",
           pre, mb, nb, kb, kb, kb);
   fprintf(fp, "#define BETA%c\n", cbet);
   if (pre == 's') fprintf(fp, "#define SREAL\n");
   else if (pre == 'd') fprintf(fp, "#define DREAL\n");
   else if (pre == 'c') fprintf(fp, "#define SCPLX\n");
   else if (pre == 'z') fprintf(fp, "#define DCPLX\n");
   fprintf(fp, "\n#define MB %d\n#define NB %d\n#define KB %d\n", mb, nb, kb);
   fprintf(fp, "\n#define MB2 %d\n#define NB2 %d\n#define KB2 %d\n\n", 
           2*mb, 2*nb, 2*kb);
}

void emit_head(int NC, FILE *fpout, char pre, int nb, int muladd, int lat,
               int mu, int nu, int ku)
{
   int i, pow2nb;
   char nam[128];
   char upr;
   
   fprintf(fpout, "#ifndef %cMM_H\n", toupper(pre));
   fprintf(fpout, "   #define %cMM_H\n\n", toupper(pre));
   if (muladd) fprintf(fpout, "   #define ATL_mmMULADD\n");
   else fprintf(fpout, "   #define ATL_mmNOMULADD\n");
   fprintf(fpout, "   #define ATL_mmLAT %d\n", lat);
   fprintf(fpout, "   #define ATL_mmMU  %d\n", mu);
   fprintf(fpout, "   #define ATL_mmNU  %d\n", nu);
   fprintf(fpout, "   #define ATL_mmKU  %d\n", ku);
   fprintf(fpout, "   #define MB %d\n", nb);
   fprintf(fpout, "   #define NB %d\n", nb);
   fprintf(fpout, "   #define KB %d\n", nb);
   fprintf(fpout, "   #define NBNB %d\n", nb*nb);
   fprintf(fpout, "   #define MBNB %d\n", nb*nb);
   fprintf(fpout, "   #define MBKB %d\n", nb*nb);
   fprintf(fpout, "   #define NBKB %d\n", nb*nb);
   fprintf(fpout, "   #define NB2 %d\n", 2*nb);
   fprintf(fpout, "   #define NBNB2 %d\n\n", 2*nb*nb);

   for (i=1,pow2nb=0; i < nb; i <<= 1, pow2nb++);
   if (i == nb)
   {
      fprintf(fpout, "   #define ATL_MulByNB(N_) ((N_) << %d)\n", pow2nb);
      fprintf(fpout, "   #define ATL_DivByNB(N_) ((N_) >> %d)\n", pow2nb);
      fprintf(fpout, "   #define ATL_MulByNBNB(N_) ((N_) << %d)\n", 2*pow2nb);
   }
   else 
   {
      fprintf(fpout, "   #define ATL_MulByNB(N_) ((N_) * %d)\n", nb);
      for (i=1; (nb / (1 << i))*(i << i) == nb; i++); 
                 
      if (i == 1) fprintf(fpout,"   #define ATL_DivByNB(N_) ((N_) / %d)\n", nb);
      else fprintf(fpout, "   #define ATL_DivByNB(N_) ( ((N_) >> %d)/%d )\n",
                   i, (nb / (1 << i)));
      fprintf(fpout, "   #define ATL_MulByNBNB(N_) ((N_) * %d)\n", nb*nb);
   }
   if (!NC)
   {
      sprintf(nam, "ATL_%cJIK%dx%dx%dTN%dx%dx%d", pre, nb, nb, nb, nb, nb, 0);
      if (pre == 'd' || pre == 's')
      {
         fprintf(fpout, "   #define NBmm %s_a1_b1\n", nam);
         fprintf(fpout, "   #define NBmm_b1 %s_a1_b1\n", nam);
         fprintf(fpout, "   #define NBmm_b0 %s_a1_b0\n", nam);
         fprintf(fpout, "   #define NBmm_bX %s_a1_bX\n", nam);
      }
      else
      {
   
         fprintf(fpout, "void %s_a1_b0(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n", nam);
         fprintf(fpout, "void %s_a1_b1(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n", nam);
         fprintf(fpout, "void %s_a1_bX(const int M, const int N, const int K, const TYPE alpha, const TYPE *A, const int lda, const TYPE *B, const int ldb, const TYPE beta, TYPE *C, const int ldc);\n\n", nam);

         fprintf(fpout, "   #define NBmm_b1(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
            fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
            fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         fprintf(fpout, "   #define NBmm_b0(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
         fprintf(fpout, "   %s_a1_b0(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, ATL_rzero, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b0(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, ATL_rzero, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         fprintf(fpout, "   #define NBmm_bX(m_, n_, k_, al_, A_, lda_, B_, ldb_, be_, C_, ldc_) \\\n");
         fprintf(fpout, "{ \\\n");
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_), ldb_, -(be_), C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_), lda_, (B_)+NBNB, ldb_, be_, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_bX(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_)+NBNB, ldb_, ATL_rnone, C_, ldc_); \\\n", nam);
         fprintf(fpout, "   %s_a1_b1(m_, n_, k_, al_, (A_)+NBNB, lda_, (B_), ldb_, ATL_rone, (C_)+1, ldc_); \\\n", nam);
         fprintf(fpout, "   }\n");

         if (pre == 'z') upr = 'd';
         else upr = 's';
         sprintf(nam, "ATL_%cJIK%dx%dx%dTN%dx%dx%d", upr, nb, nb, nb, nb, nb,0);
         fprintf(fpout, "   #define rNBmm_b1 %s_a1_b1\n", nam);
         fprintf(fpout, "   #define rNBmm_b0 %s_a1_b0\n", nam);
         fprintf(fpout, "   #define rNBmm_bX %s_a1_bX\n", nam);
      }
   }

   fprintf(fpout, "\n#endif\n");
}

int GetGoodLat(int muladd, int mu, int nu, int ku, int lat)
{
   int mul=mu*nu*ku, slat, blat;
   if (muladd) return(lat);
   for(slat=lat; mul % slat; slat--);
   for(blat=lat; mul % blat && blat < mul; blat++);
   if (blat-lat > lat-slat || mul%blat) return(slat);
   else return(blat);
}

void opfetch(FILE *fpout,          /* where to print */
             char *spc,            /* indentation string */
             int ifetch, /* number of elts to fetch from memory into regs */
             char *rA,  /* name for register holding elt of inner matrix */
             char *rB,  /* name for register holding elt of outer matrix */
             char *pA,  /* name for pointer to elt of inner matrix */
             char *pB,  /* name for pointer to elt of outer matrix */
             int mu,    /* register blocking for inner matrix */
             int nu,    /* register blocking for outer matrix */
             int offA,  /* offset to first elt of this block of inner matrix */
             int offB,  /* offset to first elt of this block of outer matrix */
             int lda,   /* row stride; if 0, row stride is arbitrary */
             int ldb,   /* row stride; if 0, row stride is arbitrary */
             int mulA,  /* col stride; 1: real, 2: cplx */
             int mulB,  /* col stride; 1: real, 2: cplx */
             int rowA,  /* if 0 : fetch within column, else fetch within row */
             int rowB,  /* if 0 : fetch within column, else fetch within row */
             int *ia0,  /* elt of inner matrix to be fetched */
             int *ib0)  /* elt of inner matrix to be fetched */
/*
 * This routine is used to generate memory-to-register fetches
 * A is inner matrix, fetched first;  B is outer matrix, fetched last
 * Assumes each matrix has either a pointer for each column of accessed, labeled
 * <pA><col#>, or the number of rows is a constant (ldx), and only one pointer,
 * <pA>0.
 */
{
   int ia = *ia0, ib = *ib0, nf = 0;

   if (ia >= mu && ib >= nu) return;

   if (ia == 0 && ib == 0) /* initial fetch, always get 2 */
   {
      assert(ifetch >= 2);
      if (offA) fprintf(fpout, "%s   %s0 = %s0[%d];\n", spc, rA, pA, offA);
      else fprintf(fpout, "%s   %s0 = *%s0;\n", spc, rA, pA);
      if (offB) fprintf(fpout, "%s   %s0 = %s0[%d];\n", spc, rB, pB, offB);
      else fprintf(fpout, "%s   %s0 = *%s0;\n", spc, rB, pB);
      nf = 2;
      ia = ib = 1;
   }
   while ( (nf < ifetch) && (ia < mu || ib < nu) )
   {
      if (ia < mu) /* remaining elts of inner matrix to be fetched */
      {
         if (rowA) /* fetching from row */
         {
            if (lda) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                              spc, rA, ia, pA, offA+(ia*lda)*mulA);
            else if (offA == 0) 
               fprintf(fpout, "%s   %s%d = *%s%d;\n", spc, rA, ia, pA, ia);
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", spc, rA, ia, pA, 
                         ia, offA);
         }
         else fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                      spc, rA, ia, pA, offA+ia*mulA);
         ia++;
      }
      else  /* after inner matrix fetched, fetch outer matrix */
      {
         if (rowB) /* fetching from row */
         {
            if (ldb) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                              spc, rB, ib, pB, offB+ib*ldb*mulB);
            else if (offB == 0) 
               fprintf(fpout, "%s   %s%d = *%s%d;\n", spc, rB, ib, pB, ib);
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", spc, rB, ib, pB, 
                         ib, offB);
         }
         else fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                      spc, rB, ib, pB, offB+ib*mulB);
         ib++;
      }
      nf++;
   }
   *ia0 = ia;
   *ib0 = ib;
}

/*
 * incABk : increment A & B pointers or offsets inside K-loop
 */
void incABk(FILE *fpout, char *spc, 
            char *pA, char *pB,   /* varnams of pointers to matrices */
            int mu, int nu,       /* unrollings */
            int *offA, int *offB,  /* offsets from ptr to first part of block */
            int lda, int ldb,      /* leading dimensions */
            int mulA, int mulB,    /* col increment: 1 = real, 2 = cplx */
            int incpA, int incpB,  /* Increment ptrs at each K iteration? */
            char *incAk, char *incBk, /* if needed, K-loop inc constant */
            int rowA, int rowB)    /* 0: fetch from col, else fetch from row */
{
   int p;

   if (incpA)
   {
      if (rowA)
      {
         if (mulA == 1)
         {
            if (lda) fprintf(fpout, "%s   %s0++;\n", spc, pA);
            else for(p=0; p < mu; p++) 
                    fprintf(fpout, "%s   %s%d++;\n",spc, pA, p);
         }
         else
         {
            if (lda) fprintf(fpout, "%s   %s0 += %d;\n", spc, pA, mulA);
            else for(p=0; p < mu; p++) 
                    fprintf(fpout, "%s   %s%d += %d;\n",spc, pA, p, mulA);
         }
      }
      else  /* mu unroll is along a column */
      {
         if (lda) fprintf(fpout, "%s   %s0 += %d;\n", spc, pA, lda*mulA);
         else fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
      }
   }
   else
   {
      if (rowA) (*offA) += mulA;
      else
      {
         assert(lda);
         *offA += mulA*lda;
      }
   }

   if (incpB)
   {
      if (rowB)
      {
         if (mulB == 1)
         {
            if (ldb) fprintf(fpout, "%s   %s0++;\n", spc, pB);
            else for(p=0; p < nu; p++) 
                    fprintf(fpout, "%s   %s%d++;\n",spc, pB, p);
         }
         else
         {
            if (ldb) fprintf(fpout, "%s   %s0 += %d;\n", spc, pB, mulB);
            else for(p=0; p < nu; p++) 
                    fprintf(fpout, "%s   %s%d += %d;\n",spc, pB, p, mulB);
         }
      }
      else  /* nu unroll is along a row */
      {
         if (ldb) fprintf(fpout, "%s   %s0 += %d;\n", spc, pB, ldb*mulB);
         else fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
      }
   }
   else  /* incrementing offset, not pointers */
   {
      if (rowB) (*offB) += mulB;
      else
      {
         assert(ldb);
         *offB += mulB*ldb;
      }
   }
}

/*
 * regKunroll_ma: K-loop unrolling for combine multiply/add instruction.
 * Unrolls k loop by ku, with mu unroll along inner matrix & nu along outer.
 * If actual inner matrix is B instead of A, pass B's data in A and vice versa,
 * and assign pC[i][j] = rCji.
 */
void regKunroll_ma(FILE *fpout, 
                   char *spc,  /* indentation string */
                   enum ATLAS_LOOP_ORDER LoopOrder,
                   int ifetch, /* number of initial fetches to perform */
                   int nfetch, /* # of fetches to perform for every flop */
                   char *rA,   /* varnam for registers of inner matrix */
                   char *rB,   /* varnam for registers of outer matrix */
                   char *rC,   /* varnam for registers holding C */
                   char *pA,   /* varnam for pointer(s) to inner matrix */
                   char *pB,   /* varnam for pointer(s) to outer matrix */
                   int mu,     /* unrolling along inner loop */
                   int nu,     /* unrolling along outer loop */
                   int ku,     /* unrolling along k-loop (innermost) */
                   int *offA0, /* offset to first elt of this block */
                   int *offB0, /* offset to first elt of this block */
                   int lda,    /* row stride; if 0, row stride is arbitrary */
                   int ldb,    /* row stride; if 0, row stride is arbitrary */
                   int mulA,   /* col stride; 1: real 2: cplx */
                   int mulB,   /* col stride; 1: real 2: cplx */
                   int incpA,  /* Increment A for every K iteration? */
                   int incpB,  /* Increment B for every K iteration? */
                   char *incAk,  /* if !rowA, k-loop increment for ptrs */
                   char *incBk,  /* if !rowB, k-loop increment for ptrs */
                   int rowA, /* if 0, fetch within col, else fetch within row */
                   int rowB) /* if 0, fetch within col, else fetch within row */
{
   int i, j, k, ia=0, ib=0, offA=(*offA0), offB=(*offB0);

   if (LoopOrder == AtlasIJK)
   {
      regKunroll_ma(fpout, spc, AtlasJIK, ifetch, nfetch, rB, rA, rC, pB, pA, 
                    nu, mu, ku, offB0, offA0, ldb, lda, mulB, mulA, 
                    incpA, incpB, incBk, incAk, rowB, rowA);
      return;
   }
   for (k=0; k < ku; k++)
   {
      ia = ib = 0;
      opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, offA, offB, 
              lda, ldb, mulA, mulB, rowA, rowB, &ia, &ib);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            fprintf(fpout, "%s   %s%d%d += %s%d * %s%d;\n", 
                    spc, rC, i, j, rA, i, rB, j);
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, offA, offB, 
                    lda, ldb, mulA, mulB, rowA, rowB, &ia, &ib);
         }
      }
      incABk(fpout, spc, pA, pB, mu, nu, &offA, &offB, lda, ldb, mulA, mulB, 
             incpA, incpB, incAk, incBk, rowA, rowB);
   }
}

/*
 * regKloop_ma : Creates a full K-loop, unrolled by ku, assuming M & N
 * unrollings of mu & nu, using combined muladd instruction
 */
void regKloop_ma(FILE *fpout, 
                 char *spc,  /* indentation string */
                 enum ATLAS_LOOP_ORDER LoopOrder,
                 enum ATLAS_TRANS TA,
                 enum ATLAS_TRANS TB,
                 int M,     /* if 0, M is arbitrary, else M is len of M-loop */
                 int N,     /* if 0, N is arbitrary, else N is len of N-loop */
                 int K,      /* if 0, K is arbitrary, else K is len of K-loop */
                 int ifetch, /* number of initial fetches to perform */
                 int nfetch, /* # of fetches to perform for every flop */
                 int lat,    /* latency */
                 char *rA,   /* varnam for registers of inner matrix */
                 char *rB,   /* varnam for registers of outer matrix */
                 char *rC,   /* varnam for registers holding C */
                 char *pA,   /* varnam for pointer(s) to inner matrix */
                 char *pB,   /* varnam for pointer(s) to outer matrix */
                 int mu,     /* unrolling along inner loop */
                 int nu,     /* unrolling along outer loop */
                 int ku,     /* unrolling along k-loop (innermost) */
                 int lda,    /* row stride: 0 = unknown */
                 int ldb,    /* row stride: 0 = unknown */
                 int mulA,   /* column stride: 1 = real, 2 = cplx */
                 int mulB,   /* column stride: 1 = real, 2 = cplx */
                 int incpA,  /* Increment A for every K iteration? */
                 int incpB,  /* Increment B for every K iteration? */
                 char *incAk,  /* if !rowA, k-loop increment for ptrs */
                 char *incBk)  /* if !rowB, k-loop increment for ptrs */
{
   char kadj[8];
   int i;
   int rowA, rowB; /* mu/nu elts fetched from row? */
   int offA=0, offB=0;
   if (K) assert (ku*2 <= K || K == ku);  /* need at least one iter. for loop */

   if (TA == AtlasNoTrans) rowA = 0;
   else rowA = 1;
   if (TB == AtlasNoTrans) rowB = 1;
   else rowB = 0;

   if (ku == K) /* loop fully unrolled */
   {
      regKunroll_ma(fpout, spc, LoopOrder, ifetch, nfetch, rA, rB, rC, pA, pB,
                    mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, 
                    incpA, incpB, incAk, incBk, rowA, rowB);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (ldb == 0 && TB == AtlasNoTrans)
            for (i=1; i < nu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
      return;
   }

   if (K)
   {
      if (ku == 1) 
         fprintf(fpout, "%s   for (k=%d; k; k--) /* easy loop to unroll */\n",
                 spc, K);
      else fprintf(fpout, 
                   "%s   for (k=%d; k; k -= %d) /* easy loop to unroll */\n",
                   spc, (K/ku)*ku, ku);
   }
   else
   {
      if (ku == 1) 
         fprintf(fpout, "%s   for (k=K; k; k--) /* easy loop to unroll */\n",
                 spc);
      else fprintf(fpout, 
                   "%s   for (k=Kb; k; k -= %d) /* easy loop to unroll */\n",
                   spc, ku);
   }
   fprintf(fpout, "%s   {\n", spc);
   spc -= 3;
   regKunroll_ma(fpout, spc, LoopOrder, ifetch, nfetch, rA, rB, rC, pA, pB, 
                 mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                 incAk, incBk, rowA, rowB);
   if (!incpA) /* need to increment the A pointers ourselves */
   {  
      fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
      if (rowA && !lda)
         for (i=1; i < mu; i++) 
            fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
   }
   if (!incpB) /* need to increment the B pointers ourselves */
   {
      fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
      if (rowB && !ldb) 
         for (i=1; i < nu; i++) 
            fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
   }
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);

/*
 * K-loop cleanup
 */
   if (K) /* known cleanup */
   {
      if (K%ku)
         regKunroll_ma(fpout, spc, LoopOrder, ifetch, nfetch, rA, rB, rC, 
                       pA, pB, mu, nu, K%ku, &offA, &offB, lda, ldb, mulA, mulB,
                       incpA, incpB, incAk, incBk, rowA, rowB);
      sprintf(kadj, "%d", K%ku);
   }
   else if (ku > 1) /* cleanup between 0-(ku-1) */
   {
      fprintf(fpout, "%s   switch(k = (K-Kb))\n%s   {\n", spc, spc);
      for (i=1; i < ku; i++)
      {
         fprintf(fpout, "%s   case %d:\n", spc, i);
         regKunroll_ma(fpout, spc-3, LoopOrder, ifetch, nfetch, rA, rB, rC, 
                       pA, pB, mu, nu, i, &offA, &offB, lda, ldb, mulA, mulB, 
                       incpA, incpB, incAk, incBk, rowA, rowB);
         fprintf(fpout, "%s      break;\n", spc);
      }
      fprintf(fpout, "%s   case 0: ;\n%s   }\n", spc, spc);
      sprintf(kadj, "k");
   }
   if ( (K && K%ku) || ku > 1)
   {
      if (incpA)
      {
         fprintf(fpout, "%s   %s0 -= %s*%s;\n", spc, pA, kadj, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d -= %s*%s;\n", spc, pA, i, kadj, incAk);
      }
      if (incpB)
      {
         fprintf(fpout, "%s   %s0 -= %s*%s;\n", spc, pB, kadj, incBk);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d -= %s*%s;\n", spc, pB, i, kadj, incBk);
      }
   }
}

/*
 * regKunroll: K-loop unrolling for separate multiply and add instructions.
 * Unrolls k loop by ku, with mu unroll along inner matrix & nu along outer.
 * If actual inner matrix is B instead of A, pass B's data in A and vice versa,
 * and assign pC[i][j] = rCji.
 * Assumes lat flops of this iteration done previously, lat of next done here,
 * Present flop to be done is (iop,jop) of the mu*nu to be done.
 * assumes ifetch has enough data for all lat operations !!!!
 */
int regKunroll(FILE *fpout,
               char *spc,  /* indentation string */
               enum ATLAS_LOOP_ORDER LoopOrder,
               int ifetch, /* number of initial fetches to perform */
               int nfetch, /* # of fetches to perform for every flop */
               int lat,    /* skew of K-loop */
               int STARTUP, /* 0: not starting pipeline, else doing so */
               char *rA,   /* varnam for registers of inner matrix */
               char *rB,   /* varnam for registers of outer matrix */
               char *rC,   /* varnam for registers of C */
               char *pA,   /* varnam for pointer(s) to inner matrix */
               char *pB,   /* varnam for pointer(s) to outer matrix */
               int mu,     /* unrolling along inner loop */
               int nu,     /* unrolling along outer loop */
               int ku,     /* unrolling along k-loop (innermost) */
               int *offA,  /* offset to first elt of this block */
               int *offB,  /* offset to first elt of this block */
               int lda,    /* row stride; if 0, row stride is arbitrary */
               int ldb,    /* row stride; if 0, row stride is arbitrary */
               int mulA,   /* col stride; 1: real 2: cplx */
               int mulB,   /* col stride; 1: real 2: cplx */
               int incpA,  /* Increment A for every K iteration? */
               int incpB,  /* Increment B for every K iteration? */
               char *incAk,  /* if !rowA, k-loop increment for ptrs */
               char *incBk,  /* if !rowB, k-loop increment for ptrs */
               int rowA, /* if 0, fetch within col, else fetch within row */
               int rowB, /* if 0, fetch within col, else fetch within row */
               int *ia,    /* elt of inner matrix to be fetched */
               int *ib,    /* elt of outer matrix to be fetched */
               int *iop0,   /* 1st operand of inner matrix to use */
               int *jop0)   /* 1st operand of outer matrix to use */
{
   int i, j, k, h=0;
   int iop = *iop0, jop = *jop0;

   if (LoopOrder == AtlasIJK)
      return(regKunroll(fpout, spc, AtlasJIK, ifetch, nfetch, lat, STARTUP, 
                        rB, rA, rC, pB, pA, nu, mu, ku, offB, offA, ldb, lda, 
                        mulB, mulA, incpB, incpA, incBk, incAk, rowB, rowA, 
                        ib, ia, jop0, iop0));
   if (STARTUP) fprintf(fpout, "/*\n *%s Start pipeline\n */\n", spc);
/*
 * If we have not fetched any data for this iteration yet, do so
 */
   if (STARTUP && *ia == 0 && *ib == 0) 
      opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, *offA, *offB, 
              lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
/*
 * One iteration of the ku-unrolled K loop
 */
   for (k=0; k < ku; k++)
   {
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            if (!STARTUP) 
               fprintf(fpout, "%s   %s%d%d += m%d;\n", spc, rC, i, j, h);
            fprintf(fpout, "%s   m%d = %s%d * %s%d;\n", 
                    spc, h, rA, iop, rB, jop);
            if (++iop == mu)
            {
               iop = 0;
               if (++jop == nu) /* used all this iteration's data */
               {
                  jop = 0;
                  incABk(fpout, spc, pA, pB, mu, nu, offA, offB, lda, ldb, 
                         mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB);
                  *ia = *ib = 0;
                  opfetch(fpout, spc, ifetch, rA, rB, pA, pB, mu, nu, 
                          *offA, *offB, lda, ldb, mulA, mulB, rowA, rowB, 
                          ia, ib);
               }
            }
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, *offA, *offB,
                    lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
            if (++h == lat)
            {
               if (STARTUP)
               {
                  fprintf(fpout, "\n");
                  *iop0 = iop;
                  *jop0 = jop;
                  return(lat);
               }
               h = 0;
            }
         }
      }
   }
   *iop0 = iop;
   *jop0 = jop;
   return(h);
}

/* 
 * regKdrain: drains the pipe by explicitly unrolling last K iteration
 */
void regKdrain(FILE *fpout,
               char *spc,  /* indentation string */
               enum ATLAS_LOOP_ORDER LoopOrder,
               int ifetch, /* number of initial fetches to perform */
               int nfetch, /* # of fetches to perform for every flop */
               int lat,    /* skew of K-loop */
               char *rA,   /* varnam for registers of inner matrix */
               char *rB,   /* varnam for registers of outer matrix */
               char *rC,   /* varnam for registers of C */
               char *pA,   /* varnam for pointer(s) to inner matrix */
               char *pB,   /* varnam for pointer(s) to outer matrix */
               int mu,     /* unrolling along inner loop */
               int nu,     /* unrolling along outer loop */
               int ku,     /* unrolling along k-loop (innermost) */
               int *offA,  /* offset to first elt of this block */
               int *offB,  /* offset to first elt of this block */
               int lda,    /* row stride; if 0, row stride is arbitrary */
               int ldb,    /* row stride; if 0, row stride is arbitrary */
               int mulA,   /* col stride; 1: real 2: cplx */
               int mulB,   /* col stride; 1: real 2: cplx */
               int incpA,  /* Increment A for every K iteration? */
               int incpB,  /* Increment B for every K iteration? */
               char *incAk,  /* if !rowA, k-loop increment for ptrs */
               char *incBk,  /* if !rowB, k-loop increment for ptrs */
               int rowA, /* if 0, fetch within col, else fetch within row */
               int rowB, /* if 0, fetch within col, else fetch within row */
               int *ia,    /* elt of inner matrix to be fetched */
               int *ib,    /* elt of outer matrix to be fetched */
               int iop,   /* 1st operand of inner matrix to use */
               int jop,   /* 1st operand of outer matrix to use */
               int h)     /* */
{
   int i, j, k=0;
   int REGFETCH=1;

   if (LoopOrder == AtlasIJK)
   {
      regKdrain(fpout, spc, AtlasJIK, ifetch, nfetch, lat, rB, rA, rC,
                pB, pA, nu, mu, ku, offB, offA, ldb, lda, mulB, mulA,
                incpB, incpA, incBk, incAk, rowB, rowA, ib, ia, jop, iop, h);
      return;
   }
/*
 * Drain part of pipe where we are still doing multiplies.  Once iop and jop
 * reach mu/nu, we stop doing fetches
 */
   fprintf(fpout, "/*\n *%s Drain pipe on last iteration of K-loop\n */\n",
           spc);
@skip   if (lat == mu*nu && iop == 0 && jop == 0) { iop = mu; jop = nu; }
   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fpout, "%s   %s%d%d += m%d;\n", spc, rC, i, j, h);
         if (iop < mu || jop < nu)
         {
            fprintf(fpout, "%s   m%d = %s%d * %s%d;\n", 
                    spc, h, rA, iop, rB, jop);
            if (++iop == mu)
            {
               iop = 0;
               if (++jop == nu) /* used all this iteration's data */
               {
                  REGFETCH = 0;
                  iop = mu;
                  incABk(fpout, spc, pA, pB, mu, nu, offA, offB, lda, ldb, 
                         mulA, mulB, incpA, incpB, incAk, incBk, rowA, rowB);
               }
            }
         }
         else k++;
         if (++h == lat) h = 0;
         if (REGFETCH)
            opfetch(fpout, spc, nfetch, rA, rB, pA, pB, mu, nu, *offA, *offB, 
                    lda, ldb, mulA, mulB, rowA, rowB, ia, ib);
      }
   }
/*
 * Drain last of pipe, where all we do is adds
 */
   while (k < lat)
   {
      for (j=0; j < nu && k < lat; j++)
      {
         for (i=0; i < mu && k < lat; i++, k++)
         {
            fprintf(fpout, "%s   %s%d%d += m%d;\n", spc, rC, i, j, h);
            if (++h == lat) h = 0;
         }
      }
   }
}
/*
 * regKloop : Creates a full K-loop, unrolled by ku, assuming M & N
 * unrollings of mu & nu, using separate muladd instruction
 */
void regKloop(FILE *fpout, 
              char *spc,  /* indentation string */
              enum ATLAS_LOOP_ORDER LoopOrder,
              enum ATLAS_TRANS TA,
              enum ATLAS_TRANS TB,
              int M,     /* if 0, M is arbitrary, else M is len of M-loop */
              int N,     /* if 0, N is arbitrary, else N is len of N-loop */
              int K,      /* if 0, K is arbitrary, else K is len of K-loop */
              int ifetch, /* number of initial fetches to perform */
              int nfetch, /* # of fetches to perform for every flop */
              int lat,    /* latency */
              char *rA,   /* varnam for registers of inner matrix */
              char *rB,   /* varnam for registers of outer matrix */
              char *rC,   /* varnam for registers holding C */
              char *pA,   /* varnam for pointer(s) to inner matrix */
              char *pB,   /* varnam for pointer(s) to outer matrix */
              int mu,     /* unrolling along inner loop */
              int nu,     /* unrolling along outer loop */
              int ku,     /* unrolling along k-loop (innermost) */
              int lda,    /* row stride: 0 = unknown */
              int ldb,    /* row stride: 0 = unknown */
              int mulA,   /* column stride: 1 = real, 2 = cplx */
              int mulB,   /* column stride: 1 = real, 2 = cplx */
              int incpA,  /* Increment A for every K iteration? */
              int incpB,  /* Increment B for every K iteration? */
              char *incAk,  /* if !rowA, k-loop increment for ptrs */
              char *incBk)  /* if !rowB, k-loop increment for ptrs */
{
   int k, Kb, Kpipe, Kloop, kr;
   int i, j, h;
   int rowA, rowB; /* mu/nu elts fetched from row? */
   int offA=0, offB=0, offA0, offB0;
   int ia=0, ib=0, iop=0, jop=0;
   char incAk0[64], incBk0[64];

   sprintf(incAk0, "%s0", incAk);
   sprintf(incBk0, "%s0", incBk);
   if (K)
   {
      Kb = K - K % ku;
      if (2*lat > K)
      {
         regKloop_ma(fpout, spc, LoopOrder, TA, TB, M, N, K, ifetch, nfetch, 
                     lat, rA, rB, rC, pA, pB, mu, nu, ku, lda, ldb, mulA, mulB,
                     incpA, incpB, incAk, incBk);
         return;
      }
      assert (ku*2 <= K || K == ku);  /* need at least one iter. for loop */
   }
   if (K != ku)
   {
      if (K) i = mu*nu*ku;
      else i = mu*nu;
      if (i > lat) assert(i == ((i)/lat)*lat);
      else assert(lat == (lat/i)*i);
   }
@skip   assert( ifetch+nfetch*lat <= ku*(mu+nu) );

   if (TA == AtlasNoTrans) rowA = 0;
   else rowA = 1;
   if (TB == AtlasNoTrans) rowB = 1;
   else rowB = 0;


   if (K == ku)  /* fully unrolled loop */
   {
      regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 1, rA, rB, rC, 
                 pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, 
                 incpA, incpB, incAk, incBk, rowA, rowB, &ia, &ib, &iop, &jop);
      fprintf(fpout, "/*\n *%s Completely unrolled K-loop\n */\n", spc);
      i = ku - (lat/(mu*nu)) - 1;
      h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, rA, rB, rC,
                     pA, pB, mu, nu, i, &offA, &offB, lda, ldb, mulA, mulB,
                     incpA, incpB, incAk, incBk, rowA, rowB, &ia, &ib, 
                     &iop, &jop);
      regKdrain(fpout, spc, LoopOrder, ifetch, nfetch, lat, rA, rB, rC, pA, pB,
                mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                incAk, incBk, rowA, rowB, &ia, &ib, iop, jop, h);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (lda == 0 && TA != AtlasNoTrans)
            for (i=1; i < mu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (ldb == 0 && TB == AtlasNoTrans)
            for (i=1; i < nu; i++)
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
   }
   else  /* unknown K != ku */
   {
      Kpipe = lat / (mu*nu) + 1;  /* its done in pipeline startup & drain */
      if (K)
      {
         Kloop = ((K-Kpipe)/ku)*ku;
         kr = K - Kpipe - Kloop;
      }
      else Kloop = kr = 0;

      offA0 = offA; offB0 = offB;
      regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 1, rA, rB, rC, 
                 pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, 
                 incpA, incpB, incAk0, incBk0, rowA, rowB, 
                 &ia, &ib, &iop, &jop);
      k = Kpipe - 1;
      if (!incpA && k) /* need to increment the A pointers ourselves */
      {  
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(k, incAk0));
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, 
                       GetInc(k, incAk0));
      }
      if (!incpB && k) /* need to increment the B pointers ourselves */
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(k, incBk0));
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, 
                       GetInc(k, incBk0));
      }
      offA = offA0; offB = offB0;  /* offsets stay as set by pipeline */

      if (K)
      {
         if (ku == 1) 
           fprintf(fpout, "%s   for (k=%d; k; k--) /* easy loop to unroll */\n",
                    spc, Kloop);
         else fprintf(fpout, 
                      "%s   for (k=%d; k; k -= %d) /* easy loop to unroll */\n",
                      spc, Kloop, ku);
      }
      else
      {
         if (ku == 1) 
            fprintf(fpout, 
                    "%s   for (k=Kloop; k; k--) /* easy loop to unroll */\n",
                    spc);
         else fprintf(fpout, 
                 "%s   for (k=Kloop; k; k -= %d) /* easy loop to unroll */\n",
                      spc, ku);
      }
      fprintf(fpout, "%s   {\n", spc);
      spc -= 3;
      h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, rA, rB, rC,
                     pA, pB, mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB,
                     incpA, incpB, incAk, incBk, rowA, rowB, &ia, &ib, 
                     &iop, &jop);
      if (!incpA) /* need to increment the A pointers ourselves */
      {  
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk);
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk);
      }
      if (!incpB) /* need to increment the B pointers ourselves */
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk);
      }
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      if (kr)
      {
         offA = offA0;  offB = offB0;
         h = regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 
                        rA, rB, rC, pA, pB, mu, nu, kr, &offA, &offB, 
                        lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk, 
                        rowA, rowB, &ia, &ib, &iop, &jop);
         if (!incpA) /* need to increment the A pointers ourselves */
         {  
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(kr, incAk0));
            if (rowA && !lda)
               for (i=1; i < mu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, 
                          GetInc(kr, incAk0));
         }
         if (!incpB) /* need to increment the B pointers ourselves */
         {
            fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(kr, incBk0));
            if (rowB && !ldb) 
               for (i=1; i < nu; i++) 
                  fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, 
                          GetInc(kr, incBk0));
         }
      }
      else if (K == 0 && ku != 1)
      {
         fprintf(fpout, "%s   switch(kr)\n%s   {\n", spc, spc);
         for (i=1; i < ku; i++)
         {
            fprintf(fpout, "%s   case %d:\n", spc, i);
            spc -= 3;
            offA = offA0;  offB = offB0;
            regKunroll(fpout, spc, LoopOrder, ifetch, nfetch, lat, 0, 
                       rA, rB, rC, pA, pB, mu, nu, i, &offA, &offB, 
                       lda, ldb, mulA, mulB, incpA, incpB, incAk, incBk, 
                       rowA, rowB, &ia, &ib, &iop, &jop);
            if (!incpA) /* need to increment the A pointers ourselves */
            {  
               fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, GetInc(i, incAk0));
               if (rowA && !lda)
                  for (j=1; j < mu; j++) 
                     fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, j, 
                             GetInc(i, incAk0));
            }
            if (!incpB) /* need to increment the B pointers ourselves */
            {
               fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, GetInc(i, incBk0));
               if (rowB && !ldb) 
                  for (j=1; j < nu; j++) 
                     fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, j, 
                             GetInc(i, incBk0));
            }
            spc += 3;
            fprintf(fpout, "%s      break;\n", spc);
         }
         fprintf(fpout, "%s   case 0: ;\n%s   }\n", spc, spc);

@beginskip
         if (!incpA) /* need to increment the A pointers ourselves */
         {  
            fprintf(fpout, "%s   k = kr * %s;\n", incAk0);
            fprintf(fpout, "%s   %s0 += k;\n", spc, pA);
            if (rowA && !lda)
               for (i=1; i < mu; i++) 
                  fprintf(fpout, "%s   %s%d += k;\n", spc, pA, i);
         }
         if (!incpB) /* need to increment the B pointers ourselves */
         {
            fprintf(fpout, "%s   k = kr * %s;\n", incBk0);
            fprintf(fpout, "%s   %s0 += k;\n", spc, pB);
            if (rowB && !ldb) 
               for (i=1; i < nu; i++) 
                  fprintf(fpout, "%s   %s%d += k;\n", spc, pB, i);
         }
         fprintf(fpout, "%s   }\n", spc);
@endskip
      }
      offA = offA0;  offB = offB0;
      regKdrain(fpout, spc, LoopOrder, ifetch, nfetch, lat, rA, rB, rC, pA, pB,
                mu, nu, ku, &offA, &offB, lda, ldb, mulA, mulB, incpA, incpB,
                incAk0, incBk0, rowA, rowB, &ia, &ib, iop, jop, h);
      if (!incpA)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pA, incAk0);
         if (rowA && !lda)
            for (i=1; i < mu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pA, i, incAk0);

      }
      if (!incpB)
      {
         fprintf(fpout, "%s   %s0 += %s;\n", spc, pB, incBk0);
         if (rowB && !ldb) 
            for (i=1; i < nu; i++) 
               fprintf(fpout, "%s   %s%d += %s;\n", spc, pB, i, incBk0);
      }
   }
}

/*
 * fetchC : fetches mu*nu elts of C, & applies beta
 * If LoopOrder is IJK, we will pass B in as A, so we need to transpose C
 */
void fetchC(FILE *fpout,
            char *spc,
            enum ATLAS_LOOP_ORDER LoopOrder,
            int ForceFetch,  /* fetch C even if beta==0? */
            int mu,          /* unroll of inner loop */
            int nu,          /* unroll of outer loop */
            int offC,    /* offset to start of C */
            char *pC,    /* varnam of pointer to C */
            char *rC,    /* register name for elts of C */
            int mul,     /* stride in elts of C in column (1=real, 2=cplx) */
            int ldc,     /* if 0: use ptrs for cols of C; else row stride */
            int alpha,
            int beta,
            char *reg)   /* name of unrelated register for beta */
{
   int i, j;
   if (ForceFetch && beta == 0) /* lame-ass prefetch on C */
   {
      fprintf(fpout, "/*\n *%s Feeble prefetch of C\n */\n", spc);
      for (j=0; j < nu; j++)
      {
         fprintf(fpout, "%s   %s%d%d = ", spc, rC, 0, j);
         if (ldc)
         {
            if (offC+j) fprintf(fpout, "%s0[%d];\n", pC, offC+(j*ldc)*mul);
            else fprintf(fpout, "*%s0;\n", pC);
         }
         else
         {
            if (offC) fprintf(fpout, "%s%d[%d];\n", pC, j, offC);
            else fprintf(fpout, "*%s%d;\n", pC, j);
         }
      }
   }
   else if ( (beta && alpha != SAFE_ALPHA) )
   {
      if (alpha != 1)
         fprintf(fpout, "%s   %s = BetaAlpha;\n", spc, reg);
      else if (beta != 1 && beta != -1 && beta != 0)
         fprintf(fpout, "%s   %s = beta;\n", spc, reg);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, "%s   %s%d%d = ", spc, rC, i, j);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, "%s   %s%d%d = ", spc, rC, j, i);
            if (ldc)
            {
               if (offC+i+j) 
                  fprintf(fpout, "%s0[%d];\n", pC, offC+(j*ldc+i)*mul);
               else fprintf(fpout, "*%s0;\n", pC);
            }
            else
            {
               if (offC+i) fprintf(fpout, "%s%d[%d];\n", pC, j, offC+i*mul);
               else fprintf(fpout, "*%s%d;\n", pC, j);
            }
            if (beta == -1) fprintf(fpout, "%s   %s%d%d = -%s%d%d;\n", 
                                    spc, rC, i, j, rC, i, j);
            else if (beta != 1 && beta != 0 || alpha != 1)
               fprintf(fpout, "%s   %s%d%d *= %s;\n", spc, rC, i, j, reg);
         }
      }
   }
   if (beta == 0 || alpha == SAFE_ALPHA)
   {
      fprintf(fpout, "%s   ", spc);
      for (j=0; j < nu; j++)
         for (i=0; i < mu; i++) fprintf(fpout, "%s%d%d = ", rC, i, j);
      fprintf(fpout, "0.0;\n");
   }
}

void IncPtrs(FILE *fpout,
             char *spc, 
             int np,    /* number of pointers to increment */
             char var,  /* variable: A, B, C */
             char loop) /* which loop: n, m, k */
{
   int i;

   for (i=0; i < np; i++)
      fprintf(fpout, "%s   p%c%d += inc%c%c;\n", spc, var, i, var, loop);
}
             
void Cass(FILE *fpout,
          char *spc,
          enum ATLAS_LOOP_ORDER LoopOrder,
          int mu,          /* unroll of inner loop */
          int nu,          /* unroll of outer loop */
          int alpha,
          int beta,
          int offC,    /* offset to start of C */
          char *rA,    /* register name for elts of A */
          char *rB,    /* register name for elts of B */
          char *pC,    /* varnam of pointer to C */
          char *rC,    /* register name for elts of C */
          int mulC,     /* stride in elts of C in column (1=real, 2=cplx) */
          int ldc,     /* if 0: use ptrs for cols of C; else row stride */
          char *incC)  /* increment for this loop; if NULL don't use */
{
   int i, j;
   char *cp, calpha[32];
   int AlphaReg = (nu > 1);

   if (alpha == SAFE_ALPHA) 
   {
      if (LoopOrder == AtlasIJK)
      {
         cp = rA;
         rA = rB;
         rB = cp;
         if (nu > 1) sprintf(calpha, "%s1", rB);
         else sprintf(calpha, "alpha");
      }
      else
      {
         if (nu > 1) sprintf(calpha, "%s1", rB);
         else sprintf(calpha, "alpha");
      }
      fprintf(fpout, "%s   %s0 = beta;\n", spc, rB);
      if (AlphaReg) fprintf(fpout, "%s   %s = alpha;\n", spc, calpha);
      for (j=0; j < nu; j++)
      {
         for (i=0; i < mu; i++)
         {
            fprintf(fpout, "%s   %s%d%d *= %s;\n", spc, rC, i, j, calpha);
            if (ldc) fprintf(fpout, "%s   %s%d = %s0[%d];\n", 
                             spc, rA, i, pC, mulC*(j*ldc+i));
            else fprintf(fpout, "%s   %s%d = %s%d[%d];\n", 
                         spc, rA, i, pC, j, i*mulC);
            fprintf(fpout, "%s   %s%d%d += %s0 * %s%d;\n", 
                    spc, rC, i, j, rB, rA, i);
         }
      }
   }
   else if (alpha != 1)
   {
      fprintf(fpout, "%s   %s0 = alpha;\n", spc, rB);
      for (i=0; i < mu; i++)
      {
         for (j=0; j < nu; j++)
         {
            if (LoopOrder == AtlasJIK) 
               fprintf(fpout, "%s   %s%d%d *= %s0;\n", spc, rC, i, j, rB);
            else if (LoopOrder == AtlasIJK) 
               fprintf(fpout, "%s   %s%d%d *= %s0;\n", spc, rC, j, i, rB);
         }
      }
   }
   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         if (ldc)
         {
            if (offC+j+i)
               fprintf(fpout, "%s   %s0[%d] = ", spc, pC, offC+(ldc*j+i)*mulC);
            else fprintf(fpout, "%s   *%s0 = ", spc, pC);
         }
         else
         {
            if (i) fprintf(fpout, "%s   %s%d[%d] = ", spc, pC, j, i*mulC);
            else fprintf(fpout, "%s   *%s%d = ", spc, pC, j);
         }
         if (LoopOrder == AtlasJIK) fprintf(fpout, "%s%d%d;\n", rC, i, j);
         else if (LoopOrder == AtlasIJK) fprintf(fpout, "%s%d%d;\n", rC, j, i);
      }
   }
}

#define RegCallSeq 1
void CallMM(FILE *fpout, char *spc, char pre, char *loopstr, 
            int CleanUp, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB,
            int M, int N, int K, int mu, int nu, int ku, int alpha, int beta, 
            int lda, int ldb, int ldc, int Mb, int Nb, int Kb, 
            char *cA, char *cB, char *cC, char *cM, char *cN, char *cK)
{
   char cTA='N', cTB='N';

   if (TA == AtlasTrans) cTA = 'T';
   else if (TA == AtlasConjTrans) cTA = 'C';
   if (TB == AtlasTrans) cTB = 'T';
   else if (TB == AtlasConjTrans) cTB = 'C';

   if (CleanUp)
      fprintf(fpout, "%s   ATL_%c%s%dx%dx%d%c%c%dx%dx%d", spc, pre, loopstr, 
              M, N, K, cTA, cTB, mu, nu, ku);
   else
      fprintf(fpout, "%s   ATL_%c%s%dx%dx%d%c%c%dx%dx%d", spc, pre, loopstr, 
              M, N, K, cTA, cTB, lda, ldb, ldc);

   if (alpha == 1) fprintf(fpout, "_a1");
   else if (alpha == -1) fprintf(fpout, "_an1");
   else if (alpha == SAFE_ALPHA) fprintf(fpout, "_aXX");
   else fprintf(fpout, "_aX");
   if (beta == 1 || beta == 0) fprintf(fpout, "_b%d(", beta);
   else if (beta == -1) fprintf(fpout, "_bn1(");
   else fprintf(fpout, "_bX(");
   if (M) fprintf(fpout, "%d, ", M);
   else fprintf(fpout, "%s, ", cM);
   if (N) fprintf(fpout, "%d, ", N);
   else fprintf(fpout, "%s, ", cN);
   if (K) fprintf(fpout, "%d, ", K);
   else fprintf(fpout, "%s, ", cK);
   if ((alpha != 1 && alpha != -1) || RegCallSeq) fprintf(fpout, "alpha, ");
   fprintf(fpout, "%s, ", cA);
   if (!lda || RegCallSeq) fprintf(fpout, "lda, ");
   fprintf(fpout, "%s, ", cB);
   if (!ldb || RegCallSeq) fprintf(fpout, "ldb, ");
   if ( (beta != 1 && beta != 0 && beta != -1) || RegCallSeq) 
      fprintf(fpout, "beta, ");
   fprintf(fpout, "%s", cC);
   if (!ldc || RegCallSeq) fprintf(fpout, ", ldc");
   fprintf(fpout, ");\n");
}

void MMDeclare(FILE *fpout, char *spc, char pre, char *type, char *decmod, 
               char *loopstr, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, 
               int M, int N, int K, int mu, int nu, int ku, 
               int alpha, int beta, int lda, int ldb, int ldc)
{
   char cTA='N', cTB='N';

   if (TA == AtlasTrans) cTA = 'T';
   else if (TA == AtlasConjTrans) cTA = 'C';
   if (TB == AtlasTrans) cTB = 'T';
   else if (TB == AtlasConjTrans) cTB = 'C';
/*
 * For cleanup, put unrolling in name to distinguish from original function.
 * For regular function, encode leading dimensions instead
 */
   if (decmod[0] == '\0')
      fprintf(fpout, "%svoid ATL_%c%s%dx%dx%d%c%c%dx%dx%d", 
              spc, pre, loopstr, M, N, K, cTA, cTB, lda, ldb, ldc);
   else
      fprintf(fpout, "%s%svoid ATL_%c%s%dx%dx%d%c%c%dx%dx%d", 
              spc, decmod, pre, loopstr, M, N, K, cTA, cTB, mu, nu, ku);
   if (alpha == 1) fprintf(fpout, "_a1");
   else if (alpha == -1) fprintf(fpout, "_an1");
   else if (alpha == SAFE_ALPHA) fprintf(fpout, "_aXX");
   else fprintf(fpout, "_aX");
   if (beta == 1 || beta == 0) fprintf(fpout, "_b%d", beta);
   else if (beta == -1) fprintf(fpout, "_bn1");
   else fprintf(fpout, "_bX");
   fprintf(fpout, "\n   (");
   if (!M || RegCallSeq) fprintf(fpout, "const int M, ");
   if (!N || RegCallSeq) fprintf(fpout, "const int N, ");
   if (!K || RegCallSeq) fprintf(fpout, "const int K, ");
   if ( (alpha != 1 && alpha != -1) || RegCallSeq)
      fprintf(fpout, "const %s alpha, ", type);
   fprintf(fpout, "const %s *A, ", type);
   if (!lda || RegCallSeq) fprintf(fpout, "const int lda, ");
   fprintf(fpout, "const %s *B, ", type);
   if (!ldb || RegCallSeq) fprintf(fpout, "const int ldb, ");
   if (beta != 1 && beta != -1 && beta != 0 || RegCallSeq)
      fprintf(fpout, "const %s beta, ", type);
   fprintf(fpout, "%s *C", type);
   if (!ldc || RegCallSeq) fprintf(fpout, ", const int ldc");
   fprintf(fpout, ")\n");
   fprintf(fpout, "/*\n * matmul with TA=%c, TB=%c, MB=%d, NB=%d, KB=%d, \n", 
           cTA, cTB, M, N, K);
   fprintf(fpout, " * lda=%d, ldb=%d, ldc=%d, mu=%d, nu=%d, ku=%d\n",
           lda, ldb, ldc, mu, nu, ku);
   fprintf(fpout, " */\n");
}

static int ncucases=0;
static int cucases[64][4];
/* 
 * For every operand involved in a given loop, we pass:
 *  ldx : if 0, use pointer for each column, and moving between columns is
 *              accomplished by incrementing by constant passed in string incX
 *        else: use only 1 pointer, increment by ldx move between columns
 */
void emit_mm(FILE *fpout, 
             char *spc,  /* indentation string */
             char pre,
             char *type,
             char *decmod,  /* routine declaration modifier (eg. static) */
             enum ATLAS_LOOP_ORDER LoopOrder,
             enum ATLAS_TRANS TA,
             enum ATLAS_TRANS TB,
             int CleanUp, /* 1 : issue cleanup code, 0: do not */
             int muladd, /* 0: separate mult & add, ELSE: combined muladd */
             int lat,    /* pipeline length */
             int ForceFetch,
             int ifetch, /* number of initial fetches to perform */
             int nfetch, /* # of fetches to perform for every flop */
             int M,      /* if 0, M is arbitrary, else M is len of M-loop */
             int N,      /* if 0, N is arbitrary, else N is len of N-loop */
             int K,      /* if 0, K is arbitrary, else K is len of K-loop */
             int mu,     /* unrolling along inner loop */
             int nu,     /* unrolling along outer loop */
             int ku,     /* unrolling along k-loop (innermost) */
             int mulA,   /* column stride: 1 = real, 2 = cplx */
             int mulB,   /* column stride: 1 = real, 2 = cplx */
             int mulC,   /* column stride: 1 = real, 2 = cplx */
             int lda,    /* row stride: 0 = unknown */
             int ldb,    /* row stride: 0 = unknown */
             int ldc,    /* row stride: 0 = unknown */
             int alpha,
             int beta)

{
   char *lstr[2] = {"IJK", "JIK"};
   char *incAk="incAk", *incBk="incBk";
   char *rA = "rA";   /* varnam for registers holding A */
   char *rB = "rB";   /* varnam for registers of B */
   char *rC = "rC";
   char *pA = "pA";   /* varnam for pointer(s) to A */
   char *pB = "pB";   /* varnam for pointer(s) to B */
   char *pC = "pC";
   char *op, *ip;
   char outmat, innmat, OUTMAT, INNMAT;
   char cA[64], cB[64], cC[64], ctmp[64];
   char ln[64];
   int i, j, k, kuA, kuB;
   int muC, nuC;
   int Mb, Nb, Kb, Kb0;
   int Aptrs, Bptrs, OuterLoop, OuterTest, InnerLoop, InnerTest, lat2;
   int incpA, incpB;
   int CleanN=0, Cleaning=0;
   int CleaningM=0, CleaningN=0;
   KLOOPFUNC kloop;
   if (CleanUp) CleaningM = CleaningN = 1;
   cucases[ncucases][0] = mu;
   cucases[ncucases][1] = nu;
   cucases[ncucases][2] = ku;
   cucases[ncucases][3] = LoopOrder;
   ncucases++;
/*
 * Error checks
 */
   assert(mulA == 1 || mulA == 2);
   assert(mulB == 1 || mulB == 2);
   assert(mulC == 1 || mulC == 2);
   assert(K >= 0 && M >= 0 && N >= 0);
   assert(mu > 0 && nu > 0 && ku > 0);
   if (M) if (mu > M) mu = M;
   if (N) if (nu > N) nu = N;
   if (K)
   {
      if (2*ku > K) ku = K;
      if (2*lat > K) muladd = lat = 1;  /* no use in pipelining short loop */
   }
   if (K != ku && !muladd)
   {
      if (K) i = mu*nu*ku;
      else i = mu*nu;
      assert(i == ((i)/lat)*lat);
@skip      if (i > lat) assert(i == ((i)/lat)*lat);
@skip      else assert(lat == (lat/i)*i);
   }
   if (ifetch == -1) ifetch = mu + nu;
   if (ifetch < mu+nu) assert(nfetch > 0);
/*
 * If there is a discrepency between the number of items fetched by entering
 * the loop, and not entering it (the K=0 case), fix it
 */
   if (K == 0 && muladd == 0 && lat < mu*nu)
      while(ifetch+nfetch*lat < mu+nu) ifetch++;

/*
 * If iterating in the K loop indexes A/B by non compile time constant, we
 * must increment that pointer at each step in the K loop, even if the K loop
 * is unrolled
 */
#if 0
   incpA = (lda == 0 && TA == AtlasNoTrans || ku == 1);
   incpB = (ldb == 0 && TB != AtlasNoTrans || ku == 1);
#else
   incpA = (lda == 0 && TA == AtlasNoTrans);
   incpB = (ldb == 0 && TB != AtlasNoTrans);
#endif
   if (incpA) kuA = 1;
   else kuA = ku;
   if (incpB) kuB = 1;
   else kuB = ku;

   if (muladd) kloop = regKloop_ma;
   else kloop = regKloop;

@beginskip
   if (TA == AtlasNoTrans) lda = M;
   else lda = K;
   if (TB == AtlasNoTrans) ldb = K;
   else ldb = N;
   ldc = M;
/*
 * If we don't know how far we are unrolling the K loop, and we are doing
 * latency hiding requiring more than one K-loop iteration prefetch, we need
 * to generate cleanup case with no latency hiding
 */
   if (!muladd && !K)
   {
      for (k=0; k < ncucases; k++) 
         if (1==cucases[k][0] && 1==cucases[k][1] && 1==cucases[k][2]
             && AtlasJIK == cucases[k][3]) break;
      if ( (k == ncucases) ||
           (1==cucases[0][0] && 1==cucases[0][1] && 1==cucases[0][2] &&
            ncucases == 1 && mu*nu <= lat) )

         emit_mm(fpout, spc, pre, type, "static ", AtlasJIK, TA, TB, 1, muladd,
                 lat, ForceFetch, ifetch, nfetch, M, N, K, 1, 1, 1, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
@endskip
   if (!muladd && !K)
   {
      for (k=0; k < ncucases; k++) 
         if (1==cucases[k][0] && 1==cucases[k][1] && 1==cucases[k][2]
             && LoopOrder == cucases[k][3]) break;
      if (k == ncucases)
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, 1,
                 lat, ForceFetch, ifetch, nfetch, M, N, 0, 1, 1, 1, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
   if (N)  /* generate N-cleanup, routine, if known */
   {
      if (N%nu)
      {
         if (K) lat2 = GetGoodLat(muladd, mu, N%nu, ku, lat);
         else lat2 = GetGoodLat(muladd, mu, N%nu, 1, lat);
         CleanN = Cleaning = 1;
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, muladd,
                 lat2, ForceFetch, ifetch, nfetch, M, N%nu, K, mu, N%nu, ku, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
      }
   }
   else if (nu > 1 && CleaningN) /* unknown N */
   {
      if (K) lat2 = GetGoodLat(muladd, mu, 1, ku, lat);
      else lat2 = GetGoodLat(muladd, mu, 1, 1, lat);
      CleanN = Cleaning = 1;
      for (k=0; k < ncucases; k++) 
         if (mu==cucases[k][0] && 1==cucases[k][1] && ku==cucases[k][2]
             && LoopOrder == cucases[k][3]) break;
      if (k == ncucases)
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, muladd,
                 lat2, ForceFetch, ifetch, nfetch, M, 0, K, mu, 1, ku, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
   if (CleanN) i = N - N % nu;
   else i = N;
   if (M)
   {
      if (M%mu)
      {
         if (K) lat2 = GetGoodLat(muladd, M%mu, nu, ku, lat);
         else lat2 = GetGoodLat(muladd, M%mu, nu, 1, lat);
         Cleaning = 1;
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, !CleanN, 
                 muladd, lat2, ForceFetch, ifetch, nfetch, M%mu, i, K, 
                 M%mu, nu, ku, mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
      }
   }
   else if (mu > 1 && CleaningM)
   {
      Cleaning = 1;
      if (K) lat2 = GetGoodLat(muladd, 1, nu, ku, lat);
      else lat2 = GetGoodLat(muladd, 1, nu, 1, lat);
      for (k=0; k < ncucases; k++) 
         if (1==cucases[k][0] && nu==cucases[k][1] && ku==cucases[k][2]
             && LoopOrder == cucases[k][3]) break;
      if (k == ncucases)
         emit_mm(fpout, spc, pre, type, "static ", LoopOrder, TA, TB, 1, 
                 muladd, lat2, ForceFetch, ifetch, nfetch, 0, i, K, 1, nu, ku, 
                 mulA, mulB, mulC, lda, ldb, ldc, alpha, beta);
   }
/*
 * Name : ATL_<pre><IJK/JIK><MB>x<NB>x<KB>mm<mu>x<nu>x<ku>_aX_bX
 *        ATL_dJIK40x40x40mm4x4x1_a1_b1
 */
   MMDeclare(fpout, spc, pre, type, decmod, lstr[LoopOrder], TA, TB, M, N, K, 
             mu, nu, ku, alpha, beta, lda, ldb, ldc);
   fprintf(fpout, "{\n");

   if (LoopOrder == AtlasJIK)
   {
      muC = mu;
      nuC = nu;
      outmat = 'n';
      innmat  = 'm';
   }
   else
   {
      muC = nu;
      nuC = mu;
      outmat = 'm';
      innmat  = 'n';
   }
/*
 * Figure dimension size, in multiples of blocking factor
 */
   if (!M)
   {
      if (mu == 1) fprintf(fpout, "   #define Mb M\n");
      else
      {
         i = GetPower2(mu);
         if (i) fprintf(fpout, "   const int Mb = (M>>%d)<<%d;\n", i, i);
         else fprintf(fpout, "   const int Mb = (M/%d)*%d;\n", mu, mu);
      }
      Mb = 0;
   }
   else Mb = M - M%mu;
   if (!N)
   {
      if (nu == 1) fprintf(fpout, "   #define Nb N\n");
      else
      {
         i = GetPower2(nu);
         if (i) fprintf(fpout, "   const int Nb = (N>>%d)<<%d;\n", i, i);
         else fprintf(fpout, "   const int Nb = (N/%d)*%d;\n", nu, nu);
      }
      Nb = 0;
   }
   else Nb = N - N%nu;
   if (!K)
   {
      Kb = 0;
      i = GetPower2(ku);
      if (!muladd)
      {
         fprintf(fpout, "   #define Kb K\n");
         j = lat/(mu*nu) + 1;
         if (ku == 1)
            fprintf(fpout, "   const int Kloop = K - %d;\n", j);
         else
         {
            if (ku == 1)
            {
               fprintf(fpout, "   const int Kloop = K-%d;\n", j);
               fprintf(fpout, "   #define kr 0\n");
            }
            else
            {
               if (i) fprintf(fpout, 
                              "   const int Kloop = ((K-%d)>>%d)<<%d", j, i, i);
               else fprintf(fpout, 
                              "   const int Kloop = ((K-%d)/%d)*%d", j, ku, ku);
               fprintf(fpout, ", kr = K - Kloop - %d;\n", j);
            }
         }
      }
      else
      {
         if (ku == 1) fprintf(fpout, "   #define Kb K\n");
         else
         {
            if (i) fprintf(fpout, "   const int Kb = (K>>%d)<<%d;\n", i, i);
            else fprintf(fpout, "   const int Kb = (K/%d)*%d;\n", ku, ku);
         }
      }
   }
   else Kb = K - K%ku;
   Kb0 = Kb;
   if (!muladd) Kb = K;

   if (Cleaning)
      fprintf(fpout, "   const %s *ca=A, *cb=B;\n   %s *cc=C;\n", type, type);
/*
 * Figure loop boundary tests, stM & stN
 */
   if (TA == AtlasNoTrans)
   {
      if (M) fprintf(fpout, "   const %s *stM = A + %d;\n", 
                     type, mulA*Mb);
      else   fprintf(fpout, "   const %s *stM = A + %s;\n", 
                     type, GetInc(mulA, "Mb"));
   }
   else
   {
      if (M)
      {
         if (lda) fprintf(fpout, "   const %s *stM = A + %d;\n", 
                          type, Mb*lda*mulA);
         else fprintf(fpout, "   const %s *stM = A + %s;\n", 
                      type, GetInc(Mb*mulA, "lda"));
      }
      else if (lda) fprintf(fpout, "   const %s *stM = A + %s;\n", 
                            type, GetInc(mulA*lda, "Mb"));
      else fprintf(fpout, "   const %s *stM = A + %s;\n", 
                   type, GetInc(mulA, "lda*Mb"));
   }
   if (TB == AtlasNoTrans)
   {
      if (N)
      {
         if (ldb) fprintf(fpout, "   const %s *stN = B + %d;\n", 
                          type, Nb*ldb*mulB);
         else fprintf(fpout, "   const %s *stN = B + %s;\n", 
                      type, GetInc(Nb*mulB, "ldb"));
      }
      else if (ldb) fprintf(fpout, "   const %s *stN = B + %s;\n", 
                            type, GetInc(mulB*ldb, "Nb"));
      else fprintf(fpout, "   const %s *stN = B + %s;\n", 
                   type, GetInc(mulB, "ldb*Nb"));
   }
   else
   {
      if (N) fprintf(fpout, "   const %s *stN = B + %d;\n",
                     type, mulB*Nb);
      else   fprintf(fpout, "   const %s *stN = B + %s;\n", 
                     type, GetInc(mulB, "Nb"));
   }
   if (alpha != SAFE_ALPHA && alpha != 1)
      fprintf(fpout, "   const %s BetaAlpha = beta / alpha;\n", type);

/*
 * Figure A & B's increments for all three loops
 */
   if (LoopOrder == AtlasJIK)
   {
      if (TA == AtlasNoTrans)
      {
         if (lda) fprintf(fpout, "   #define incAk %d\n", mulA*lda*kuA);
         else fprintf(fpout, "   const int incAk = %s;\n", 
                      GetInc(kuA*mulA, "lda"));
@skip         if (K) fprintf(fpout, "   const int incAm = %d - %s", mulA*mu, 
@skip                        GetInc((K/kuA)*mulA, "incAk"));
         if (K)
         {
            if (lda) fprintf(fpout, "   const int incAm = %d - %d",
                             mulA*mu, Kb*mulA*lda);
            else fprintf(fpout, "   const int incAm = %d - %s", mulA*mu,
                         GetInc(Kb*mulA, "lda"));
         }
         else fprintf(fpout, "   const int incAm = %d - %s", mulA*mu, 
                      GetInc(mulA, "Kb*lda"));
         if (M) fprintf(fpout, ", incAn = -%d;\n", mulA*Mb);
         else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA, "Mb"));
      }
      else
      {
         fprintf(fpout, "   #define incAk %d\n", kuA*mulA);
         if (K)
         {
            if (lda)
               fprintf(fpout, "   const int incAm = %d", mulA*(lda*mu - Kb));
            else
            {
               sprintf(ln, "%s - %d", GetInc(mu, "lda"), Kb);
               fprintf(fpout, "   const int incAm = %s", GetInc(mulA, ln));
            }
         }
         else
         {
            if (lda) fprintf(fpout, "   const int incAm = %d - %s", mulA*lda*mu,
                             GetInc(mulA,"Kb"));
            else
            {
               sprintf(ln, "%s - Kb", GetInc(mu, "lda"));
               fprintf(fpout, "   const int incAm = %s", GetInc(mulA, ln));
            }
         }
         if (M)
         {
            if (lda) fprintf(fpout, ", incAn = -%d;\n", mulA*lda*Mb);
            else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA*Mb, "lda"));
         }
         else if (lda)
            fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA*lda,"Mb"));
         else fprintf(fpout, ", incAn = -%s;\n", GetInc(mulA, "Mb*lda"));
      }
      if (TB == AtlasNoTrans)
      {
         fprintf(fpout, "   #define incBk %d\n", mulB*kuB);
         if (K) fprintf(fpout, "   const int incBm = -%d", mulB*Kb);
         else fprintf(fpout, "   const int incBm = -%s", GetInc(mulB, "Kb"));
         if (ldb) fprintf(fpout, ", incBn = %d;\n", ldb*nu*mulB);
         else fprintf(fpout, ", incBn = %s;\n", GetInc(nu*mulB, "ldb"));
      }
      else
      {
         if (ldb)
         {
            fprintf(fpout, "   const int incBk = %d", mulB*kuB*ldb);
            if (K) fprintf(fpout, ", incBm = -%d", mulB*ldb*Kb);
            else fprintf(fpout, ", incBm = -%s", GetInc(mulB*ldb, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incBk = %s", GetInc(mulB*kuB, "ldb"));
            if (K) fprintf(fpout, ", incBm = -%s", GetInc(mulB*Kb, "ldb"));
            else fprintf(fpout, ", incBm = -%s", GetInc(mulB, "Kb*ldb"));
         }
         fprintf(fpout, ";\n   #define incBn %d\n", nu*mulB);
      }
   }
   else if (LoopOrder == AtlasIJK)
   {
      if (TA == AtlasNoTrans)
      {
         if (lda)
         {
            fprintf(fpout, "   const int incAk = %d", lda*kuA*mulA);
            if (K) fprintf(fpout, ", incAn = -%d", mulA*lda*Kb);
            else fprintf(fpout, ", incAn = -%s", GetInc(mulA*lda, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incAk = %s", GetInc(kuA*mulA, "lda"));
            if (K) fprintf(fpout, ", incAn = -%s", GetInc(mulA*Kb, "lda"));
            else fprintf(fpout, ", incAn = -%s", GetInc(mulA, "lda*Kb"));
         }
         fprintf(fpout, ";\n   #define incAm %d\n", mu*mulA);
      }
      else
      {
         fprintf(fpout, "   #define incAk %d\n", kuA*mulA);
         if (K) fprintf(fpout, "   const int incAn = -%d", Kb*mulA);
         else fprintf(fpout, "   const int incAn = -%s", GetInc(mulA, "Kb"));
         if (lda) fprintf(fpout, ";\n   #define incAm %d\n", mulA*lda*mu);
         else fprintf(fpout, ", incAm = %s;\n", GetInc(mulA*mu, "lda"));
      }
      if (TB == AtlasNoTrans)
      {
         fprintf(fpout, "   #define incBk %d\n", mulB*kuB);
         if (ldb)
         {
            if (K) fprintf(fpout, "   #define incBn %d;\n", mulB*(nu*ldb-Kb));
            else fprintf(fpout, "   const int incBn = %d - %s;\n", 
                         mulB*nu*ldb, GetInc(mulB, "Kb"));
            if (N) fprintf(fpout, "   #define incBm -%d\n", mulB*ldb*Nb);
            else fprintf(fpout, "   const int incBm = -%s;\n", 
                         GetInc(mulB*ldb, "Nb"));
         }
         else
         {
            if (K) fprintf(fpout, "   const int incBn = %s - %d", 
                           GetInc(mulB*nu, "ldb"), mulB*Kb);
            else
            {
               fprintf(fpout, "   const int incBn = %s - ", 
                       GetInc(mulB*nu, "ldb"));
               fprintf(fpout, "%s",  GetInc(mulB*nu, "Kb"));
            }
            if (N) fprintf(fpout, ", incBm = -%s;\n", GetInc(mulB*Nb, "ldb"));
            else fprintf(fpout, ", incBm = -%s;\n", 
                         GetInc(mulB, "Nb*ldb"));
         }
      }
      else
      {
         if (ldb)
         {
            fprintf(fpout, "   #define incBk %d\n", mulB*kuB*ldb);
            if (K) fprintf(fpout, "   const int incBn = %d", mulB*(nu-ldb*Kb));
            else fprintf(fpout, "   const int incBn = %d - %s", 
                         mulB*nu, GetInc(mulB*ldb, "Kb"));
         }
         else
         {
            fprintf(fpout, "   const int incBk = %s", 
                      GetInc(mulB*kuB, "ldb"));
            if (K) fprintf(fpout, ", incBn = %d - %s", 
                           mulB*nu, GetInc(mulB*Kb, "ldb"));
            else fprintf(fpout, ", incBn = %d - %s", 
                         mulB*nu, GetInc(mulB, "Kb*ldb"));
         }
         if (N) fprintf(fpout, ";\n   #define incBm -%d\n", mulB*Nb);
         else fprintf(fpout, ", incBm = %s;\n", GetInc(mulB, "-Nb"));
      }
   }
   if (!muladd)
   {
      if (ku == 1) 
         fprintf(fpout, "   #define incAk0 incAk\n   #define incBk0 incBk\n");
      else
      {
         if (!incpA) 
         {
            fprintf(fpout, "   const int incAk0 = %s", GetDiv(ku, "incAk"));
            if (!incpB) fprintf(fpout, ", incBk0 = %s;\n", GetDiv(ku, "incBk"));
            else fprintf(fpout, ";\n   #define incBk0 incBk\n");
         }
         else
         {
            fprintf(fpout, "   #define incAk0 incAk\n");
            if (!incpB) fprintf(fpout, "   const int incBk0 = %s;\n", 
                                GetDiv(ku, "incBk"));
            else fprintf(fpout, "   #define incBk0 incBk\n");
         }
      }
   }
   if (LoopOrder == AtlasJIK)
   {
      fprintf(fpout, "   #define incCm %d\n", mulC*mu);
      if (ldc)
      {
         if (M) fprintf(fpout, "   #define incCn %d\n", mulC*(ldc*nu-Mb));
         else fprintf(fpout, "   const int incCn = %d - %s;\n", 
                      mulC*ldc*nu, GetInc(mulC,"Mb"));
      }
      else
      {
         fprintf(fpout, "   const int incCn = %s", GetInc(mulC*nu, "ldc"));
         if (M)
         {
            if (Mb) fprintf(fpout, " - %d;\n", mulC*Mb);
            else fprintf(fpout, ";\n");
         }
         else fprintf(fpout, " - %s;\n", GetInc(mulC, "Mb"));
      }
   }
   else if (LoopOrder == AtlasIJK)
   {
      if (ldc)
      {
         fprintf(fpout, "   #define incCn %d\n", mulC*nu*ldc);
         if (N) fprintf(fpout, "   #define incCm %d\n", mulC*(mu - Nb*ldc));
         else fprintf(fpout, "   const int incCm = %d - %s;\n", 
                      mulC*mu, GetInc(mulC*ldc, "Nb"));
      }
      else
      {
         fprintf(fpout, "   const int incCn = %s", GetInc(mulC*nu, "ldc"));
         fprintf(fpout, ", incCm = %d", mulC*mu);
         if (N)
         {
            if (Nb) fprintf(fpout, " - %s;\n", GetInc(mulC*Nb, "ldc"));
            else fprintf(fpout, ";\n");
         }
         else fprintf(fpout, " - %s;\n", GetInc(mulC, "ldc*Nb"));
      }
   }
/*
 * Need to get mu[nu] ptrs when A [B] is accessed within a row inside the
 * K-loop, and the row-stride (ldx) is not known
 */
   Aptrs = ( (lda == 0) && (TA != AtlasNoTrans) );
   Bptrs = ( (ldb == 0) && (TB == AtlasNoTrans) );
/*
 * Setup necessary pointers
 */
   fprintf(fpout, "   %s *%s0=C", type, pC);
   if (!ldc)  /* need extra pointers if row stride is unknown */
      for (j=1; j < nu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pC, j, pC, j-1, GetInc(mulC,"ldc"));
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *%s0=A", type, pA);

   if (Aptrs)
      for (j=1; j < mu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pA, j, pA, j-1, GetInc(mulA,"lda"));
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *%s0=B", type, pB);
   if (Bptrs)
      for (j=1; j < nu; j++) 
         fprintf(fpout, ", *%s%d=%s%d+%s", pB, j, pB, j-1, GetInc(mulB,"ldb"));
   fprintf(fpout, ";\n");

   fprintf(fpout, "   register int k;\n");

   fprintf(fpout, "   register %s %s0", type, rA);
   for (j=1; j < mu; j++) fprintf(fpout, ", %s%d", rA, j);
   fprintf(fpout, ";\n");

   fprintf(fpout, "   register %s %s0", type, rB);
   for (j=1; j < nu; j++) fprintf(fpout, ", %s%d", rB, j);
   fprintf(fpout, ";\n");

   if (!muladd && lat)
   {
      fprintf(fpout, "   register %s m0", type);
      for (j=1; j < lat; j++) fprintf(fpout, ", m%d", j);
      fprintf(fpout, ";\n");
   }

   for (j=0; j < nuC; j++)
   {
      for (i=0; i < muC; i++)
      {
         if (i || j) fprintf(fpout, ", %s%d%d", rC, i, j);
         else fprintf(fpout, "   register %s %s00", type, rC);
      }
   }
   fprintf(fpout, ";\n");
/*
 * See which loops exist 
 */
   if (LoopOrder == AtlasJIK)
   {
      OuterLoop = (nu != N);
      OuterTest = (N == 0) && (nu > 1) && CleaningN;
      InnerLoop = (mu != M);
      InnerTest = (M == 0) && (mu > 1) && CleaningM;
      outmat = 'n';
      OUTMAT = 'N';
      innmat  = 'm';
      INNMAT  = 'M';
      op = pB;
      ip = pA;
   }
   else if (LoopOrder == AtlasIJK)
   {
      OuterLoop = (mu != M);
      OuterTest = (M == 0) && (mu > 1) && CleaningM;
      InnerLoop = (nu != N);
      InnerTest = (N == 0) && (nu > 1) && CleaningN;
      outmat = 'm';
      OUTMAT = 'M';
      innmat  = 'n';
      INNMAT  = 'N';
      op = pA;
      ip = pB;
   }

   if (!muladd && !K && mu*nu <= lat)
   {
      k = 2 + lat/(mu*nu);
      fprintf(fpout, "%s   if (K < %d)\n%s   {\n", spc, k, spc);
      CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, N, K, 
             1, 1, 1, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
             "A", "B", "C", "M", "N", "K");
      fprintf(fpout, "%s      return;\n%s   }\n", spc, spc);
   }
   if (InnerLoop && InnerTest) 
   {
      fprintf(fpout, "%s   if (%s0 != st%c)\n%s   {\n", 
              spc, ip, INNMAT, spc);
      spc -= 3;
   }
   if (OuterLoop)
   {
      if (OuterTest) 
      {
         fprintf(fpout, "%s   if (%s0 != st%c)\n%s   {\n", 
                 spc, op, OUTMAT, spc);
         spc -= 3;
      }
      fprintf(fpout, "%s   do /* %c-loop */\n%s   {\n", spc, OUTMAT, spc);
      spc -= 3;
   }
   if (InnerLoop)
   {
      fprintf(fpout, "%s   do /* %c-loop */\n%s   {\n", spc, INNMAT, spc);
      spc -= 3;
   }

   sprintf(ln, "%s0", rA);
   fetchC(fpout, spc, LoopOrder, ForceFetch, mu, nu, 0, pC, rC, mulC, ldc, 
           alpha, beta, ln);
   kloop(fpout, spc, LoopOrder, TA, TB, M, N, K, ifetch, nfetch, lat, rA, rB, 
         rC, pA, pB, mu, nu, ku, lda, ldb, mulA, mulB, incpA, incpB, 
         incAk, incBk);
   sprintf(ln, "incC%c", innmat);
   Cass(fpout, spc, LoopOrder, mu, nu, alpha, beta, 0, rA, rB, 
        pC, rC, mulC, ldc, ln);

/*
 * Must inc innerloop pointers if either loop exists, so indexing remains
 * as expected
 */
   if (InnerLoop || OuterLoop)
   {
      if (ldc != 0) IncPtrs(fpout, spc, 1, 'C', innmat);
      else IncPtrs(fpout, spc, nu, 'C', innmat);
      if (Aptrs) IncPtrs(fpout, spc, mu, 'A', innmat);
      else IncPtrs(fpout, spc, 1, 'A', innmat);
      if (Bptrs) IncPtrs(fpout, spc, nu, 'B', innmat);
      else IncPtrs(fpout, spc, 1, 'B', innmat);
   }
   if (InnerLoop)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(%s0 != st%c);\n",spc, spc, ip, INNMAT);
   }
   if (OuterLoop)
   {
      if (ldc != 0) IncPtrs(fpout, spc, 1, 'C', outmat);
      else IncPtrs(fpout, spc, nu, 'C', outmat);
      if (Aptrs) IncPtrs(fpout, spc, mu, 'A', outmat);
      else IncPtrs(fpout, spc, 1, 'A', outmat);
      if (Bptrs) IncPtrs(fpout, spc, nu, 'B', outmat);
      else IncPtrs(fpout, spc, 1, 'B', outmat);

      spc += 3;
      fprintf(fpout, "%s   }\n%s   while(%s0 != st%c);\n",spc, spc, op, OUTMAT);
      if (OuterTest)
      {
         spc += 3;
         fprintf(fpout, "%s   }\n", spc);
      }
   }
   if (InnerLoop && InnerTest)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
   }
/*
 * For loop cleanup, reuse matrix already in L1, if possible
 */
   k = 0;
   for (i=0; i < 2; i++)
   {
      if ( (LoopOrder == AtlasJIK && i == 0) || 
           (LoopOrder == AtlasIJK && i == 1 ) )
      {  /* A is in L1, clean N-loop first, else clean it second */
         if (N)
         {
            if (N%nu) /* there is cleanup to do */
            {
               if (ldc) sprintf(cC, "cc + %d", ldc*Nb*mulC);
               else sprintf(cC, "cc + %s", GetInc(Nb*mulC, "ldc"));
               if (TB == AtlasNoTrans)
               {
                  if (ldb) sprintf(cB, "cb + %d", ldb*Nb*mulB);
                  else sprintf(cB, "cb + %s", GetInc(Nb*mulB, "ldb"));
               }
               else sprintf(cB, "cb + %d", Nb*mulB);
               CallMM(fpout, spc, pre, lstr[LoopOrder], 1, TA, TB, M, N%nu, K, 
                      mu, N%nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      "ca", cB, cC, "M", "N", "K");
            }
         }
         else if (nu > 1 && CleaningN)
         {
            if (ldc) sprintf(cC, "cc + %s", GetInc(ldc*mulC, "Nb"));
            else sprintf(cC, "cc + %s", GetInc(mulC, "Nb*ldc"));
            if (TB == AtlasNoTrans)
            {
               if (ldb) sprintf(cB, "cb + %s", GetInc(ldb*mulB, "Nb"));
               else sprintf(cB, "cb + %s", GetInc(mulB, "Nb*ldb"));
            }
            else sprintf(cB, "cb + %s", GetInc(mulB, "Nb"));
            if (!k)
            {
               fprintf(fpout, "%s   if (k=N-Nb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, 0, K, 
                      mu, 1, ku, alpha, beta, lda, ldb, ldc, M, Nb, Kb0,
                      "ca", cB, cC, "M", "k", "K");
            }
            else
            {
               fprintf(fpout, "%s   if ((k=N-Nb) && Nb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, M, 0, K, 
                      mu, 1, ku, alpha, beta, lda, ldb, ldc, M, Nb, Kb0,
                      "ca", cB, cC, "Mb", "k", "K");
            }
            k = 1;
         }
      }
      else if ( (LoopOrder == AtlasIJK && i == 0) ||
                (LoopOrder == AtlasJIK && i == 1) )
      {  /* if B is in L1, clean M-loop first, else clean it second */
         if (CleanN)
         {
            j = N - N%nu;
            sprintf(ctmp, "Nb");
         }
         else
         {
            j = N;
            sprintf(ctmp, "N");
         }
         if (M)
         {
            sprintf(cC, "cc + %d", Mb*mulC);
            if (TA == AtlasNoTrans) sprintf(cA, "ca + %d", Mb*mulA);
            else
            {
               if (lda) sprintf(cA, "ca + %d", mulA*Mb*lda);
               else sprintf(cA, "ca + %s", GetInc(mulA*Mb, "lda"));
            }
            if (M%mu)
            {
               if (CleanN && !N)
               {
                  fprintf(fpout, "%s   if (Nb)\n\n", spc);
                  spc -= 3;
               }
               CallMM(fpout, spc, pre, lstr[LoopOrder], 1, TA, TB, M%mu, j, K, 
                      M%mu, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "M", ctmp, "K");
               if (CleanN && !N) spc += 3;
            }
         }
         else if (mu > 1 && CleaningM)
         {
            sprintf(cC, "cc + %s", GetInc(mulC, "Mb"));
            if (TA == AtlasNoTrans) sprintf(cA, "ca + %s", GetInc(mulA, "Mb"));
            else
            {
               if (lda) sprintf(cA, "ca + %s", GetInc(mulA*lda, "Mb"));
               else sprintf(cA, "ca + %s", GetInc(mulA, "Mb*lda"));
            }
            if (!k)
            {
               fprintf(fpout, "%s   if (k=M-Mb)\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, 0, j, K, 
                      1, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "k", "N", "K");
            }
            else
            {
               fprintf(fpout, "%s   if (Nb && (k=M-Mb))\n", spc);
               CallMM(fpout, spc-3, pre, lstr[LoopOrder], 1, TA, TB, 0, j, K, 
                      1, nu, ku, alpha, beta, lda, ldb, ldc, Mb, Nb, Kb0,
                      cA, "cb", cC, "k", "Nb", "K");
            }
            k = 1;
         }
      }
   }
   fprintf(fpout, "}\n");
   fprintf(fpout, "#ifdef incAm\n   #undef incAm\n#endif\n");
   fprintf(fpout, "#ifdef incAn\n   #undef incAn\n#endif\n");
   fprintf(fpout, "#ifdef incAk\n   #undef incAk\n#endif\n");
   fprintf(fpout, "#ifdef incBm\n   #undef incBm\n#endif\n");
   fprintf(fpout, "#ifdef incBn\n   #undef incBn\n#endif\n");
   fprintf(fpout, "#ifdef incBk\n   #undef incBk\n#endif\n");
   fprintf(fpout, "#ifdef incCm\n   #undef incCm\n#endif\n");
   fprintf(fpout, "#ifdef incCn\n   #undef incCn\n#endif\n");
   fprintf(fpout, "#ifdef incCk\n   #undef incCk\n#endif\n");
   fprintf(fpout, "#ifdef Mb\n   #undef Mb\n#endif\n");
   fprintf(fpout, "#ifdef Nb\n   #undef Nb\n#endif\n");
   fprintf(fpout, "#ifdef Kb\n   #undef Kb\n#endif\n");
}

void GenMakefile(char pre, int nb, int nb0, int nbetas, char **betas)
{
   char fnam[64];
   int i;
   FILE *fp;

   sprintf(fnam, "CLEANUP/%cMakefile", pre);
   fp = fopen(fnam, "w");
   assert(fp);

   fprintf(fp, "include ../Make.inc\n\n");
   fprintf(fp, "CDEFS2 =\n");
   fprintf(fp, "obj = \\\n");
   for (i=0; i < nbetas; i++)
   {
      fprintf(fp, "      ATL_%cpMBmm%s.o \\\n", pre, betas[i]);
      fprintf(fp, "      ATL_%cpNBmm%s.o \\\n", pre, betas[i]);
   }
   if (nb0 != 0) fprintf(fp, "      ATL_%cpKBmm0.o \\\n", pre);
   for (i=nb0+1; i <= nb; i++)
   {
      fprintf(fp, "      ATL_%cpKBmm%d.o \\\n", pre, i);
   }
   fprintf(fp, "      ATL_%cpKBmm.o \n\n", pre);

   fprintf(fp, "%cclean : clean\n", pre);
   fprintf(fp, "clean : \n\trm -f $(obj) %clib.grd\n\n", pre);

   fprintf(fp, "all : lib\n");
   fprintf(fp, "lib : %clib\n", pre);
   fprintf(fp, "%clib : %clib.grd\n", pre, pre);
   fprintf(fp, "%clib.grd : $(obj)\n", pre);
   fprintf(fp, "\t $(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);
   fprintf(fp, "\n.c.o:\n\t$(MCC) $(CDEF2) -c $(MMFLAGS) $<\n");
   fclose(fp);
}

void ComplexWrap(FILE *fpout, char *type, char *caller, char *callee, int beta)
{
   char bnam0[8], bnam0N[8];
   if (beta == 1)
   {
      sprintf(bnam0N, "_bX");
      sprintf(bnam0, "_b1");
   }
   else if (beta == 0)
   {
      sprintf(bnam0N, "_b0");
      sprintf(bnam0, "_b0");
   }
   else
   {
      sprintf(bnam0N, "_bX");
      sprintf(bnam0, "_bX");
   }
   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, bnam0N, type, type, type, type, type);
   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, "_bX", type, type, type, type, type);
   fprintf(fpout, "void %s%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", callee, "_b1", type, type, type, type, type);
   fprintf(fpout, "\n");

   fprintf(fpout, "void %s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n", caller, type, type, type, type, type);
   fprintf(fpout, "{\n");
   fprintf(fpout, "   %s%s(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", callee, bnam0N);
   fprintf(fpout, "   %s%s(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", callee, bnam0N);
   fprintf(fpout, "   %s%s(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", callee, "_bX");
   fprintf(fpout, "   %s%s(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", callee, "_b1");
   fprintf(fpout, "}\n");

}

void GetInstLogFile(char *nam, int pre, int *muladd, int *lat, int *nb, 
                    int *mu, int *nu, int *ku, int *ForceFetch,
                    int *ifetch, int *nfetch, double *mflop)
{
   char ln[128];
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp == NULL) fprintf(stderr, "file %s not found!!\n\n", nam);
   assert(fp);
   fgets(ln, 128, fp);
   fscanf(fp, " %d  %d %d %d %d %d %d %d %d %lf\n",
          muladd, lat, nb, mu, nu, ku, ForceFetch, ifetch, nfetch, mflop);
   fclose(fp);
}

void GenKBcases(char *spc, char pre, char *type, int *kb0, int *nb0)
{
   char fnam[128];
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int kb, muladd, lat, nb, mu, nu, ku, FFetch, ifetch, nfetch, i;
   int mulC=1;
   double specmf, genmf;
   FILE *fpin, *fpout;

   if (pre == 'c' || pre == 'z') mulC = 2;
   sprintf(fnam, "res/%cCleanK", pre);
   fpin = fopen(fnam, "r");
   assert(fpin);
   fgets(fnam, 128, fpin);
   i = 0;
   do
   {
      fscanf(fpin, " %d %d %d %d %d %d %d %d %d %d %lf %lf\n",
             &kb, &muladd, &lat, &nb, &mu, &nu, &ku, &FFetch, &ifetch, &nfetch, 
             &specmf, &genmf);
      ncucases = 0;
      sprintf(fnam, "CLEANUP/ATL_%cpKBmm%d.c", pre, kb);
      fpout = fopen(fnam, "w");
      assert(fpout);
      emit_mm(fpout, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
              1, muladd, lat, FFetch, ifetch, nfetch, 0, 0, kb, mu, nu, ku,
              1, 1, mulC, kb, kb, 0, 1, 8);
      fclose(fpout);
      if (kb) i++;
   }
   while (kb && i < nb);
   fclose(fpin);
   *kb0 = nb - i;
   GenMakefile(pre, nb, *kb0, 3, bnams);
   *nb0 = nb;
}

void GenKBmm(char *spc, char pre, char *type)
{
   char fnam[128];
   char *betnam = "_bX";
   const int COMPLEX = (pre == 'c' || pre == 'z');
   int i, kb0, nb;
   FILE *fp;

   GenKBcases(spc, pre, type, &kb0, &nb);

   sprintf(fnam, "CLEANUP/ATL_%cpKBmm.c", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   for (i=kb0+1; i <= nb; i++)
   {
      fprintf(fp, "void ATL_%cJIK0x0x%dTN%dx%dx0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, i, i, i, betnam, type, type, type, type, type);

   }
   if (kb0 != 0)
      fprintf(fp, "void ATL_%cJIK0x0x0TN0x0x0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, betnam, type, type, type, type, type);

   fprintf(fp, "typedef void (*MMfunc)(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n\n", type, type, type, type, type);
   fprintf(fp, "void ATL_%cpKBmm(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n{\n", pre, type, type, type, type, type);

   if (kb0 >= nb)
   {
      if (COMPLEX)
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
      }
      else
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", pre, betnam);
      }
   }
   else
   {
      fprintf(fp, "   static MMfunc mmfunc[%3d] = {\n", nb-kb0);
      for (i=kb0+1; i < nb; i++)
         fprintf(fp, 
                 "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
                 pre, i, i, i, betnam);
      fprintf(fp, "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
              pre, i, i, i, betnam);
      fprintf(fp, "                        };\n");
      if (COMPLEX) fprintf(fp, "   MMfunc mm;\n");
      fprintf(fp, "\n");

      if (kb0)
      {
         if (COMPLEX)
         {
            fprintf(fp, "   if (K <= %d)\n   {\n", kb0);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
            fprintf(fp, "   }\n   else\n   {\n");
            fprintf(fp, "      mm = mmfunc[K-%d];\n", kb0+1);
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
            fprintf(fp, "   }\n");
         }
         else
         {
            fprintf(fp, "   if (K <= %d) ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0, pre, betnam);
            fprintf(fp, "   else mmfunc[K-%d](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0+1);
         }
      }
      else if (COMPLEX)
      {
         fprintf(fp, "      mm = mmfunc[K-1];\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
      }
      else fprintf(fp, "   mmfunc[K-1](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n");
   }
   fprintf(fp, "}\n");
   fclose(fp);
}

@beginskip
void GenKBmm(char *spc, char pre, char *type, int muladd, int lat, 
             int ForceFetch, int ifetch, int nfetch, int nb,
             int mu, int nu, int ku, int mulA, int mulB, int mulC,
             int beta, char *betnam)
{
   char fnam[64], ln[128];
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int i, j, COMPLEX=0;
   int kb0, nku, *kus, *lats;
   double tmp;
   FILE *fp, *fpin;

   sprintf(fnam, "res/%cCleanK", pre);
   fpin = fopen(fnam, "r");
   assert(fpin);
   fgets(ln, 128, fpin);
   fscanf(fpin, "%d", &kb0);
   fscanf(fpin, "%lf", &tmp);
   fscanf(fpin, "%lf", &tmp);
   nku = nb - kb0;
   kus = malloc(2*sizeof(int)*nku);
   assert(kus);
   lats = kus + nku;
   for(i=0; i < nku; i++) fscanf(fpin, "%d %d", kus+i, lats+i);
   fclose(fpin);

   COMPLEX = (pre == 'c' || pre == 'z');
   if (COMPLEX) assert(beta != 0 && beta != 1 && beta != -1);
   sprintf(fnam, "CLEANUP/ATL_%cpKBmm.c", pre);
   fp = fopen(fnam, "w");
   assert(fp);

   for (i=kb0+1; i <= nb; i++)
   {
      fprintf(fp, "void ATL_%cJIK0x0x%dTN%dx%dx0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, i, i, i, betnam, type, type, type, type, type);

   }
   if (kb0 != 0)
      fprintf(fp, "void ATL_%cJIK0x0x0TN0x0x0_a1%s(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n", pre, betnam, type, type, type, type, type);

   fprintf(fp, "typedef void (*MMfunc)(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc);\n\n", type, type, type, type, type);
   fprintf(fp, "void ATL_%cpKBmm(const int M, const int N, const int K, const %s alpha, const %s *A, const int lda, const %s *B, const int ldb, const %s beta, %s *C, const int ldc)\n{\n", pre, type, type, type, type, type);

   if (kb0 >= nb)
   {
      if (COMPLEX)
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
      }
      else
      {
         fprintf(fp, "   ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", pre, betnam);
      }
   }
   else
   {
      fprintf(fp, "   static MMfunc mmfunc[%3d] = {\n", nb-kb0);
      for (i=kb0+1; i < nb; i++)
         fprintf(fp, 
                 "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
                 pre, i, i, i, betnam);
      fprintf(fp, "                         ATL_%cJIK0x0x%dTN%dx%dx0_a1%s,\n",
              pre, i, i, i, betnam);
      fprintf(fp, "                        };\n");
      if (COMPLEX) fprintf(fp, "   MMfunc mm;\n");
      fprintf(fp, "\n");

      if (kb0)
      {
         if (COMPLEX)
         {
            fprintf(fp, "   if (K <= %d)\n   {\n", kb0);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n", pre);
            fprintf(fp, "      ATL_%cJIK0x0x0TN0x0x0_a1_bX(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n", pre);
            fprintf(fp, "   }\n   else\n   {\n");
            fprintf(fp, "      mm = mmfunc[K-%d];\n", kb0+1);
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
            fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
            fprintf(fp, "   }\n");
         }
         else
         {
            fprintf(fp, "   if (K <= %d) ATL_%cJIK0x0x0TN0x0x0_a1%s(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0, pre, betnam);
            fprintf(fp, "   else mmfunc[K-%d](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n", kb0+1);
         }
      }
      else if (COMPLEX)
      {
         fprintf(fp, "      mm = mmfunc+K-1;\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B, ldb, -beta, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A, lda, B+N*ldb, ldb, beta, C+1, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B+N*ldb, ldb, -1.0, C, ldc);\n");
         fprintf(fp, "      mm(M, N, K, alpha, A+M*lda, lda, B, ldb, 1.0, C+1, ldc);\n");
      }
      else fprintf(fp, "   mmfunc[K-1](M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);\n");
   }
   fprintf(fp, "}\n");
   fclose(fp);
/*
 * Generate required KB-specific codes
 */
   for (j=0, i=nb; i > kb0; j++, i--)
   {
      ncucases = 0;
      sprintf(fnam, "CLEANUP/ATL_%cpKBmm%d.c", pre, i);
      fp = fopen(fnam, "w");
      assert(fp);
      emit_mm(fp, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
              1, muladd, lats[j], ForceFetch, ifetch, nfetch, 0, 0, i, mu, nu, 
              kus[j], mulA, mulB, mulC, i, i, 0, 1, beta);
      fclose(fp);
   }
   if (kb0 != 0)
   {
      ncucases = 0;
      sprintf(fnam, "CLEANUP/ATL_%cpKBmm0.c", pre);
      fp = fopen(fnam, "w");
      assert(fp);
      lat = GetGoodLat(muladd, mu, nu, 1, lat);
      emit_mm(fp, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
              1, muladd, lat, ForceFetch, ifetch, nfetch, 0, 0, 0, mu, nu, ku,
              mulA, mulB, mulC, 0, 0, 0, 1, beta);
      fclose(fp);
   }
   GenMakefile(pre, nb, kb0, 3, bnams);
}
@endskip

void GenMNBcase(char *spc, char MN, char pre, char *type, int beta, char *bnam)
{
   const int COMPLEX = (pre == 'c' || pre == 'z');
   const int csA=1, csB=1, csC = ( COMPLEX ? 2 : 1 );
   char fnam[128], callee[128], caller[128];
   int muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch;
   double mflop;
   FILE *fpout;

   sprintf(fnam, "res/%cClean%c", pre, MN);
   GetInstLogFile(fnam, pre, &muladd, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   mb = kb = nb;
   if (MN == 'M') mb = 0;
   else nb = 0;

   sprintf(fnam, "CLEANUP/ATL_%cp%cBmm%s.c", pre, MN, bnam);
   fpout = fopen(fnam, "w");
   assert(fpout);
   if (!COMPLEX)
      fprintf(fpout,"#define ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1%s ATL_%cp%cBmm%s\n",
              pre, mb, nb, kb, kb, kb, 0, bnam, pre, MN, bnam);
   ncucases = 0;
   emit_mm(fpout, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans,
           1, muladd, lat, ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku,
           csA, csB, csC, kb, kb, 0, 1, beta);
   if (COMPLEX)
   {
      sprintf(caller, "ATL_%cp%cBmm%s", pre, MN, bnam);
      sprintf(callee, "ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1", 
              pre, mb, nb, kb, kb, kb, 0);
      ComplexWrap(fpout, type, caller, callee, beta);
   }
   fclose(fpout);
}

void GenMNClean(char *spc, char pre, char *type)
{
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int betas[3] = {1, 0, 8};
   int i;

   for (i=0; i < 3; i++)
   {
      GenMNBcase(spc, 'M', pre, type, betas[i], bnams[i]);
      GenMNBcase(spc, 'N', pre, type, betas[i], bnams[i]);
   }
}

void DoClean(char *spc, char pre, char *type)
{
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   GenKBmm(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   GenMNClean(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
}


@beginskip
void GenMCleanup(char *spc, char pre, char *type, int COMPLEX,
                 enum ATLAS_LOOP_ORDER LoopOrder,
                 int muladd, int lat, int ForceFetch, int ifetch, int nfetch, 
                 int M, int N, int K, int mu, int nu, int ku, 
                 int csA, int csB, int csC, int beta, char *bnam)
{
   char fnam[128], callee[128], caller[128];
   FILE *fpout;

   sprintf(fnam, "CLEANUP/ATL_%cpMBmm%s.c", pre, bnam);
   fpout = fopen(fnam, "w");
   assert(fpout);
   if (!COMPLEX)
      fprintf(fpout, "#define ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1%s ATL_%cpMBmm%s\n",
              pre, 0, N, K, K, K, 0, bnam, pre, bnam);
   ncucases = 0;
   emit_mm(fpout, spc, pre, type, "", LoopOrder, AtlasTrans, AtlasNoTrans,
           1, muladd, lat, ForceFetch, ifetch, nfetch, 0, N, K, mu, nu, ku,
           csA, csB, csC, K, K, 0, 1, beta);
   if (COMPLEX)
   {
      sprintf(caller, "ATL_%cpMBmm%s", pre, bnam);
      sprintf(callee, "ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1", 
              pre, 0, N, K, K,K, 0);
      ComplexWrap(fpout, type, caller, callee, beta);
   }
   fclose(fpout);
}
void GenNCleanup(char *spc, char pre, char *type, int COMPLEX,
                 enum ATLAS_LOOP_ORDER LoopOrder,
                 int muladd, int lat, int ForceFetch, int ifetch, int nfetch, 
                 int M, int N, int K, int mu, int nu, int ku, 
                 int csA, int csB, int csC, int beta, char *bnam)
{
   char fnam[128], callee[128], caller[128];
   FILE *fpout;

   sprintf(fnam, "CLEANUP/ATL_%cpNBmm%s.c", pre, bnam);
   fpout = fopen(fnam, "w");
   assert(fpout);
   if (!COMPLEX)
      fprintf(fpout, "#define ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1%s ATL_%cpNBmm%s\n",
              pre, M, 0, K, K, K, 0, bnam, pre, bnam);
   ncucases = 0;
   emit_mm(fpout, spc, pre, type, "", LoopOrder, AtlasTrans, AtlasNoTrans,
           1, muladd, lat, ForceFetch, ifetch, nfetch, M, 0, K, mu, nu, ku,
           csA, csB, csC, K, K, 0, 1, beta);
   if (COMPLEX)
   {
      sprintf(caller, "ATL_%cpNBmm%s", pre, bnam);
      sprintf(callee, "ATL_%cJIK%dx%dx%dTN%dx%dx%d_a1", 
              pre, M, 0, K, K,K, 0);
      ComplexWrap(fpout, type, caller, callee, beta);
   }
   fclose(fpout);
}

void GenKCleanup(char *spc, char pre, char *type, int COMPLEX,
                 enum ATLAS_LOOP_ORDER LoopOrder,
                 int muladd, int lat, int ForceFetch, int ifetch, int nfetch, 
                 int M, int N, int K, int mu, int nu, int ku, 
                 int csA, int csB, int csC, int beta, char *bnam)
{
   ncucases = 0;
   GenKBmm(spc, pre, type, muladd, lat, ForceFetch, ifetch, nfetch, K,
           mu, nu, ku, csA, csB, csC, beta, bnam);
}

void GenMNClean(char *spc,char pre, char *type, enum ATLAS_LOOP_ORDER LoopOrder,
                int muladd, int lat, int ForceFetch, int ifetch, int nfetch, 
                int M, int N, int K, int mu, int nu, int ku, 
                int csA, int csB, int csC)
{
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int betas[3] = {1, 0, 8};
   int i, COMPLEX;

   COMPLEX = (pre == 'z' || pre == 'c');
   for (i=0; i < 3; i++)
   {
      GenMCleanup(spc, pre, type, COMPLEX, LoopOrder, muladd, lat, ForceFetch, 
                  ifetch, nfetch, M, N, K, mu, nu, ku, csA, csB, csC, 
                  betas[i], bnams[i]);
      GenNCleanup(spc, pre, type, COMPLEX, LoopOrder, muladd, lat, ForceFetch, 
                  ifetch, nfetch, M, N, K, mu, nu, ku, csA, csB, csC, 
                  betas[i], bnams[i]);
   }
}
int GenKClean(char *spc, char pre, char *type, enum ATLAS_LOOP_ORDER LoopOrder,
              int muladd, int lat, int ForceFetch, int ifetch, int nfetch, 
              int M, int N, int K, int mu, int nu, int ku, 
              int csA, int csB, int csC)
{
   char fnam[64], caller[128], callee[128], bnam[16];
   char *bnams[3] = {"_b1", "_b0", "_bX"};
   int betas[3] = {1, 0, 8};
   FILE *fpout;
   int COMPLEX;
   COMPLEX = (pre == 'z' || pre == 'c');

   GenKCleanup(spc, pre, type, COMPLEX, LoopOrder, muladd, lat, ForceFetch, 
               ifetch, nfetch, M, N, K, mu, nu, ku, csA, csB, csC, 
               8, "_bX");
}
@endskip

int DoNocopyTT(char *spc, char pre, char *type, char cTA, char cTB)
{
   char fnam[128];
   const int COMPLEX = (pre == 'c' || pre == 'z');
   char *bnams[3] = {"_b0", "_b1", "_bX"}, *anams[2] = {"_a1", "_aX"};
   int betas[3] = {0, 1, 8}, alphas[2] = {1, 8};
   int NB, muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch;
   int mul=1, i, j;
   enum ATLAS_TRANS TA, TB;
   double mflop;
   FILE *fp;

   if (cTA == 'N') TA = AtlasNoTrans;
   else TA = AtlasTrans;
   if (cTB == 'N') TB = AtlasNoTrans;
   else TB = AtlasTrans;

   if (COMPLEX) { sprintf(fnam, "res/%cNCNB", pre);  mul = 2; }
   else sprintf(fnam, "res/%cNB", pre);
   fp = fopen(fnam, "r");
   assert(fp);
   if (!COMPLEX) fscanf(fp, " %d", &NB);  /* ignore number of NBs */
   fscanf(fp, " %d", &NB);
   fclose(fp);

   sprintf(fnam, "res/%cbest%c%c_%dx%dx%d", pre, cTA, cTB, NB, NB, NB);
   GetInstLogFile(fnam, pre, &muladd, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   mb = kb = nb;
   for (j=0; j < 2; j++)
   {
      for (i=0; i < 3; i++)
      {
         sprintf(fnam, "ATL_%cNCmm%c%c%s%s.c", pre, cTA, cTB, 
                  anams[j], bnams[i]);
         fp = fopen(fnam, "w");
         assert(fp);
         ncucases = 0;
         emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, lat,
                 ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul,
                 0, 0, 0, alphas[j], betas[i]);
         fclose(fp);
      }
   }

   sprintf(fnam, "res/%cbest%c%c_0x0x%d", pre, cTA, cTB, NB);
   GetInstLogFile(fnam, pre, &muladd, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   kb = nb;
   mb = nb = 0;
   sprintf(fnam, "ATL_%cNCCUmm%c%c_K.c", pre, cTA, cTB);
   fp = fopen(fnam, "w");
   assert(fp);
   ncucases = 0;
   emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, lat, 
           ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul, 
           0, 0, 0, 8, 8);
   fclose(fp);

   sprintf(fnam, "res/%cbest%c%c_0x0x0", pre, cTA, cTB);
   GetInstLogFile(fnam, pre, &muladd, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   kb = mb = nb = 0;
   sprintf(fnam, "ATL_%cNCCUmm%c%c.c", pre, cTA, cTB);
   fp = fopen(fnam, "w");
   assert(fp);
   ncucases = 0;
   emit_mm(fp, spc, pre, type, "", AtlasJIK, TA, TB, 1, muladd, lat, 
           ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku, mul, mul, mul, 
           0, 0, 0, 8, 8);
   fclose(fp);
   return(NB);
}

void DoNocopy(char *spc, char pre, char *type)
{
   char fnam[128];
   int muladd, lat, NB, nb, mu, nu, ku, ffetch, ifetch, nfetch;
   double mflop;
   FILE *fp;

   DoNocopyTT(spc, pre, type, 'N', 'N');
   DoNocopyTT(spc, pre, type, 'N', 'T');
   DoNocopyTT(spc, pre, type, 'T', 'N');
   NB = DoNocopyTT(spc, pre, type, 'T', 'T');

   sprintf(fnam, "res/%cMMRES", pre);
   GetInstLogFile(fnam, pre, &muladd, &lat, &nb, &mu, &nu, &ku, 
                  &ffetch, &ifetch, &nfetch, &mflop);
   sprintf(fnam, "atlas_%cNCmm.h", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   emit_head(1, fp, pre, NB, muladd, lat, mu, nu, ku);
   fclose(fp);
}

void GetMMRES(char pre, int *nreg, int *muladd, int *lat, int *nb,
              int *mu, int *nu, int *ku, int *ff, int *iff, int *nf,
              double *mf, char *ufile, char *auth, int *ma0, int *lat0,
              int *mu0, int *nu0, int *ku0, double *mf0)
{
   int h, i, j, k;
   char ln[256];
   FILE *fp;

   sprintf(ln, "res/%cMMRES", pre);
   fp = fopen(ln, "r");
   assert(fp);
   fgets(ln, 256, fp);
   fgets(ln, 256, fp);
   assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %f", muladd, lat, nb,
                 mu, nu, ku, ff, iff, nf, mf) == 10);
   fgets(ln, 256, fp);
   assert(sscanf(ln, " %d", &nreg) == 1);
   if ( fgets(ln, 256, fp) )  /* user-supplied GEMM was best */
   {
      assert(sscanf(ln, "%s \"%[^\"]\n", ufile, auth) == 2);
      fgets(ln, 256, fp);
      assert(sscanf(ln, " %d %d %d %d %d %d %d %d %d %f", ma0, lat0, &h,
                    mu0, nu0, ku0, &i, &j, &k, mf0) == 10);
   }
   else ufile[0] = auth[0] = '\0';
   fclose(fp);
}

void DoNBmm(char *spc, char pre, char *type)
{
   char fnam[128], ln[256];
   char *bnams[3] = {"_b0", "_b1", "_bX"};
   int betas[3] = {0, 1, 8};
   int i, muladd, lat, mb, nb, kb, mu, nu, ku, ffetch, ifetch, nfetch;
   int nreg, maU, latU, muU, nuU, kuU;
   int mulC = 1;
   double mflop, mfU;
   FILE *fp;

   if (pre == 'c' || pre == 'z') mulC = 2;

   GetMMRES(pre, &nreg, &muladd, &lat, &nb, &mu, &nu, &ku, &ffetch, &ifetch, 
            &nfetch, &mflop, ln, fnam, &maU, &latU, &muU, &nuU, &kuU, &mfU);
   kb = mb = nb;
   if (ln[0] != '\0') sprintf(fnam, "../CASES/%s", ln);
   else fnam[0] = '\0';
   for (i=0; i < 3; i++)
   {
      sprintf(ln, "ATL_%cNBmm%s.c", pre, bnams[i]);
      fp = fopen(ln, "w");
      assert(fp);
      ncucases = 0;
      if (fnam[0] == '\0')
      {
         emit_mm(fp, spc, pre, type, "", AtlasJIK, AtlasTrans, AtlasNoTrans, 0,
                 muladd, lat, ffetch, ifetch, nfetch, mb, nb, kb, mu, nu, ku,
                 1, 1, mulC, kb, kb, 0, 1, betas[i]);
         fclose(fp);
      }
      else
      {
         emit_uhead(fp, pre, mb, nb, kb, betas[i]);
         fclose(fp);
         sprintf(ln, "cat %s >> ATL_%cNBmm%s.c\n", fnam, pre, bnams[i]);
         assert(system(ln) == 0);
      }
   }
   ncucases = 0;
   sprintf(fnam, "%cmm.h", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   emit_head(0, fp, pre, nb, muladd, lat, mu, nu, ku);
   fclose(fp);
}

void DoInstall(char *spc, char pre, char *type)
{
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   DoNBmm(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   DoNocopy(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
   DoClean(spc, pre, type);
fprintf(stderr, "line %d of %s\n", __LINE__, __FILE__);
}
void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -p <pre> -muladd <0/1> -ta <n/t> -tb <n/t> -l <lat> -m <mu> -n <nu> -k <ku> -M <MB> -N <NB> -K <KB> -lda <lda> -ldb <ldb> -ldc <ldc> -csA <col stride A> -csB <csb> -csC <csC> -a <alpha> -b <beta> -L <IJK/JIK> -f <file> -F0 <init fetch> -FN <nfetch> -FF <0/1> -Cleanup <0/1> -Z <0/1> -R <0/nb0> \n", nam);
   exit(-1);
}
void GetFlags(int nargs, char **args, FILE **fpout, char *pre, int *CleanUp,
              int *muladd, int *ForceFetch, int *ifetch, int *nfetch, 
              enum ATLAS_LOOP_ORDER *LoopOrder, 
              enum ATLAS_TRANS *TA, enum ATLAS_TRANS *TB, int *lat, 
              int *mu, int *nu, int *ku, int *M, int *N, int *K, 
              int *lda, int *ldb, int *ldc, int *csA, int *csB, int *csC, 
              int *alpha, int *beta, int *CplxTst, int *rout)
{
   int i;

/*
 * Defaults
 */
   *muladd = 0;
   *ForceFetch = 0;
   *CleanUp = 0;
   *pre = 'd';
   *fpout = stdout;
   *LoopOrder = AtlasJIK;
   *ifetch = *nfetch = -1;
   *TA = AtlasTrans;
   *TB = AtlasNoTrans;
   *lat = 4;
   *mu = 4;
   *nu = 4;
   *ku = 1;
   *M = *N = *K = 0;
   *lda = *ldb = *ldc = 0;
   *csA = *csB = *csC = 1;
   *alpha = *beta = 1;
   *CplxTst = 0;
   *rout = -1;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'R':
         *rout = atoi(args[++i]);
         break;
      case 'C':
         *CleanUp = atoi(args[++i]);
         break;
      case 'Z':
         *CplxTst = atoi(args[++i]);
         break;
      case 'p':
         *pre = tolower(args[++i][0]);
         if (*pre != 'd' && *pre != 's' && *pre != 'c' && *pre != 'z')
            PrintUsage(args[0]);
         break;
      case 'L':
         i++;
         if (tolower(args[i][0]) == 'i') *LoopOrder = AtlasIJK;
         else if (tolower(args[i][0]) == 'j') *LoopOrder = AtlasJIK;
         else PrintUsage(args[0]);
         if ( (tolower(args[i][1]) != 'i' && tolower(args[i][1]) != 'j') ||
              (tolower(args[i][2]) != 'k') )
            PrintUsage(args[0]);
         break;
      case 'f':
         *fpout = fopen(args[++i], "w");
         assert(*fpout);
         break;
      case 'F':
         switch(tolower(args[i][2]))
         {
         case '0':
            *ifetch = atoi(args[++i]);
            break;
         case 'n':
            *nfetch = atoi(args[++i]);
            break;
         case 'f':
            *ForceFetch = atoi(args[++i]);
            break;
         default:
            fprintf(stderr, "What the heck: flag=%s %s???\n", 
                    args[i], args[i+1]);
            PrintUsage(args[0]);
         }
         break;
      case 'a':
         *alpha = atoi(args[++i]);
         break;
      case 'b':
         *beta  = atoi(args[++i]);
         break;
      case 'm':
         if (args[i][2] == 'u') *muladd = atoi(args[++i]);
         else *mu = atoi(args[++i]);
         break;
      case 't':
         if (args[i][2] == 'a' || args[i][2] == 'A')
         {
            i++;
            if (args[i][0] == 'n' || args[i][0] == 'N') *TA = AtlasNoTrans;
            else if (args[i][0] == 't' || args[i][0] == 'T') *TA = AtlasTrans;
            else
            {
               fprintf(stderr, "What the hell: TA = ???%s???\n", args[i]);
               PrintUsage(args[0]);
            }
         }
         else if (args[i][2] == 'b' || args[i][2] == 'B')
         {
            i++;
            if (args[i][0] == 'n' || args[i][0] == 'N') *TB = AtlasNoTrans;
            else if (args[i][0] == 't' || args[i][0] == 'T') *TB = AtlasTrans;
            else
            {
               fprintf(stderr, "What the hell: TB = ???%s???\n", args[i]);
               PrintUsage(args[0]);
            }
         }
         else PrintUsage(args[0]);
         break;
      case 'l':
         if (args[i][2] == '\0') *lat = atoi(args[++i]);
         else if (tolower(args[i][2]) != 'd') PrintUsage(args[0]);
         else
         {
            switch(tolower(args[i][3]))
            {
            case 'a': 
               *lda = atoi(args[++i]);
               break;
            case 'b':
               *ldb = atoi(args[++i]);
               break;
            case 'c':
               *ldc = atoi(args[++i]);
               break;
            default:
               fprintf(stderr, "What the heck: flag=%s %s???\n", 
                       args[i], args[i+1]);
               PrintUsage(args[0]);
            }
         }
         break;
      case 'n':
         *nu = atoi(args[++i]);
         break;
      case 'k':
         *ku = atoi(args[++i]);
         break;
      case 'M':
         *M = atoi(args[++i]);
         break;
      case 'N':
         *N = atoi(args[++i]);
         break;
      case 'K':
         *K = atoi(args[++i]);
         break;
      case 'c':
         if (args[i][2] != 's') PrintUsage(args[0]);
         switch (tolower(args[i][3]))
         {
         case 'a':
            *csA = atoi(args[++i]);
            break;
         case 'b':
            *csB = atoi(args[++i]);
            break;
         case 'c':
            *csC = atoi(args[++i]);
            break;
         default:
            fprintf(stderr, "What the heck: flag=%s %s???\n", 
                    args[i], args[i+1]);
            PrintUsage(args[0]);
         }
         break;
      }
   }
}

main(int nargs, char **args)
{
   char *spcs = "                                                            ";
   char *spc = spcs+60;
   char pre, *type;
   FILE *fpout;
   enum ATLAS_TRANS TA, TB;
   enum ATLAS_LOOP_ORDER LoopOrder;
   int muladd, lat, mu, nu, ku, M, N, K, lda, ldb, ldc, csA, csB, csC;
   int alpha, beta, ifetch, nfetch, CleanUp, ForceFetch, CplxTst, rout;

   GetFlags(nargs, args, &fpout, &pre, &CleanUp, &muladd, &ForceFetch, 
            &ifetch, &nfetch, &LoopOrder, &TA, &TB, &lat, &mu, &nu, &ku, 
            &M, &N, &K, &lda, &ldb, &ldc, &csA, &csB, &csC, &alpha, &beta,
            &CplxTst, &rout);
   if (mu == 1 && nu == 1 && ku == 1 && K == 0 && muladd == 0) muladd = 1;
   fprintf(stderr, "pre=%c, CU=%d, ma=%d, ff=%d, if=%d, nf=%d, lo=%d, ta=%d, tb=%d, lat=%d, mu=%d, nu=%d, ku=%d, m=%d, n=%d, k=%d, lda=%d, ldb=%d, ldc=%d, csA=%d, csB=%d, csC=%d, alpha=%d, beta=%d\n\n", 
           pre, CleanUp, muladd, ForceFetch, ifetch, nfetch, LoopOrder, TA, TB,
           lat, mu, nu, ku, M, N, K, lda, ldb, ldc, csA, csB, csC, alpha, beta);
   switch (pre)
   {
      case 'd':
      case 'z':
         type = "double";
         break;
      case 's':
      case 'c':
         type = "float";
         break;
   }
   if (ifetch == -1) ifetch = mu + nu;
   if (rout == -2) DoInstall(spc, pre, type);
   else if (rout == -3) emit_uhead(fpout, pre, M, N, K, beta);
   else
   {
      emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, muladd,
              lat, ForceFetch, ifetch, nfetch, M, N, K, mu, nu, ku, 
              csA, csB, csC, lda, ldb, ldc, alpha, beta);
/*      if (CplxTst && (pre == 'c' || pre == 'z') && M && N && K) */
      if (CplxTst && (pre == 'c' || pre == 'z'))
      {
         ncucases=0;
         if (beta == 1 || beta == 0)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 8);
         ncucases=0;
         if (beta != 1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
@beginskip
         if (beta == 1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, -1);
         else if (beta == -1)
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp, 
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K, 
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
   
         if (beta != 1 && beta != -1)
         {
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, -1);
            ncucases=0;
            emit_mm(fpout, spc, pre, type, "", LoopOrder, TA, TB, CleanUp,
                    muladd, lat, ForceFetch, ifetch, nfetch, M, N, K,
                    mu, nu, ku, csA, csB, csC, lda, ldb, ldc, alpha, 1);
         }
@endskip
      }
   }
   exit(0);
}
@ROUT emit_head emit_r1h
int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
      assert(L1f != NULL);
   }
   fscanf(L1f, "%d", &L1Size);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT emit_r1h
void emit_r1head(char pre, double l1mul, int flag, int mu, int nu)
{
   char fnam[64];
   int l1;
   FILE *fp;

   l1 = 1024 * GetL1CacheSize();
   if (pre == 's') l1 /= ATL_ssize;
   else if (pre == 'd') l1 /= ATL_dsize;
   else if (pre == 'c') l1 /= ATL_csize;
   else if (pre == 'z') l1 /= ATL_zsize;
   l1 = l1mul * l1;

   sprintf(fnam, "atlas_%cr1.h", pre);
   fp = fopen(fnam, "w");
   fprintf(fp, "#ifndef ATLAS_%cR1_H\n", toupper(pre));
   fprintf(fp, "#define ATLAS_%cR1_H\n\n", toupper(pre));

   if ( ATL_NoBlock(flag) ) fprintf(fp, "#define ATL_R1NOBLOCK\n");
   fprintf(fp, "#define ATL_L1r1elts %d\n", l1);
   fprintf(fp, "#define ATL_r1MU %d\n", mu);
   fprintf(fp, "#define ATL_r1NU %d\n", nu);
   fprintf(fp, "\n");

   fprintf(fp, "#define ATL_GetPartR1(A_, lda_, mb_, nb_) \\\n{ \\\n");
   fprintf(fp, "   (mb_) = (ATL_L1r1elts - (ATL_r1NU+ATL_r1NU)) / (ATL_r1NU+ATL_r1NU+1); \\\n");
   fprintf(fp, 
      "   if ((mb_) > ATL_r1MU) (mb_) = ATL_r1MU*((mb_)/ATL_r1MU); \\\n");
   fprintf(fp, "   else (mb_) = ATL_r1MU; \\\n");
   fprintf(fp, "   (nb_) = ATL_r1NU; \\\n");
   fprintf(fp, "}\n");

   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -p <pre> -l <l1mul> -x <xu> -y <yu> -f <flag>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, double *l1mul, 
              int *xu, int *yu, int *iflag)
{
   int i, j;

   *pre = 'd';
   *l1mul = 0.75;
   *xu = 16;
   *yu = 2;
   *iflag = 0;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p' :
         i++;
         *pre = Mlowcase(args[i][0]);
         break;
      case 'l':
         *l1mul = atoi(args[++i])/100.0;
         break;
      case 'x':
         *xu = atoi(args[++i]);
         break;
      case 'y':
         *yu = atoi(args[++i]);
         break;
      case 'f':
         *iflag = atoi(args[++i]);
         break;
      }
   }
}

main(int nargs, char **args)
{
   double l1mul;
   int xu, yu, iflag;
   char pre;
   GetFlags(nargs, args, &pre, &l1mul, &xu, &yu, &iflag);
   emit_r1head(pre, l1mul, iflag, xu, yu);
   exit(0);
}

@ROUT emit_head
int GetL1Elts(char pre, double l1mul)
{
   int l1;
   l1 = 1024 * GetL1CacheSize();
   if (pre == 's') l1 /= ATL_ssize;
   else if (pre == 'd') l1 /= ATL_dsize;
   else if (pre == 'c') l1 /= ATL_csize;
   else if (pre == 'z') l1 /= ATL_zsize;
   l1 = l1mul * l1;
   return(l1);
}
void emit_mvhead(char pre, int l1mul)
{
   char fnam[64];
   int l1;
   FILE *fp;

   l1 = GetL1Elts(pre, 0.01*l1mul);
   sprintf(fnam, "atlas_%cmv.h", pre);
   fp = fopen(fnam, "w");
   fprintf(fp, "#ifndef ATLAS_%cMV_H\n", toupper(pre));
   fprintf(fp, "#define ATLAS_%cMV_H\n\n", toupper(pre));

   fprintf(fp, "#define ATL_L1mvelts %d\n", l1);
   fprintf(fp, "#include \"atlas_%cmvN.h\"\n", pre);
   fprintf(fp, "#include \"atlas_%cmvT.h\"\n", pre);
   fprintf(fp, "#include \"atlas_%cmvS.h\"\n", pre);

   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

void emit_transhead(char pre, char TA, int flag, int mu, int nu, int l1mul)
{
   char fnam[128];
   FILE *fp;
   int l1, mb;

   l1 = GetL1Elts(pre, 0.01*l1mul);
   sprintf(fnam, "atlas_%cmv%c.h", pre, TA);
   fp = fopen(fnam, "w");
   assert(fp);
   fprintf(fp, "#ifndef ATLAS_MV%c_H\n", TA);
   fprintf(fp, "#define ATLAS_MV%c_H\n\n", TA);

   fprintf(fp, "#include \"atlas_misc.h\"\n");
   if (ATL_MVIsMM(flag))
   {
      fprintf(fp, "#include \"atlas_%cNCmm.h\"\n", pre);
      fprintf(fp, "#include \"atlas_lvl3.h\"\n");
   }
   fprintf(fp, "\n");

   if (!ATL_MVIsMM(flag))
   {
      fprintf(fp, "#define ATL_mv%cMU %d\n", TA, mu);
      fprintf(fp, "#define ATL_mv%cNU %d\n", TA, nu);
   }
   else
   {
      fprintf(fp, "#define ATL_mv%cMU ATL_mmMU\n", TA);
      fprintf(fp, "#define ATL_mv%cNU NB\n", TA);
      fprintf(fp, "#define ATL_mv%cCallsGemm\n", TA);
   }
   if (ATL_MVNoBlock(flag)) fprintf(fp, "#define ATL_mv%cNOBLOCK\n", TA);
   fprintf(fp, "#ifndef ATL_L1mvelts\n");
   fprintf(fp, "   #define ATL_L1mvelts ((3*ATL_L1elts)>>2)\n");
   fprintf(fp, "#endif\n");

   if (TA == 'S') /* symm/hemm stuff */
   {
      fprintf(fp, "#ifndef ATL_mvNNU\n");
      fprintf(fp, "   #include \"atlas_%cmvN.h\"\n", pre);
      fprintf(fp, "#endif\n");
      fprintf(fp, "#ifndef ATL_mvTNU\n");
      fprintf(fp, "   #include \"atlas_%cmvT.h\"\n", pre);
      fprintf(fp, "#endif\n");
      if (ATL_MVIsMM(flag))
      {
         fprintf(fp, 
         "#define ATL_GetPartSYMV(A_, lda_, mb_, nb_) *(mb_) = *(nb_) = NB \n");
      }
      else if (ATL_MVIsAxpy(flag))
      {
         fprintf(fp,
                 "#define ATL_GetPartSYMV(A_, lda_, mb_, nb_) \\\n{ \\\n");
         fprintf(fp, "   *(nb_) = ATL_mvSMU; \\\n");
         mb = (l1/2 - mu)/(mu+1);
         if (mb > 2*nu) mb = (mb/(2*nu))*nu;
         else mb = nu;
         fprintf(fp, "   *(mb_) = %d; \\\n}\n", mb);
      }
      else
      {
         fprintf(fp,"#define ATL_GetPartSYMV(A_, lda_, mb_, nb_) \\\n{ \\\n");
         fprintf(fp, "   for(*(nb_)=ATL_mvNNU; (*(nb_))*(*(nb_))+((*(nb_))<<2) + ATL_mvTMU*(*(nb_)+2) < ATL_L1mvelts; *(nb_) += ATL_mvNNU); \\\n");
         fprintf(fp, 
               "   *(mb_) = Mmax(ATL_mvTNU, ATL_mvNMU) + *(nb_); \\\n");
         fprintf(fp, 
         "   *(mb_) = ( ATL_L1mvelts - ((*(mb_))<<1) ) / (*(mb_) + 2); \\\n");
         fprintf(fp,
   "   if (*(mb_) > ATL_mvTNU) *(mb_) = (*(mb_)/ATL_mvTNU)*ATL_mvTNU; \\\n");
         fprintf(fp, "   else *(mb_) = ATL_mvTNU; \\\n");
         fprintf(fp, "}\n");
      }
   }
   else if (TA == 'N')
   {
      if (ATL_MVIsAxpy(flag)) fprintf(fp, "#define ATL_AXPYMV\n");
      else if (nu < 32)
      {
         fprintf(fp, "#ifndef ATL_mvpagesize\n");
         fprintf(fp, "   #define ATL_mvpagesize ATL_DivBySize(4096)\n");
         fprintf(fp, "#endif\n");
         fprintf(fp, "#ifndef ATL_mvntlb\n");
         fprintf(fp, "   #define ATL_mvntlb 56\n");
         fprintf(fp, "#endif\n");
      }
   
      fprintf(fp, "\n#define ATL_GetPartMVN(A_, lda_, mb_, nb_) \\\n{ \\\n");
      if (ATL_MVIsAxpy(flag))
      {
       
         fprintf(fp, 
"   *(mb_) = (ATL_L1mvelts - (ATL_mvNNU<<1)) / ((ATL_mvNNU<<1)+1); \\\n");
@beginskip
         fprintf(fp, 
"   *(mb_) = (ATL_L1mvelts - ATL_mvNNU*(ATL_mvNNU+2)) / (ATL_mvNNU+1); \\\n");
@endskip
         fprintf(fp, 
"   if (*(mb_) > ATL_mvNMU) *(mb_) = ATL_mvNMU*( *(mb_)/ATL_mvNMU ); \\\n");
         fprintf(fp, "   else *(mb_) = ATL_mvNMU; \\\n");
         fprintf(fp, "   *(nb_) = ATL_mvNNU; \\\n");
      }
@skip      else if (ATL_MVNoBlock(flag)) /* do no blocking */
@skip         fprintf(fp, "   *(mb_) = (lda_); *(nb_) = 100000; \\\n");
      else if (nu >= 32)
      {
         fprintf(fp, "   *(nb_) = ATL_mvNNU; \\\n");
         fprintf(fp, 
"   *(mb_) = (ATL_L1mvelts - ATL_mvNNU - (ATL_mvNNU+1)*ATL_mvNMU) / (ATL_mvNNU+1); \\\n");
         fprintf(fp, 
"   if (*(mb_) > ATL_mvNMU) *(mb_) = (*(mb_) / ATL_mvNMU)*ATL_mvNMU; \\\n");
         fprintf(fp, "   else *(mb_) = ATL_mvNMU; \\\n");
      }
      else if (ATL_MVIsMM(flag)) /* gemv calls gemm */
      {
         fprintf(fp, 
            "   *(mb_) = (ATL_L1mvelts - (ATL_mmMU+1)*NB) / (NB + 2); \\\n");
         fprintf(fp, 
         "   if (*(mb_) > NB) *(mb_) = ATL_MulByNB(ATL_DivByNB(*(mb_))); \\\n");
         fprintf(fp, 
         "   else if (*(mb_) < ATL_mmMU) *(mb_) = NB; \\\n");
         fprintf(fp, 
         "   else  *(mb_) = (*(mb_) / ATL_mmMU) * ATL_mmMU; \\\n");
         fprintf(fp, "   *(nb_) = NB; \\\n");
      }
      else
      {
         assert(mu && nu);
         fprintf(fp, 
"   *(nb_) = (ATL_L1mvelts - (ATL_mvNMU<<1)) / ((ATL_mvNMU<<1)+1); \\\n");
         fprintf(fp, "   if (ATL_mvpagesize > (lda_)) \\\n   { \\\n");
         fprintf(fp, 
            "      *(mb_) = (ATL_mvpagesize / (lda_)) * ATL_mvntlb; \\\n");
         fprintf(fp, 
            "      if ( *(mb_) < *(nb_) ) *(nb_) = *(mb_); \\\n");
         fprintf(fp, "   } \\\n");
         fprintf(fp, 
            "   else if (ATL_mvntlb < *(nb_)) *(nb_) = ATL_mvntlb; \\\n");
         fprintf(fp, 
"   if (*(nb_) > ATL_mvNNU) *(nb_) = (*(nb_) / ATL_mvNNU) * ATL_mvNNU; \\\n");
         fprintf(fp, "   else *(nb_) = ATL_mvNNU; \\\n");
         fprintf(fp, 
"   *(mb_) = (ATL_L1mvelts - *(nb_) * (ATL_mvNMU+1)) / (*(nb_)+2); \\\n");
         fprintf(fp, 
"   if (*(mb_) > ATL_mvNMU) *(mb_) = (*(mb_) / ATL_mvNMU) * ATL_mvNMU; \\\n");
         fprintf(fp, "   else *(mb_) = ATL_mvNMU; \\\n");
      }
      fprintf(fp, "}\n");
   }
   else
   {
      if (mu != 0)
      {
         fprintf(fp, "#ifndef ATL_mvNNU\n");
         fprintf(fp, "   #include \"atlas_%cmvN.h\"\n", pre);
         fprintf(fp, "#endif\n");
      }
      fprintf(fp, "\n");
      fprintf(fp, "#define ATL_GetPartMVT(A_, lda_, mb_, nb_) \\\n{ \\\n");
@skip      if (ATL_MVNoBlock(flag)) /* do no blocking */
@skip         fprintf(fp, "   *(mb_) = *(nb_) = 100000; \\\n}\n");
      if (mu == 0)
      {
         fprintf(fp, 
         "   *(mb_) = (ATL_L1mvelts - NB - ATL_mmMU*(NB+1)) / (NB+1); \\\n");
         fprintf(fp, "   if (*(mb_) > NB) \\\n   { \\\n");
         fprintf(fp, "      *(mb_) = ATL_MulByNB(ATL_DivByNB(*(mb_))); \\\n");
         fprintf(fp, "      *(nb_) = NB; \\\n   } \\\n");
         fprintf(fp, "   else \\\n   { \\\n");
         fprintf(fp, 
"      if (*(mb_) > ATL_mmMU) *(nb_) = (*(mb_) / ATL_mmMU)*ATL_mmMU; \\\n");
         fprintf(fp, "      else *(nb_) = ATL_mmMU; \\\n");
         fprintf(fp, "      *(mb_) = NB; \\\n   } \\\n");
         fprintf(fp, "}\n");
      }
      else
      {
         fprintf(fp, 
"   *(mb_) = (ATL_L1mvelts - (ATL_mvTMU<<1)) / ((ATL_mvTMU<<1)+1); \\\n");
         fprintf(fp, 
"   if (*(mb_) > ATL_mvTNU) *(mb_) = (*(mb_)/ATL_mvTNU)*ATL_mvTNU; \\\n");
         fprintf(fp, "   else (*mb_) = ATL_mvTNU; \\\n");
         fprintf(fp, "   *(nb_) = ATL_mvTMU; \\\n");
         fprintf(fp, "}\n");
      }
   }

   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, 
      "USAGE: %s -p <pre> -l <l1mul> -N/T/S [-x <xu> -y <yu> -f <flag> ]\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, int *l1mul, int *flagN,
              int *muN, int *nuN, int *flagT, int *muT, int *nuT, 
              int *flagS, int *muS, int *nuS)
{
   int NoTrans=1, i;

   *pre = 'd';
   *l1mul = 80;
   *flagS = *flagN = *flagT = 0;
   *muT = *muN = 16;
   *nuN = *nuT = 4;
   *muS = *nuS = -1;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p' :
         i++;
         *pre = Mlowcase(args[i][0]);
         break;
      case 'T':
         NoTrans = 0;
         break;
      case 'N':
         NoTrans = 1;
         break;
      case 'S':
         NoTrans = 2;
         break;
      case 'y':
         if (NoTrans == 1) *muN = atoi(args[++i]);
         else if (NoTrans == 2) *muS = atoi(args[++i]);
         else *muT = atoi(args[++i]);
         break;
      case 'x':
         if (NoTrans == 1) *nuN = atoi(args[++i]);
         else if (NoTrans == 2) *nuS = atoi(args[++i]);
         else *nuT = atoi(args[++i]);
         break;
      case 'f':
         if (NoTrans == 1) *flagN = atoi(args[++i]);
         else if (NoTrans == 2) *flagS = atoi(args[++i]);
         else *flagT = atoi(args[++i]);
         break;
      case 'l':
         *l1mul = atoi(args[++i]);
         break;
      default:
         fprintf(stderr, "Unknown flag = %s\n", args[i]);
         PrintUsage(args[0]);
      }
   }
   if (*muS == -1) *muS = *muT;
   if (*nuS == -1) *nuS = *nuT;
}

main(int nargs, char **args)
{
   int flagN, muN, nuN, flagT, muT, nuT, flagS, muS, nuS, l1mul;
   char pre;
   GetFlags(nargs, args, &pre, &l1mul, &flagN, &muN, &nuN, &flagT, &muT, &nuT,
            &flagS, &muS, &nuS);

   emit_mvhead(pre, l1mul);
   emit_transhead(pre, 'N', flagN, muN, nuN, l1mul);
   emit_transhead(pre, 'T', flagT, muT, nuT, l1mul);
   emit_transhead(pre, 'S', flagS, muS, nuS, l1mul);
   exit(0);
}
@ROUT emit_rmvT
static void GetAij(int nY, int ngap, int gap, int gapmul, int ia,
                   int *icol, int *igap, int *gapi, int *imul)
{ 
   ia = ia % (nY * ngap * gap * gapmul);
   *imul = ia / (nY * ngap * gap);
   ia -= *imul * nY * ngap * gap;
   *gapi = ia / (nY * ngap);
   ia -= *gapi * nY * ngap;
   *igap = ia / nY;
   ia -= *igap * nY;
   *icol = ia;
}

static int GetAi(int ngap, int gap, int igap, int gapi, int imul)
{
   return(imul*gap*ngap+igap*gap+gapi);
}

static void mvTXbody(FILE *fpout, char *spc, int lat, int nY, int ngap, int gap,
                     int gapmul, int pfA, int pfX, int Yregs, int CLEANUP)
{
   int i, j, k, nops, xelts, op=0;
   int FETCHA=1, FETCHX=1;
   int ia=pfA, ix=pfX, iy=0, myregs;
   int icol, iacc, igap, imul, Acol, Aacc, agap, Amul, xcol, xacc, xgap, xmul;

   nops = gapmul * gap * ngap * nY;
   xelts = gapmul * gap * ngap;
   if (lat)
   {
      op = lat;
      ix += lat/nY;
      if (ix > xelts) ix = ix % xelts;
   }

   for (i=0; i < nops; i++, ia++, iy++)
   {
      if (ia == nops)
      {
         ia = 0;
         for (j=0; j < nY; j++)
         {
            if (xelts > 1) fprintf(fpout, "%s   pA%d += %d;\n", spc, j, xelts);
            else fprintf(fpout, "%s   pA%d++;\n", spc, j);
         }
         if (CLEANUP) FETCHA = 0;
      }
      if (ix == xelts)
      {
         ix = 0;
         if (xelts > 1) fprintf(fpout, "%s   X += %d;\n", spc, xelts);
         else fprintf(fpout, "%s   X++;\n", spc);
         if (CLEANUP) FETCHX = 0;
      }
      GetAij(nY, ngap, gap, gapmul, i, &icol, &iacc, &igap, &imul);
      GetAij(nY, ngap, gap, gapmul, ia, &Acol, &Aacc, &agap, &Amul);
      myregs = Yregs / nY;
      if (icol < Yregs % nY) myregs++;
      if (lat)  /* seperate multiply & add code */
      {
         fprintf(fpout, "%s   rY%d += rA%d;\n", spc, 
                 icol+((iy/nY)%myregs)*nY, i %pfA);
         if (!CLEANUP || op < nops)
            fprintf(fpout, "%s   rA%d *= rX%d;\n", spc, op % pfA,
                    ((i+lat)/nY)%pfX);
      }
      else fprintf(fpout, "%s   rY%d += rA%d * rX%d;\n", 
                   spc, icol+((iy/nY)%myregs)*nY, i%pfA, (i/nY)%pfX);
      op++;
      if (FETCHA)
      {
         k = GetAi(ngap, gap, Aacc, agap, Amul);
         if (k) fprintf(fpout, "%s   rA%d = pA%d[%d];\n", spc, i%pfA, Acol, k);
         else fprintf(fpout, "%s   rA%d = *pA%d;\n", spc, i%pfA, Acol);
      }
@skip      if (icol == nY-1 && FETCHX)  /* used for muladd-only code */
      if (op%nY==0 && FETCHX)
      {
         GetAij(1, ngap, gap, gapmul, ix, &xcol, &xacc, &xgap, &xmul);
         k = GetAi(ngap, gap, xacc, xgap, xmul);
         if (k) fprintf(fpout, "%s   rX%d = X[%d];\n",spc, ((i+lat)/nY)%pfX, k);
         else fprintf(fpout, "%s   rX%d = *X;\n", spc, ((i+lat)/nY)%pfX);
         ix++;
      }
   }
}

static void FetchY(FILE *fpout, char *spc, int pre, int beta, int nY, int Yregs,
                   char *breg)
{
   int i, j;

   if (beta != 0)
   {
      fprintf(fpout, "%s   rY0 = *Y;\n", spc);
      for (j=1; j < nY; j++) fprintf(fpout, "%s   rY%d = Y[%d];\n", spc, j, j);
   }
   if (beta != 0 && beta != 1)
   {
      fprintf(fpout, "%s   %s = beta;\n", spc, breg);
      for (j=0; j < nY; j++) fprintf(fpout, "%s   rY%d *= %s;\n", spc,j, breg);
   }
   if (Yregs > nY || beta == 0)
   {
      fprintf(fpout, "%s   ", spc);
      for (i=(beta!=0)*nY; i < Yregs; i++) fprintf(fpout, "rY%d = ", i);
      if (pre == 's' || pre == 'c') fprintf(fpout, "0.0f;\n");
      else fprintf(fpout, "0.0;\n");
   }
}

static void FetchAX(FILE *fpout, char *spc, int nY, int ngap, int gap,
                    int gapmul, int pfA, int pfX)
{
   int ix, ia, icol, iacc, igap, imul, k;

   for (ix=0; ix < pfX; ix++) 
   {
      GetAij(1, ngap, gap, gapmul, ix, &icol, &iacc, &igap, &imul);
      k = GetAi(ngap, gap, iacc, igap, imul);
      if (k) fprintf(fpout, "%s   rX%d = X[%d];\n", spc, ix, k);
      else fprintf(fpout, "%s   rX%d = *X;\n", spc, ix);
   }
   for (ia = 0; ia < pfA; ia++)
   {
      GetAij(nY, ngap, gap, gapmul, ia, &icol, &iacc, &igap, &imul);
      k = GetAi(ngap, gap, iacc, igap, imul);
      if (k) fprintf(fpout, "%s   rA%d = pA%d[%d];\n", spc, ia, icol, k);
      else fprintf(fpout, "%s   rA%d = *pA%d;\n", spc, ia, icol);
   }
}

static void StartPipe(FILE *fpout, char *spc, int lat, int nY,
                      int ngap, int gap, int gapmul, int pfX)
{
   int i, k, icol, wgap, gapi, imul;

   for (i=0; i < lat; i++)
   {
      fprintf(fpout, "%s   rA%d *= rX%d;\n", spc, i, (i/nY)%pfX);
      if ((i+1) % nY == 0)
      {
         GetAij(1, ngap, gap, gapmul, pfX+i/nY, &icol, &wgap, &gapi, &imul);
         k = GetAi(ngap, gap, wgap, gapi, imul);
         if (k) fprintf(fpout, "%s   rX%d = X[%d];\n", spc, (i/nY)%pfX, k);
         else fprintf(fpout, "%s   rX%d = *X;\n", spc, (i/nY)%pfX);
      }
   }
}

static void CombY(FILE *fpout, char *spc, int nY, int Yregs)
/*
 * use binary tree for adding up multiple accumulators
 */
{
   int i, j, d, n=(Yregs+nY-1)/nY;
   for (d=1; d < n; d <<= 1)
      for (i=0; i < n; i += (d<<1))
         for (j=0; j < nY; j++)
            if (j+(i+d)*nY < Yregs)
               fprintf(fpout, "%s   rY%d += rY%d;\n", spc, j+i*nY, j+(i+d)*nY);
}

static void XCleanup(FILE *fpout, char *spc, char pre, int lat, int nY,
                     int ngap, int gap, int gapmul, int pfA, int pfX, int Yregs)
{
#if 1
   int mingap, j, ia, ix, iy, il, FirstTime=1;

   fprintf(fpout, "%s   if (X != stXN)\n%s   {\n", spc, spc);
   spc -= 3;
   if (pre == 's') mingap = 8;
   else mingap = 4;
   for (j=1; j < ngap*gap*gapmul; j <<= 1);
   if (j > ngap*gap*gapmul) /* not power of two */
   {
      if (GetPower2(gap))
      {
         if (!GetPower2(ngap)) ngap = 2;
         gapmul = j / (ngap*gap);
      }
      else
      {
         ngap = gapmul = 1;
         gap = j;
      }
   }
   if (j <= 2) FirstTime=0;
   for (; j; j >>= 1)
   {
      if (FirstTime)
         fprintf(fpout, "%s   if ( (ptrdiff_t)(stXN-X) < %d ) goto cu%d;\n", 
                 spc, j, j>>1);
      else if (j == 1)
         fprintf(fpout, "%s   if ( (ptrdiff_t)(stXN-X) == 1 )\n", spc);
      else fprintf(fpout, "%s   if ( (ptrdiff_t)(stXN-X) >= %d )\n", spc, j);
      for (ia=pfA; (nY*ngap*gap*gapmul) % ia; ia--);
      for (ix=pfX; (ngap * gap * gapmul)% ix; ix--);
      if (lat)
      {
         for (il=Mmin(ia,lat); (nY*ngap*gap*gapmul) % il; il--);
         if (lat - il > 2 || il < 2 || il < pfA) il = 0;
      }
      else il = 0;
      iy = Mmin(Yregs, nY*ngap*gap*gapmul);
      fprintf(fpout, 
"%s   { /* lat=%d, ngap=%d, gap=%d, gapmul=%d, pfA=%d, pfX=%d, yregs=%d */\n", 
              spc, il, ngap, gap, gapmul, ia, ix, iy);
      spc -= 3;
      FetchAX(fpout, spc, nY, ngap, gap, gapmul, ia, ix);
      if (il) StartPipe(fpout, spc, il, nY, ngap, gap, gapmul, pfX);
      mvTXbody(fpout, spc, il, nY, ngap, gap, gapmul, ia, ix, iy, 1);
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      if (FirstTime) fprintf(fpout, "cu%d:\n", j>>1);
      if (gapmul > 1) gapmul >>= 1;
      else if (ngap > 2) ngap >>= 1;
      else if (gap > mingap) gap >>= 1;
      else if (ngap > 1) ngap >>= 1;
      else if (gap > 1) gap >>= 1;
      FirstTime = 0;
   }
   spc += 3;
   fprintf(fpout, "%s   } /* done X cleanup */\n\n", spc);
#else
   int i;

   fprintf(fpout, "%s   if (X != stXN)\n%s   {\n", spc, spc);
   spc -= 3;
   if (nY == 1) i = 1;
   else for (i=pfA; nY % i; i--);
   FetchAX(fpout, spc, nY, 1, 1, 1, i, 1);

   fprintf(fpout, "%s   if (X != stXN_1)\n%s   {\n", spc, spc);
   spc -= 3;
   fprintf(fpout, "%s   do /* while (X != stXN_1) */\n%s   {\n", spc, spc);
   spc -= 3;
   mvTXbody(fpout, spc, lat, nY, 1, 1, 1, i, 1, nY, 0);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(X != stXN_1);\n", spc, spc);
   spc += 3;
   fprintf(fpout, "%s   }\n", spc);

   mvTXbody(fpout, spc, lat, nY, 1, 1, 1, i, 1, nY, 1);
   spc += 3;
   fprintf(fpout, "%s   } /* finish cleanup */\n\n", spc);
#endif
}

static void Xloop(FILE *fpout, char *spc, char pre, int lat, int nY,
                  int ngap, int gap, int gapmul, int pfA, int pfX, int Yregs)
{
   int i, nu = ngap * gap * gapmul;

   fprintf(fpout, "%s   if (N >= %d)\n%s   {\n", spc, 2*nu, spc);
   spc -= 3;
   FetchAX(fpout, spc, nY, ngap, gap, gapmul, pfA, pfX);
   if (lat) StartPipe(fpout, spc, lat, nY, ngap, gap, gapmul, pfX);
   fprintf(fpout, "%s   do /* while (X != stX) */\n%s   {\n", spc, spc);
   spc -= 3;
   mvTXbody(fpout, spc, lat, nY, ngap, gap, gapmul, pfA, pfX, Yregs, 0);
   spc += 3;
   fprintf(fpout, "%s   }\n%s   while(X != stX);\n", spc, spc);
   mvTXbody(fpout, spc, lat, nY, ngap, gap, gapmul, pfA, pfX, Yregs, 1);
   spc += 3;
   fprintf(fpout, "%s   }\n\n", spc);

   XCleanup(fpout, spc, pre, lat, nY, ngap, gap, gapmul, pfA, pfX, Yregs);
   CombY(fpout, spc, nY, Yregs);
}

static void emit_mvT
   (FILE *fpout, char *rout, char pre, char *styp, char *typ, int lat,
    int beta, int nY, int ngap, int gap, int gapmul, int pfA, int pfX,
    int Yregs)
{
   char *spcs = "                                        ";
   char *spc = spcs+40;
   char ln[128];
   char *bnam[3] = {"b0", "b1", "bX"};
   int i, j, nu = ngap * gap * gapmul;
   if (beta != 0 && beta != 1) beta = 2;

@skip   if (nY > 1) fprintf(fpout, "#include \"atlas_aux.h\"\n");
   if (nY > 1) fprintf(fpout, "#include \"atlas_level1.h\"\n");
   fprintf(fpout, "#include <stddef.h>\n");
   if (rout == NULL)
   {
      rout = ln;
      sprintf(ln, "ATL_%cgemvT_a1_x1_%s_y1\n", pre, bnam[beta]);
   }
   fprintf(fpout, "void %s", rout);
   fprintf(fpout, "/*\n * lat=%d, beta=%s, nY=%d, ngap=%d, gap=%d, gapmul=%d, pfA=%d, pfX=%d\n */\n",
           lat, bnam[beta], nY, ngap, gap, gapmul, pfA, pfX);
   fprintf(fpout, "   (const int M, const int N, const %s alpha,\n", styp);
   fprintf(fpout, 
           "   const %s *A, const int lda, const %s *X, const int incX,\n", 
           typ, typ);
   fprintf(fpout, "   const %s beta, %s *Y, const int incY)\n", styp, typ);
   fprintf(fpout, "{\n");
   fprintf(fpout, "   register %s rX0", typ);
   for (i=1; i < pfX; i++) fprintf(fpout, ", rX%d", i);
   for (i=0; i < pfA; i++) fprintf(fpout, ", rA%d", i);
   for (i=0; i < Yregs; i++) fprintf(fpout, ", rY%d", i);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const %s *pA0=A", typ);
   for (i=1; i < nY; i++) fprintf(fpout, ", *pA%d=pA%d+lda", i, i-1);
   fprintf(fpout, ";\n");
   fprintf(fpout, "   const int n = %s;\n", GetInc(nu,GetDiv(nu, "N")));
   fprintf(fpout, "   const int m = %s;\n", GetInc(nY,GetDiv(nY, "M")));
   fprintf(fpout, 
           "   const %s *stX = X + n - %d, *stXN = X + N, *stXN_1 = stXN-1;\n",
           typ, nu);
   fprintf(fpout, "   %s *stY = Y + m;\n", typ);
   fprintf(fpout, "%s   const int incA = %s - N;\n", spc, GetInc(nY, "lda"));
   fprintf(fpout, "\n");

   if (nY > 1)
   {
      fprintf(fpout, "%s   if (m)\n%s   {\n", spc, spc);
      spc -= 3;
   }
   fprintf(fpout, "%s   do /* while (Y != stY) */\n%s   {\n", spc, spc);
   spc -= 3;

   FetchY(fpout, spc, pre, beta, nY, Yregs, "rX0");

   Xloop(fpout, spc, pre, lat, nY, ngap, gap, gapmul, pfA, pfX, Yregs);

   fprintf(fpout, "%s   X -= N;\n", spc);
   for (j=0; j < nY; j++)
   {
      fprintf(fpout, "%s   pA%d += incA;\n", spc, j);
      fprintf(fpout, "%s   Y[%d] = rY%d;\n", spc, j, j);
   }
   if (nY > 1) fprintf(fpout, "%s   Y += %d;\n", spc, nY);
   spc += 3;
   if (nY == 1) fprintf(fpout, "%s   }\n%s   while(++Y != stY);\n", spc, spc);
   else fprintf(fpout, "%s   }\n%s   while(Y != stY);\n", spc, spc);
   if (nY > 1)
   {
      spc += 3;
      fprintf(fpout, "%s   }\n", spc);
      fprintf(fpout, "%s   if (m != M)\n%s   {\n", spc, spc);
      spc -= 3;
      if (beta != 0 && beta != 1) fprintf(fpout, "%s   rX0 = beta;\n", spc);
      if (nY > 2)
      {
         fprintf(fpout, "%s   stY += M-m;\n", spc);
         fprintf(fpout, "%s   do /* while (Y != stY) */\n%s   {\n", spc, spc);
         spc -= 3;
      }
      if (beta != 0) fprintf(fpout, "%s   rY0 = *Y;\n", spc);
      if (beta != 0 && beta != 1) fprintf(fpout, "%s   rY0 *= rX0;\n", spc);
      if (beta == 0) fprintf(fpout, "%s   rY0 = ", spc);
      else fprintf(fpout, "%s   rY0 += ", spc);
      fprintf(fpout, "ATL_%cdot(N, pA0, 1, X, 1);\n", pre);
      fprintf(fpout, "%s   *Y = rY0;\n", spc);
      if (nY > 2)
      {
         fprintf(fpout, "%s   pA0 += lda;\n", spc);
         spc += 3;
         fprintf(fpout, "%s   }\n%s   while (++Y != stY);\n", spc, spc);
      }
      spc += 3;
      fprintf(fpout, "%s   } /* end Y cleanup */;\n", spc);
   }
   fprintf(fpout, "}\n");
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -l <latency> -Y <nY> -G <ngap> -g <gap> -M <gapmul> -A <# of regs for A> -X <# of regs for X> -y <# regs for Y> -f <file> -R <rout> -b <beta>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, int *lat, int *beta, int *nY,
              int *ngap, int *gap, int *gapmul, int *pfA, int *pfX, 
              int *Yregs, char *pre, char *styp, char *typ, 
              FILE **fpout, char **rout)
{
   int i;
   *beta = -3;
   *lat = 0;
   *nY = *Yregs = *ngap = *gap = *gapmul = *pfA = *pfX = 1;
   *pre = 'd'; 
   *rout = NULL;
   *fpout = stdout;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'R':
         *rout = args[++i];
         break;
      case 'f':
         *fpout = fopen(args[++i], "w");
         assert(*fpout);
         break;
      case 'b':
         *beta = atoi(args[++i]);
         break;
      case 'l':
         *lat = atoi(args[++i]);
         break;
      case 'y':
         *nY = atoi(args[++i]);
         break;
      case 'G':
         *ngap = atoi(args[++i]);
         break;
      case 'g':
         *gap = atoi(args[++i]);
         break;
      case 'M':
         *gapmul = atoi(args[++i]);
         break;
      case 'A':
         *pfA = atoi(args[++i]);
         break;
      case 'X':
         *pfX = atoi(args[++i]);
         break;
      case 'Y':
         *Yregs = atoi(args[++i]);
         break;
      case 'p':
         i++;
         *pre = Mlowcase(args[i][0]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   i = *nY * *ngap * *gap * *gapmul;
   assert(i % *pfA == 0);
   if (*lat)
   {
      assert(i % *lat == 0);
      assert(*pfX + *lat / *nY <= i);
      assert(*pfA > *lat);
   }
   assert((*ngap * *gap * *gapmul)% (*pfX)  == 0);
   assert(*Yregs >= *nY);

   switch (*pre)
   {
   case 'z':
      sprintf(styp, "double*");
      sprintf(typ, "double");
      break;
   case 'd':
      sprintf(styp, "double");
      sprintf(typ, "double");
      break;
   case 'c':
      sprintf(styp, "float*");
      sprintf(typ, "float");
      break;
   case 's':
      sprintf(styp, "float");
      sprintf(typ, "float");
      break;
   default:
      PrintUsage(args[0]);
   }
}

main(int nargs, char **args)
{
   char pre, styp[32], typ[32], *rout;
   int lat;     /* 0: combined muladd inst; X: seperate multiply & add, lat=X */
   int nY;      /* number of columns of A to operate on (# of dot products) */
   int Yregs;   /* number of registers to use for Y */
   int ngap;    /* number of accumulaters to use within each dot prod */
   int gap;     /* gap size in column */
   int gapmul;  /* number of unrollings of whole mess to do */
   int pfA;     /* number of registers to use in prefetching A */
   int pfX;     /* number of registers to use in prefetching X */
   int i, beta;
   FILE *fpout;

   GetFlags(nargs, args, &lat, &beta, &nY, &ngap, &gap, &gapmul, &pfA, &pfX,
            &Yregs, &pre, styp, typ, &fpout, &rout);

   if (beta == -3) /* generate all beta cases */
   {
      for (i=0; i < 3; i++)
      {
         if (i == 0 || i == 1) fprintf(fpout, "#ifdef BETA%d\n\n", i);
         else fprintf(fpout, "#ifdef BETAX\n\n");
         emit_mvT(fpout, rout, pre, styp, typ, lat, i, nY, ngap, gap, gapmul,
                  pfA, pfX, Yregs);
         fprintf(fpout, "\n\n#endif\n");
      }
   }
   else emit_mvT(fpout, rout, pre, styp, typ, lat, beta, nY, ngap, gap,
                 gapmul, pfA, pfX, Yregs);
   exit(0);
}
@ROUT r1gen_sse mvgen_sse
/*
 * NOTE: do prefetch by having small program that reads output files, and
 *       simply schedules the prefetch inst within the code, by searching
 *       for particular inst in standard output.  Can print markers in
 *       generated code ID regions of interest
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_r1parse.h"

#define NUMFLAGS        8
char *F_exp[NUMFLAGS] = 
{
NULL,
NULL,
"X&Y are copied into all legal alignments",
"X&Y type-aligned, LDA*sizeof multiple of 16",
"A&X 16-byte aligned",
"preload nmu*nu rows of A ahead",
"preload nmu*nu elts of X ahead",
"Schedule X loads before compute block",
"Schedule 1st row of A loads before compute block",
"Generate single precision, not double",
"Use A ptrs rather than lda to index columns of A"
};

#define F_PRELOADA      2    /* preload mu*nmu elts of A ahead */
#define F_PRELOADX      3    /* preload mu*nmu elts of X ahead */
#define F_LDXSEP        4    /* load X before starting computation */
#define F_LDASEP        5    /* load 1st row of A before starting computation */

#define SET_FLAG(bits_, flg_, val_) \
{\
   if (val_) (bits_) |= (1<<(flg_)); \
   else (bits_) &= ~(1<<(flg_)); \
}

#define TEST_FLAG(bits_, flg_) ( (bits_) & (1<<(flg_)) )

@extract -b @(basd)/atlas-gen.base rout=GetMul
char *GetAadd(
   int flag, 
   int I,       /* constant value to go to unrolled row */
   int J,       /* constant value to go to unrolled col */
   int UseI)    /* Should we add "+i" to ptr ref? */
{
   static char ln[256];
   char *sp = (UseI) ? "+i" : "";

   if (TEST_FLAG(flag, R1F_APTRS))  /* use ptrs to index columns */
   {
      if (I)
         sprintf(ln, "A%d+%d%s", J, I, sp);
      else if (UseI)
         sprintf(ln, "A%d+i", J);
      else 
         sprintf(ln, "A%d", J);
   }
   else  /* use lda to index columns */
   {
      if (J)
      {
         if (I)
            sprintf(ln, "A+lda%d+%d%s", J, I, sp);
         else
            sprintf(ln, "A+lda%d%s", J, sp);
      }
      else
      {
         if (I)
            sprintf(ln, "A+%d%s", I, sp);
         else if (UseI)
            sprintf(ln, "A%s", sp);
         else
            sprintf(ln, "A");
      }
   }
   return(ln);
}

char **GetLDAs(int nu)
{
   static char **ldas=NULL;
   static int nu0=0;
   int j;

   if (nu0 == nu)
      return(ldas);
   if (nu0)
   {
      for (j=0; j < nu0; j++)
         free(ldas[j]);
      free(ldas);
      ldas = NULL;
   }
   nu0 = nu;
   if (nu)
   {
      ldas = malloc(nu*sizeof(char*));
      assert(ldas);
      ldas[0] = malloc(sizeof(char));
      assert(ldas[0]);
      ldas[0][0] = '\0';
      for (j=1; j < nu; j++)
      {
         ldas[j] = malloc(8*sizeof(char));
         assert(ldas[j]);
         ldas[j][0] = '+'; ldas[j][1] = 'l'; ldas[j][2] = 'd'; ldas[j][3] = 'a';
         sprintf(ldas[j]+4, "%d", j);
      }
   }
   return(ldas);
}

void GetLdStPre(int flag, char **Xld, char **Ald, char **Ast, char *pre)
{
   if (TEST_FLAG(flag, R1F_ALGLDA) | TEST_FLAG(flag, R1F_ALLALIGNXY))
   {
      *Xld = "_mm_load_p";
      *Ald = "_mm_load_p";
      *Ast = "_mm_store_p";
   }
   else
   {
      *Xld = "_mm_loadu_p";
      *Ald = "_mm_loadu_p";
      *Ast = "_mm_storeu_p";
   }
   *pre = (TEST_FLAG(flag, R1F_SINGLE)) ? 's' : 'd';
}

@ROUT r1gen_sse
void gen_sMUxNU( FILE *fpout, char *spc, int flag, int mu, int nu, int I0);
void gen_sMUxNU(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   int flag,
   int mu,      /* unrolling on M dimension */
   int nu,      /* unrolling on N dimension */
   int I0)      /* what to start I at (for unrolling w/o register block) */
{
   int i, j;
   char pre;

   pre = TEST_FLAG(flag, R1F_SINGLE) ? 's' : 'd';

   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         if (!j)
            fprintf(fpout, "%sx%d = _mm_load_s%c(X+i+%d);\n", spc, i, pre, i+I0);
         fprintf(fpout, "%sa%d_%d = _mm_load_s%c(%s);\n", 
                 spc, i, j, pre, GetAadd(flag, i+I0, j, 1));
         fprintf(fpout, "%sm%d_%d = _mm_mul_s%c(x%d, y%d);\n",
                 spc, i, j, pre, i, j);
         fprintf(fpout, "%sa%d_%d = _mm_add_s%c(a%d_%d, m%d_%d);\n",
                 spc, i, j, pre, i, j, i, j);
         fprintf(fpout, "%s_mm_store_s%c(%s, a%d_%d);\n", 
                 spc, pre, GetAadd(flag, i+I0, j, 1), i, j);
      }
   }
}

void gen_MUxNU(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   int flag,
   int mu,      /* unrolling on M dimension */
   int nu,      /* unrolling on N dimension */
   int I0)      /* what to start I at (for unrolling w/o register block) */
{
   int i, j;
   char *Xld, *Ald, *Ast;
   char pre;

   GetLdStPre(flag, &Xld, &Ald, &Ast, &pre);

   assert(mu%2 == 0);
   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i += 2)
      {
         if (!j)
            fprintf(fpout, "%sx%d = %s%c(X+i+%d);\n", spc, i, Xld, pre, i+I0);
         fprintf(fpout, "%sa%d_%d = %s%c(%s);\n", 
                 spc, i, j, Ald, pre, GetAadd(flag, i+I0, j, 1));
         fprintf(fpout, "%sm%d_%d = _mm_mul_p%c(x%d, y%d);\n",
                 spc, i, j, pre, i, j);
         fprintf(fpout, "%sa%d_%d = _mm_add_p%c(a%d_%d, m%d_%d);\n",
                 spc, i, j, pre, i, j, i, j);
         fprintf(fpout, "%s%s%c(%s, a%d_%d);\n", 
                 spc, Ast, pre, GetAadd(flag, i+I0, j, 1), i, j);
      }
   }
}

@ROUT mvgen_sse
void gen_sMUxNU0(FILE *fpout, char *spc, int flag, int mu, int nu, int I0)
{
   int incM;
   int i, j;
   char pre;

   pre = TEST_FLAG(flag, R1F_SINGLE) ? 's' : 'd';
   incM = (pre == 'd') ? 2 : 4;
   for (i=0; i < mu; i++)
   {
      for (j=0; j < nu; j++)
      {
         if (!j)
            fprintf(fpout, "%sx%d = _mm_load_s%c(X+i+%d);\n", spc, i, pre, i+I0);
         if (!i)
         {
            fprintf(fpout, "%sy%d = _mm_load_s%c(%s);\n",
                    spc, j, pre, GetAadd(flag, I0, j, 1));
            fprintf(fpout, "%sy%d = _mm_mul_s%c(y%d, x0);\n", spc, j, pre, j);
         }
         else
         {
            fprintf(fpout, "%sa%d_%d = _mm_load_s%c(%s);\n",
                    spc, i*incM, j, pre, GetAadd(flag, i+I0, j, 1));
            fprintf(fpout, "%sa%d_%d = _mm_mul_s%c(a%d_%d, x%d);\n",
                    spc, i*incM, j, pre, i*incM, j, i*incM);
            fprintf(fpout, "%sy%d = _mm_add_s%c(y%d, a%d_%d);\n\n", 
                    spc, j, pre, j, i, j);
         }
      }
   }
}

void gen_sMUxNU(FILE *fpout, char *spc, int flag, int mu, int nu, int I0)
{
   int i, j, incM;
   char pre;

   pre = TEST_FLAG(flag, R1F_SINGLE) ? 's' : 'd';
   incM = (pre == 'd') ? 2 : 4;
   for (i=0; i < mu; i++)
   {
      for (j=0; j < nu; j++)
      {
         if (!j)
            fprintf(fpout, "%sx%d = _mm_load_s%c(X+i+%d);\n", spc, i, pre, i+I0);
         fprintf(fpout, "%sa%d_%d = _mm_load_s%c(%s);\n",
                 spc, i*incM, j, pre, GetAadd(flag, i+I0, j, 1));
         fprintf(fpout, "%sa%d_%d = _mm_mul_s%c(a%d_%d, x%d);\n",
                 spc, i*incM, j, pre, i*incM, j, i*incM);
         fprintf(fpout, "%sy%d = _mm_add_s%c(y%d, a%d_%d);\n\n", 
                 spc, j, pre, j, i, j);
      }
   }
}

void gen_MUxNU0(FILE *fpout, char *spc, int flag, int mu, int nu, int I0)
{
   char *Xld, *Ald, *Ast;
   char pre;
   int i, j, incM;

   GetLdStPre(flag, &Xld, &Ald, &Ast, &pre);
   incM = (pre == 'd') ? 2 : 4;
   assert(mu%incM == 0);

   for (i=0; i < mu; i += incM)
   {
      for (j=0; j < nu; j++)
      {
         if (!j)
            fprintf(fpout, "%sx%d = %s%c(X+i+%d);\n", 
                    spc, i, Xld, pre, i+I0);
         if (!i)
         {
            fprintf(fpout, "%sy%d = %s%c(%s);\n", 
                    spc, j, Ald, pre, GetAadd(flag, I0, j, 1));
            fprintf(fpout, "%sy%d = _mm_mul_p%c(y%d, x0);\n", spc, j, pre, j);
         }
         else
         {
            fprintf(fpout, "%sa%d_%d = %s%c(%s);\n",
                    spc, i, j, Ald, pre, GetAadd(flag, i+I0, j, 1));
            fprintf(fpout, "%sa%d_%d = _mm_mul_p%c(a%d_%d, x%d);\n",
                    spc, i, j, pre, i, j, i);
            fprintf(fpout, "%sy%d = _mm_add_p%c(y%d, a%d_%d);\n\n", 
                    spc, j, pre, j, i, j);
         }
      }
   }
}

void gen_MUxNU(FILE *fpout, char *spc, int flag, int mu, int nu, int I0)
{
   char *Xld, *Ald, *Ast;
   char pre;
   int i, j, incM;

   GetLdStPre(flag, &Xld, &Ald, &Ast, &pre);
   incM = (pre == 'd') ? 2 : 4;
   assert(mu%incM == 0);

   for (i=0; i < mu; i += incM)
   {
      fprintf(fpout, "%sx%d = %s%c(X+i+%d);\n", spc, i, Xld, pre, i+I0);
      for (j=0; j < nu; j++)
      {
         fprintf(fpout, "%sa%d_%d = %s%c(%s);\n",
                 spc, i, j, Ald, pre, GetAadd(flag, i+I0, j, 1));
         fprintf(fpout, "%sa%d_%d = _mm_mul_p%c(a%d_%d, x%d);\n",
                 spc, i, j, pre, i, j, i);
         fprintf(fpout, "%sy%d = _mm_add_p%c(y%d, a%d_%d);\n\n", 
                 spc, j, pre, j, i, j);
      }
   }
}

@ROUT r1gen_sse mvgen_sse
void genMloop(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   int flag,
   char *mstart,/* usually "0", but will be "M8" for UR=8 cleanup */
   char *mend,  /* ending clause for i */
   int nmu,     /* # of reps of mu register block in M unroll */
   int mu,      /* unrolling on M dimension */
   int nu)      /* unrolling on N dimension */
{
   int i, j;
   int MU = nmu * mu;

   fprintf(fpout, "\n%sfor (%s; i < %s; i += %d)\n", spc, mstart, mend, MU, MU);
   fprintf(fpout, "%s{/* ----- BEGIN M-LOOP BODY ----- */\n", spc);
   for (i=0; i < nmu; i++)
   {
      fprintf(fpout, "%s   /* --- BEGIN MUxNU UNROLL %d --- */\n", spc, i);
      gen_MUxNU(fpout, spc-3, flag, mu, nu, i*mu);
      fprintf(fpout, "%s   /* --- END MUxNU UNROLL %d --- */\n", spc, i);
   }
   fprintf(fpout, "%s}/* ----- END M-LOOP BODY ----- */\n", spc);
}

void genNloopBody(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   int flag,
   int nmu,     /* # of reps of mu register block in M unroll */
   int mu,      /* unrolling on M dimension */
   int nu)      /* unrolling on N dimension */
{
   int i, j, MU = nmu*mu;
   char mstart[8], mend[8];
   char pre;

   pre = TEST_FLAG(flag, R1F_SINGLE) ? 's' : 'd';

@ROUT r1gen_sse
   sprintf(mstart, "i=0");
   sprintf(mend, "M%d", MU);
   fprintf(fpout, "%sy0 = _mm_load1_p%c(Y);\n", spc, pre);
   for (j=1; j < nu; j++)
      fprintf(fpout, "%sy%d = _mm_load1_p%c(Y+incY%d);\n", spc, j, pre, j);
/*
 * See if we need to possibly peel loop based on A alignment
 */
   if (TEST_FLAG(flag, R1F_ALGLDA))
   {
      sprintf(mstart, "i=MAp");
      fprintf(fpout, "%sif (MAp)\n", spc);
      fprintf(fpout, "%s{/* peel to force X/A alignment */\n", spc);
      fprintf(fpout, "%s   i=0;\n", spc);
      if (pre == 'd')
         gen_sMUxNU(fpout, spc-3, flag, 1, nu, 0);
      else
      {
         gen_sMUxNU(fpout, spc-3, flag, 1, nu, 0);
         fprintf(fpout, "%s   if (MAp >= 2)\n%s   {\n", spc, spc);
         gen_sMUxNU(fpout, spc-6, flag, 1, nu, 1);
         fprintf(fpout, "%s   }\n", spc);
         fprintf(fpout, "%s   if (MAp == 3)\n%s   {\n", spc, spc);
         gen_sMUxNU(fpout, spc-6, flag, 1, nu, 2);
         fprintf(fpout, "%s   }\n", spc);
      }
      fprintf(fpout, "%s} /* end force-align peel */\n", spc);
   }
@ROUT mvgen_sse
   sprintf(mstart, "i=MAp");
   sprintf(mend, "M%d", MU);
   fprintf(fpout, "%sif (MAp != 1)\n", spc);
   fprintf(fpout, "%s{/* peel to zero Y */\n", spc);
   fprintf(fpout, "%s   i=0;\n", spc);
   gen_MUxNU0(fpout, spc-3, flag, 2, nu, 0);
   fprintf(fpout, "%s} /* end zero Y peel */\n", spc);
   fprintf(fpout, "%selse /* if (MAp == 1)*/\n", spc);
   fprintf(fpout, "%s{/* peel to force X/A alignment, zero Y */\n", spc);
   fprintf(fpout, "%s   i=0;\n", spc);
   gen_sMUxNU0(fpout, spc-3, flag, 1, nu, 0);
   fprintf(fpout, "%s} /* end force-align/zeroY peel */\n", spc);
@ROUT r1gen_sse mvgen_sse
   genMloop(fpout, spc, flag, mstart, mend, nmu, mu, nu);
   if (MU > 2)
   {
      sprintf(mstart, "i=M%d", MU);
      fprintf(fpout, "%sif (M != M%d)\n", spc, MU);
      fprintf(fpout,"%s{/* ----- BEGIN VECTOR UNROLL M CLEANUP ----- */\n",spc);
      spc -= 3;
/*      if (mu > 6) */
         genMloop(fpout, spc, flag, mstart, "M2", 1, 2, nu);
/*      else */ /* put case statement in here eventually */
/*      { */
/*         gen_MUxNU(fpout, spc-3, flag, mu, nu, i*mu); */
/*      } */
   }
   fprintf(fpout, "%sif (M != M2)\n", spc);
   fprintf(fpout, "%s{/* ----- BEGIN SCALAR M CLEANUP ----- */\n", spc);
   gen_sMUxNU(fpout, spc-3, flag, 1, nu, 0);
   fprintf(fpout, "%s}/* ----- END SCALAR M CLEANUP ----- */\n", spc);

   if (MU > 2)
   {
      spc += 3;
      fprintf(fpout, "%s}/* ----- END VECTOR UNROLL M CLEANUP ----- */\n", spc);
   }
@ROUT mvgen_sse
/*
 * Handle post-loop reduction & store to Y
 */
   for (j=0; j < nu/2; j++)
   {
      fprintf(fpout, "%s_my_hadd_pd(y%d, y%d);\n", spc, j*2, j*2+1);
      fprintf(fpout, "%s#if defined(BETAX) || defined(BETA1)\n", spc);
      fprintf(fpout, "%s   a0_%d = _mm_load_pd(Y+j+%d);\n", spc, j, j*2);
      fprintf(fpout, 
              "%s   #ifdef BETAX\n%s     a0_%d = _mm_mul_pd(a0_%d, vbeta);\n",
              spc, spc, j, j);
      fprintf(fpout, "%s   #endif\n", spc);
      fprintf(fpout, "%s   y%d = _mm_add_pd(y%d, a0_%d);\n", spc, j*2, j*2, j);
      fprintf(fpout, "%s#endif\n", spc);
      fprintf(fpout, "%s_mm_store_pd(Y+j+%d, y%d);\n", spc, j*2, j*2);
   }
   if (nu%2)
   {
      fprintf(fpout, "%s_my_hadd_pd(y%d, y%d);\n", spc, j*2, j*2);
      fprintf(fpout, "%s#if defined(BETAX) || defined(BETA1)\n", spc);
      fprintf(fpout, "%s   a0_%d = _mm_load_sd(Y+j+%d);\n", spc, j, j*2);
      fprintf(fpout, 
              "%s   #ifdef BETAX\n%s      a0_%d = _mm_mul_sd(a0_%d, vbeta);\n",
              spc, spc, j, j);
      fprintf(fpout, "%s   #endif\n", spc);
      fprintf(fpout, "%s   y%d = _mm_add_sd(y%d, a0_%d);\n", spc, j*2, j*2, j);
      fprintf(fpout, "%s#endif\n", spc);
      fprintf(fpout, "%s_mm_store_sd(Y+j+%d, y%d);\n", spc, j*2, j*2);
   }
@ROUT r1gen_sse mvgen_sse
}

void genNloop(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   int flag,
   char *nstart,/* usually "0", but will be "M8" for UR=8 cleanup */
   char *nend,  /* ending clause for j */
   int nmu,     /* # of reps of mu register block in M unroll */
   int mu,      /* unrolling on M dimension */
   int nu)      /* unrolling on N dimension */
{
   int j;
@ROUT r1gen_sse
   if (TEST_FLAG(flag, R1F_APTRS))
   {
      fprintf(fpout, "\n%sfor (j=%s; j < %s; j += %d, Y += incY",
              spc, nstart, nend, nu);
      for (j=0; j < nu; j++)
         fprintf(fpout, ", A%d += lda%d", j, nu);
      fprintf(fpout, ")\n");
   }
   else
      fprintf(fpout, "\n%sfor (j=%s; j < %s; j += %d, A += lda%d, Y += incY%d)\n",
              spc, nstart, nend, nu, nu, nu);
@ROUT mvgen_sse
   if (TEST_FLAG(flag, R1F_APTRS))
   {
      fprintf(fpout, "\n%sfor (j=%s; j < %s; j += %d",
              spc, nstart, nend, nu);
      for (j=0; j < nu; j++)
         fprintf(fpout, ", A%d += lda%d", j, nu);
      fprintf(fpout, ")\n");
   }
   else
      fprintf(fpout, "\n%sfor (j=%s; j < %s; j += %d, A += lda%d)\n",
              spc, nstart, nend, nu, nu);
@ROUT r1gen_sse mvgen_sse
   fprintf(fpout, "%s{/* BEGIN N-LOOP UR=%d */\n", spc, nu);
   genNloopBody(fpout, spc-3, flag, nmu, mu, nu);
   fprintf(fpout, "%s}/* END N-LOOP UR=%d */\n", spc, nu);
}

@ROUT r1gen_sse
   @define rt @r1@
@ROUT  mvgen_sse
   @define rt @mv@
@ROUT r1gen_sse mvgen_sse
#define NUNDEF 3
static char *udefs[NUNDEF] = {"MA", "MAp", "A0"};
void gen@up@(rt)(
   FILE *fpout, /* file to print to */
   char *spc,   /* string with indentation spaces */
   char *rout,  /* routine name */
   int flag,    /* bit field with flags controlling generation options */
   int nmu,     /* # of reps of mu register block in M unroll */
   int mu,      /* unrolling on M dimension */
   int nu)      /* unrolling on N dimension */
{
   int i, j;
   int MU = nmu*mu, incM;
   char nbnd[8];
   incM = TEST_FLAG(flag, R1F_SINGLE) ? 4 : 2;

   fprintf(fpout, "%s#include <xmmintrin.h>\n", spc);
   fprintf(fpout, "%s#include \"atlas_misc.h\"\n", spc);
@ROUT mvgen_sse
   fprintf(fpout, "%s#define _my_hadd_pd(dst, src) \\\n", spc);
   fprintf(fpout, "%s   __asm__ __volatile__ (\"haddpd %%2, %%0\" : \"=x\"(dst) : \"0\" (dst), \"x\"(src))\n", spc);
   fprintf(fpout, "\n%svoid %s\n", spc, rout);
   fprintf(fpout, "%s   (ATL_CINT N, ATL_CINT M, const SCALAR alpha,\n", spc);
   fprintf(fpout, "%s    TYPE *A, ATL_CINT lda1, const TYPE *X, ATL_CINT incX,\n",
           spc);
   fprintf(fpout, "%s    const SCALAR beta, TYPE *Y, ATL_CINT incY)\n", spc);
   fprintf(fpout, "%s{/* BEGIN GEMV: nMU=%d, MU=%d, NU=%d */\n",spc, nmu, mu, nu);
   spc -= 3;
   fprintf(fpout, "%sATL_INT i, j;\n", spc);
   if (!TEST_FLAG(flag, R1F_SINGLE))
      fprintf(fpout,"%sATL_CINT MAp = ((((size_t)A)&0xF) || M==1) ? 1 : 2;\n", spc);
   else
      fprintf(fpout, "%sATL_CINT MAp = ((size_t)A)&0xF ? (( (((((size_t)A)+15)>>4)<<4) - ((size_t)A) )/sizeof(TYPE)) : 4;\n", spc);
   fprintf(fpout, "%sATL_CINT MA = M - MAp;\n", spc);
@ROUT r1gen_sse
   fprintf(fpout, "\n%svoid %s\n", spc, rout);
   fprintf(fpout, "%s   (ATL_CINT M, ATL_CINT N, const SCALAR alpha,\n", spc);
   fprintf(fpout, "%s    const TYPE *X, ATL_CINT incX, const TYPE *Y,\n", spc);
   fprintf(fpout, "%s    ATL_CINT incY1, TYPE *A, ATL_CINT lda1)\n", spc);
   fprintf(fpout, "%s{/* BEGIN GER: nMU=%d, MU=%d, NU=%d */\n", spc, nmu, mu, nu);
   spc -= 3;
   fprintf(fpout, "%sATL_INT i, j;\n", spc);
   if (TEST_FLAG(flag, R1F_ALLALIGNXY) || !TEST_FLAG(flag, R1F_ALGLDA))
   {
      fprintf(fpout, "%s#define MAp 0\n");
      fprintf(fpout, "%s#define MA  M\n");
   }
   else
   {
      fprintf(fpout, "%sATL_CINT MAp = ( (((((size_t)A)+15)>>4)<<4) - ((size_t)A) )/sizeof(TYPE), MA=M-MAp;\n", spc);
   }
@ROUT r1gen_sse mvgen_sse
   if (TEST_FLAG(flag, R1F_APTRS))
   {
      fprintf(fpout, "%s#define A0 A\n", spc);
      if (nu)
      {
@ROUT mvgen_sse `         fprintf(fpout, "%sconst TYPE *A1=A0+lda1", spc);`
@ROUT r1gen_sse `         fprintf(fpout, "%sTYPE *A1=A0+lda1", spc);`
         for (j=2; j < nu; j++)
            fprintf(fpout, ", *A%d=A%d+lda1", j, j-1);
         fprintf(fpout, ";\n");
      }
   }
   fprintf(fpout, "%sATL_CINT", spc);
   fprintf(fpout, " M%d=(%s)+MAp", MU, GetMul(MU, GetDiv(MU, "MA")));
   if (MU != 2)
      fprintf(fpout, ", M2=((MA>>1)<<1)+MAp");
   if (nu > 1)
   {
      if ((nu-1) & nu)
         fprintf(fpout, ", N%d=(N/%d)*%d", nu, nu, nu);
      else
         fprintf(fpout, ", N%d=%s", nu, GetMul(nu, GetDiv(nu, "N")));
   }
   for (j=2; j <= nu; j++)
   {
      if (!TEST_FLAG(flag, R1F_APTRS))
         fprintf(fpout, ", lda%d=lda%d+lda1", j, j-1);
@ROUT r1gen_sse `      fprintf(fpout, ", incY%d=incY%d+incY1", j, j-1);`
   }
   if (TEST_FLAG(flag, R1F_APTRS))
      fprintf(fpout, ", lda%d=%s", nu, GetMul(nu, "lda1"));
   fprintf(fpout, ";\n");
@ROUT mvgen_sse `   fprintf(fpout, "%s#ifdef BETAX\n%s   __m128d vbeta;\n%s#endif\n", spc,spc,spc);`
   fprintf(fpout, "%s__m128d x0", spc);
   for (j=1; j < mu; j++)
      fprintf(fpout, ", x%d", j);
   for (j=0; j < nu; j++)
      fprintf(fpout, ", y%d", j);
   for (j=0; j < nu; j++)
      for (i=0; i < mu; i += incM)
@ROUT r1gen_sse `         fprintf(fpout, ", a%d_%d, m%d_%d", i, j, i, j);`
@ROUT mvgen_sse `         fprintf(fpout, ", a%d_%d", i, j);`
   fprintf(fpout, ";\n");

   fprintf(fpout, "%sif (!M || !N) return;\n", spc);
@ROUT mvgen_sse
   fprintf(fpout, "%s#ifdef BETAX\n%s   vbeta = _mm_load1_pd(&beta);\n%s#endif\n",
           spc, spc, spc);
@ROUT mvgen_sse r1gen_sse
   if (nu > 1)
      sprintf(nbnd, "N%d", nu);
   else
      sprintf(nbnd, "N");
   genNloop(fpout, spc, flag, "0", nbnd, nmu, mu, nu);
   if (nu > 1)  /* later on, use case statement rather than NU=1 cleanup */
   {
      genNloop(fpout, spc, flag, nbnd, "N", nmu, mu, 1);
   }
   spc += 3;
   fprintf(fpout, "%s}/* END GE@up@(rt): nMU=%d, MU=%d, NU=%d */\n", 
           spc, nmu, mu, nu);
   for (i=0; i < NUNDEF; i++)
      fprintf(fpout, "%s#ifdef %s\n%s   #undef %s\n%s#endif\n", 
              spc, udefs[i], spc, udefs[i], spc);
}

void PrintUsage(char *name, char *arg, int i)
{
   int j;
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' on %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
   fprintf(stderr, "   -M <#> : repeat mu unroll # times in loop\n");
   fprintf(stderr, "   -m <#> : unroll (wt reg blking) M loop by #\n");
   fprintf(stderr, "   -n <#> : unroll&jam N loop by #\n");
   fprintf(stderr, "   -S <flag#> [0/1] : unset/set flag.  Flags include:\n");
   for (j=0; j < NUMFLAGS; j++)
      fprintf(stderr, "      %2d : %s\n", j, R1F_exp[j]);
   fprintf(stderr, "   -F <#> : set flag bitfield to #\n");
   exit(i ? i : -1);
}

int GetFlags(int nargs, char **args, int *NMU, int *MU, int *NU)
{
   int i, flag=0, j, set;

   *NMU = *NU = 1;
   *MU = 2;

   flag = 0;
   SET_FLAG(flag, R1F_ALGLDA, 1);
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "No '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'S':
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -S ", i-1);
         set = atoi(args[i]);
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -S ", i-1);
         j = atoi(args[i]);
         SET_FLAG(flag, set, j);
        break;
      case 'F':
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -S ", i-1);
         flag = atoi(args[i]);
         break;
      case 'M':
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -M ", i-1);
         *NMU = atoi(args[i]);
        break;
      case 'm':
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -m ", i-1);
         *MU = atoi(args[i]);
        break;
      case 'n':
        if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -n ", i-1);
         *NU = atoi(args[i]);
        break;
      default:
         PrintUsage(args[0], args[i], i);
      }
   }
   return(flag);
}

#define NSPCS 128
int main(int nargs, char **args)
{
   int i, nmu, mu, nu, flag;
   char spc[NSPCS];
   char pre;
   char name[1024];

   for (i=0; i < NSPCS; i++)
      spc[i] = ' ';
   spc[NSPCS-1] = '\0';
   flag = GetFlags(nargs, args, &nmu, &mu, &nu);
   pre = TEST_FLAG(flag, R1F_SINGLE) ? 's' : 'd';
@ROUT r1gen_sse `   sprintf(name, "ATL_%cger1_a1_x1_yX", pre);`
@ROUT mvgen_sse `   sprintf(name, "Mjoin(Mjoin(ATL_%cgemvT_a1_x1,BNM),_y1)", pre);`
   gen@up@(rt)(stdout, spc+NSPCS-1, name, flag, nmu, mu, nu);
   exit(0);
}
@ROUT extract
/************************************************************************/
/*                        Extract v4.0.0                                */
/*  (C) Copyright 1994 R. Clint Whaley (rwhaley@cs.utk.edu).            */
/*  This program is distributed under the terms of the Gnu              */
/*  General Public License (GPL), with the following two exceptions:    */
/*  (1) Clause (9), dealing with updating the GPL automatically, is     */
/*      specifically disallowed by the author.  The author will         */
/*      determine if a newer GPL version is still appropriate.          */
/*  (2) The basefiles extract accepts as input, and the extracted       */
/*      files it produces as output, are specifically designated as     */
/*      as outside the scope if this license (i.e. they are *not*       */
/*      required by this license to be GPL).                            */
/*  The full, unaltered, text of the GPL is included at the end of      */
/*  the program source listing.                                         */
/*  ------------------------------------------------------------------  */
/*  Last modified by the author on  10/04/10.                           */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>

#define NAMLEN 128
#define LNLEN  2048
#define HANLEN 50
#define SUBLEN 128

#define F_nFlags     16
#define F_Case        0
#define F_RemBlank    1
#define F_Lang        2
#define F_Ugly        3
#define F_Verb        4
#define F_RepTab      5
#define F_LnLen       6
#define F_Append      7
#define F_TransNum    8
#define F_Query       9
#define F_AddKeys    10
#define F_Clint      11
#define F_FragMac    12
#define F_FragFlag   13
#define F_LLWarn     14
#define F_LocalProcs 15

#define EC_nExtCmnds 20
#define EC_Extract  0
#define EC_Skip     1
#define EC_Define   2
#define EC_Indent   3
#define EC_Key      4
#define EC_Abort    5
#define EC_MacSub   6
#define EC_EndExt   7
#define EC_Print    8
#define EC_Exp      9
#define EC_While   10 
#define EC_Ifdef   11 
#define EC_Dec     12 
#define EC_AddKey  13
#define EC_Echo    14
#define EC_Iwhile  15
#define EC_Proc    16
#define EC_Output  17
#define EC_Iif     18
#define EC_Mif     19

#define MODE_IIF  1  /* integer if mode */
#define MODE_MIF  2  /* macro if mode */
/*
 * Mode count numbers
 */
#define NMC   2
#define MCIIF 0
#define MCMIF 1

/*
 * KILLMODE must be INMODE or it sets instead
 */
#define INMODE(modenv_, which_) ( (modenv_) | (which_) == (modenv_) )
#define SETMODE(modenv_, which_) (modenv_) = (modenv_) | (which_)
#define KILLMODE(modenv_, which_) (modenv_) = (modenv_) ^ (which_)

enum LANG {LangC, LangF77, LangF90, LangMake};
typedef struct fIlE2 FILE2;
struct fIlE2
{
   char Fnam[NAMLEN];
   unsigned int LineNo;
   FILE *Fp;
   FILE2 *prev;
};

typedef struct aRgStAcK ARGSTACK;
struct aRgStAcK
{
   char KeyArgs[LNLEN];
   int Not;
   ARGSTACK *next;
};

typedef struct eXtMaC EXTMAC;
struct eXtMaC
{
   int HanLen, SubLen;
   char *Handle;
   char *Sub;
   EXTMAC *next;
};

typedef struct pUnYmAc PUNYMAC;
struct pUnYmAc
{
   EXTMAC *mp;
   PUNYMAC *next;
};

typedef struct kEyS KEYS;
struct kEyS
{
   char *KeyHandle, *Match;
   int HanLen;
   EXTMAC *KeyMac;
   ARGSTACK *MyArgs, *ArgStack; 
   KEYS *next;
};

typedef struct InDeNt INDENT;
struct InDeNt
{
   int start;
   int nspac;
   INDENT *next;
   INDENT *prev;
};

typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

typedef struct eXtPrOc EXTPROC;
struct eXtPrOc
{
   char *ProcNam, *FileNam;
   int nargs;
   WORDS *argnams;
   EXTPROC *next;
};

/*
 * If localprocs is set, I kill not only all my procedures, but all those 
 * defined by subservient extracts, and all proc macros become puny
 */
typedef struct eXtEnV EXTENV;
struct eXtEnV
{
   FILE2 *FpIn, *FpOut;
   char Flags[F_nFlags];/* logical flag array */
   char ExtCmndOn[EC_nExtCmnds];
   KEYS *KeyBase;       /* pointer to the list of keys */
   EXTPROC *MyProcs;    /* Pointer to first procedure I've defined */
   EXTPROC *MyFuncs;    /* Pointer to first function  I've defined */
   EXTMAC *MyMacBeg;
   PUNYMAC *MyPunyMacs; /* Puny macros */
   INDENT *clindent;    /* command-line indent */
   int Joining;         /* are we in a mode where joining lines is OK */
};

FILE *Warn;
EXTPROC *AllProcs=NULL, *AllFuncs=NULL;
EXTMAC *MacroBase=NULL;
INDENT *indbase=NULL;
int LnCount=0, nLnNums, *LnNums;
int ExtDone=0;
char *JoinLn=NULL;
unsigned int mode=0;
unsigned int modedepth[NMC] = {0,0};
char *version = "4.0.0";

/*
 * Prototypes of the functions used before their definition
 */
void HandleLine(EXTENV *EE, char *line);
void ApplyFlags(EXTENV *EE, char *line);

#define Mupcase(C) ( ((C) > 96 && (C) < 123) ? (C) & 0xDF : (C) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )
#define Mciswspace(C) ( (((C) > 8) && ((C) < 14)) || ((C) == 32) )
#define Mcisnum(C) ( ((C) > 47) && ((C) < 58) )
#define Mabs(x) ( (x) < 0 ? (x) * -1 : (x) )

void *Wmalloc(size_t len)
{
   void *p;
   p = malloc(len);
   assert(p != NULL);
   return(p);
}

/*===========================================================================*/
/* The following routines are string handling routines of various flavors    */
/* Before the C purists attack: I am well aware some of these routines       */
/* duplicate functionality in the ANSI C standard libraries.  However, I     */
/* wrote the first version of extract a long time ago, and I ran into a      */
/* platform where the ANSI C string libraries did not work properly . . .    */
/*===========================================================================*/

int Wstrcmp(char *p1, char *p2)
/*****************************************************************************/
/*  PURPOSE: compares two strings pointed at by p1 & p2.                     */
/*  RETURNS: 0 if they are not the same, else non-zero.                      */
/*****************************************************************************/
{
   if ( (*p1) && (*p1 == *p2) )
   {
      do
      {
         p1++;
         p2++;
      }
      while ( (*p1 == *p2) && (*p1) );
   }
   return( !(*p1 - *p2) );
} /* end Wstrcmp */

int WstrcmpN(char *p1, char *p2, int N)
/*****************************************************************************/
/*  PURPOSE: Compares 1st N characters of strings pointed to by p1 & p2.     */
/*  RETURNS: nonzero if they are equal, else 0                               */
/*****************************************************************************/
{
   while( (*p1++ == *p2++) && (N) ) N--;
   return(!N);
}

int Wfnd_substr(char *str, char *sub)
/*****************************************************************************/
/*  PURPOSE: finds if a given string (sub) is contained in another (str).    */ 
/*  RETURNS: Position of start of string (starting from 1), 0 if string      */
/*           is not found.                                                   */
/*****************************************************************************/
{
   char ch=(*sub);
   char *str2, *sub2;
   int i=0;

   sub++;
   if (*str)
   {
      do
      {
         i++;
         if (*str++ == ch) /* 1st char matches */
         {
            str2 = str;
            sub2 = sub;
            while ( (*str2) && (*str2 == *sub2) ) {str2++; sub2++;}
            if ( !(*sub2) ) return(i);
         }
      }
      while (*str);
      return(0);
   }
   else if (ch) return(0);
   else return(1);
}
int Wstrlen(char *p1)
/*****************************************************************************/
/*  PURPOSE: finds the number of characters in a string, not including \0.   */
/*  RETURNS: Length of string, not including null terminator.                */
/*****************************************************************************/
{
   int length=0;
   if (*p1) do length++; while (*(++p1));
   return (length);
}

int Wstrcpy(char *p1, char *p2)
/*****************************************************************************/
/*  PURPOSE: Copies string pointed at by p2 into p1.                         */
/*  RETURNS: Length of strings, not including null terminator.               */
/*****************************************************************************/
{
   int i=0;

   if (*p1++ = *p2++) do i++; while(*p1++ = *p2++);
   return(i);
}

void WstrcpyN(char *p1, char *p2, int N)
/*****************************************************************************/
/*  PURPOSE: Copies N characters from p2 into p1.                            */
/*****************************************************************************/
{
   if (N) do *p1++ = *p2++; while(--N);
}

void WstrcpyN_LOW(char *p1, char *p2, int N)
/*****************************************************************************/
/*  PURPOSE: Copies N characters from p2 into p1 while lowcasing.            */
/*****************************************************************************/
{
   if (N)
   {
      do 
      {
         *p1++ = Mlowcase(*p2);
         p2++;
      }
      while(--N);
   }
}

void WstrcpyN_UP(char *p1, char *p2, int N)
/*****************************************************************************/
/*  PURPOSE: Copies N characters from p2 into p1 while upcasing.             */
/*****************************************************************************/
{
   if (N)
   {
      do 
      {
         *p1++ = Mupcase(*p2);
         p2++;
      }
      while(--N);
   }
}

int WstrcpyUP(char *p1, char *p2)
/*****************************************************************************/
/*  PURPOSE: Copies string pointed at by p2 into p1, and upcases.            */
/*  RETURNS: Length of strings, not including null terminator.               */
/*****************************************************************************/
{
   int i=0;
   while( *p1++ = Mupcase(*p2) )
   {
      i++;
      p2++;
   }
   return(i);
}

int WstrcpyLOW(char *p1, char *p2)
/*****************************************************************************/
/*  PURPOSE: Copies string pointed at by p2 into p1, and lowcases.           */
/*  RETURNS: Length of strings, not including null terminator.               */
/*****************************************************************************/
{
   int i=0;
   while( *p1++ = Mlowcase(*p2) )
   {
      i++;
      p2++;
   }
   return(i);
}

int Wsafe_slowcase(char line[], int maxlen)
/*****************************************************************************/
/*  PURPOSE: Changes string to lowercase, not touching quoted strings.       */
/*  RETURNS: -1 if there is an unmatched quote, else 0.                      */
/*  NOTE   : algorithm fails if have two strings: 'ST1' STUFF 'ST2'          */
/*           if you wanna fix, need to know the language                     */
/*****************************************************************************/
{
   int i, ERROR=0;
   char quote;

   for (i=0; (line[i] && (i < maxlen)); i++)
   {
      line[i] = Mlowcase(line[i]);
      if (line[i] == 34 || line[i] == 39 || line[i] == '`')  /* is a " or ' */
      {
         quote = line[i++];
         while(line[i]) i++;
         while(line[i] != quote) i--;
         if (i > maxlen) ERROR = -1;
      }
   }
   return(ERROR);
}

int Wsafe_supcase(char line[], int maxlen)
/*****************************************************************************/
/*  PURPOSE: Changes line to uppercase, not touching quoted strings.         */
/*  RETURNS: -1 if there is an unmatched quote, else 0.                      */
/*  NOTE   : algorithm fails if have two strings: 'ST1' STUFF 'ST2'          */
/*           if you wanna fix, need to know the language                     */
/*****************************************************************************/
{
   int i, ERROR=0;
   char quote;

   for (i=0; (line[i] && (i < maxlen)); i++)
   {
      line[i] = Mupcase(line[i]);
      if (line[i] == 34 || line[i] == 39 || line[i] == '`')  /* is a " or ' */
      {
         quote = line[i++];
         while ( (line[i] - quote) && (line[i]) && (i < maxlen) ) i++;
         if ( line[i] != quote ) ERROR = -1;  /* unmatched quote */
      }
   }
   return(ERROR);
}

void Wslowcase(char *p1)
/*****************************************************************************/
/*  PURPOSE: Changes to lowercase entire string pointed to by p1.            */
/*****************************************************************************/
{
   while(*p1 = Mlowcase(*p1)) p1++;
}

void Wsupcase(char *p1)
/*****************************************************************************/
/*  PURPOSE: Changes to uppercase entire string pointed to by p1.            */
/*****************************************************************************/
{
   while(*p1 = Mupcase(*p1)) p1++;
}

void Wsstrip(char *p1)
/*****************************************************************************/
/*  PURPOSE: strip all white spaces from string                              */
/*****************************************************************************/
{
   char *p2=p1;
   do
   {
      if (Mciswspace(*p2)) p2++;
      else *p1++ = *p2++;
   }
   while (*p1);
}

void Wtab2spcs(char *p, int N)
/*****************************************************************************/
/*  PURPOSE: replace all tabs in string p with N spaces                      */
/*****************************************************************************/
{
   char tline[256];
   int i;
   int Wstrcpy(char *p1, char *p2);

   while (*p)
   {
      if (*p == '\t')
      {
         Wstrcpy(tline, p+1);
         i = N;
         while (N--) *p++ = ' ';
         Wstrcpy(p, tline);
      }
      else p++;
   }
}

int Wstr2int(char *str, int *iptr)
/*****************************************************************************/
/*  PURPOSE: read an integer from string str into *iptr                      */
/*  RETURNS: number of characters read in                                    */
/*****************************************************************************/
{
   int i, j;

   sscanf(str, "%d", iptr);
   for (i=0, j=Mabs(*iptr); j > 0; i++) j /= 10;
   if (*iptr == 0) i=1;
   if (str[0] == '+' || str[0] == '-') i++;
   return(i);
}

void Wsafe_mws2spc(char *p1)
/*****************************************************************************/
/*  PURPOSE: replaces contiguous white spaces with 1 space, skip quotes.     */
/*****************************************************************************/
{
   char *p2;

   p2 = p1;

   while (*p2)
   {
      if (*p1 == '"')
      {
         do *p2++ = *p1++; while(*p1 != '"');
         *p2++ = *p1++;
         continue;
      }
      if (Mciswspace(*p1))
      {
         *p2++ = ' ';
         while (Mciswspace(*p1)) p1++;
         continue;
      }
      while ( (*p2) && !(Mciswspace(*p1)) ) *p2++ = *p1++;
   }
}

void Wremove_trailing_blanks(char *p)
/*****************************************************************************/
/*  PURPOSE: Remove trailing whitespace from string p.                       */
/*****************************************************************************/
{
   char *st=p;

   if ( !(*p) ) return;
   do p++; while (*p);
   p--;
   while ( (Mciswspace(*p)) && (p != st) ) p--;
   if ( Mciswspace(*p) )
   {
      *p = '\n';
      p[1] = '\0';
   }
   else
   {
      p[1] = '\n';
      p[2] = '\0';
   }
}

void CharSet(int N, char *x, char val)
/*****************************************************************************/
/* Set N elements starting at x to val                                       */
/*****************************************************************************/
{
   int i;
   for (i=0; i < N; i++) x[i] = val;
}

int commandcpy(char *out, char *in)
/*****************************************************************************/
/* PURPOSE: copy in to out, remove all leading spaces, put 1 space after     */
/*          first word, lowcase first word, then copy rest string unchanged. */
/* RETURNS: Length of first word (the possible command).                     */
/*****************************************************************************/
{
   int i=0;
   while( Mciswspace(*in) ) in++;   /* skip leading white spaces */

   while( (*in) && !Mciswspace(*in) )  /* copy first word */
   {
      *out++ = Mlowcase(*in);
      in++;
      i++;
   }
/*
 * Only 1 space follows word, and copy rest of line unaltered
 */
   *out++ = ' ';
   while( Mciswspace(*in) ) in++;
   while (*out++ = *in++);
   return(i);
}

void keycpy(char *out, char *in)
/*****************************************************************************/
/* PURPOSE: copy in to out, remove all leading spaces, lowcase and put 1     */
/*          space after each word, and leave stuff in ` ` alone.             */
/*****************************************************************************/
{
   char *p, *ch;

   p = out;
   while (*in)
   {
      while( Mciswspace(*in) ) in++;    /* skip leading spaces */

      if (*in == '`')                   /* don't mess with `  ` quotes */
      {
         ch = in;
         while (*ch) ch++;
         while (*ch != '`') ch--;
         while (in != ch) *out++ = *in++;
         *out++ = *in++;
      }

      while( (*in) && !Mciswspace(*in) )  /* copy word */
      {
         *out++ = Mlowcase(*in);
         in++;
      }
      *out++ = ' ';                 /* white spaces collapse to 1 space */
      if (*in) in++;
   }
   *out = '\0';
}

/*===========================================================================*/
/*  These functions print out error and warning messages from extract        */
/*===========================================================================*/

void ExtWarn(EXTENV *EE, char *form, ...)
{
   FILE2 *fp;
   va_list argptr;
   char cline[256];
   int i;

   va_start(argptr, form);
   vsprintf(cline, form, argptr);
   va_end(argptr);
/*
 * Remove newlines from cline
 */
   for (i=0; cline[i]; i++);
   i--;
   if (cline[i] == '\n') cline[i--] = '\0';

   if (EE)
   {
      fflush(EE->FpOut->Fp);
      fprintf(stderr, "\nExtract warning \'%s\'.\n", cline);
      fprintf(stderr, "Input file chain:\n");
      fprintf(stderr, "   Warning occured on line %d of file %s.\n",
              EE->FpIn->LineNo, EE->FpIn->Fnam); 
      for (fp=EE->FpIn->prev; fp; fp = fp->prev)
         fprintf(stderr, "      Which was extracted from line %d of file %s.\n",
                 fp->LineNo, fp->Fnam); 
      fprintf(stderr, "\nWarning occured after line %d of output file %s.\n",
              EE->FpOut->LineNo, EE->FpOut->Fnam); 

   }
   else fprintf(stderr, "\nExtract warning \'%s\'\n", cline);
}

void ExtErr(EXTENV *EE, char *form, ...)
{
   FILE2 *fp;
   va_list argptr;
   char cline[256];
   int i;

   va_start(argptr, form);
   vsprintf(cline, form, argptr);
   va_end(argptr);
/*
 * Remove newlines from cline
 */
   for (i=0; cline[i]; i++);
   i--;
   if (cline[i] == '\n') cline[i--] = '\0';

   if (EE)
   {
      if (EE->FpOut && EE->FpOut->Fp) fflush(EE->FpOut->Fp);
      fprintf(stderr, "\nExtract ERROR \'%s\'.\n", cline);
      if (EE->FpIn)
      {
         fprintf(stderr, "Input file chain:\n");
         fprintf(stderr, "   Error occured on line %d of file %s.\n",
                 EE->FpIn->LineNo, EE->FpIn->Fnam); 
         for (fp=EE->FpIn->prev; fp; fp = fp->prev)
            fprintf(stderr, 
                    "      Which was extracted from line %d of file %s.\n",
                    fp->LineNo, fp->Fnam); 
         fprintf(stderr, "\nError occured after line %d of output file %s.\n\n",
                 EE->FpOut->LineNo, EE->FpOut->Fnam); 

      }
   }
   else fprintf(stderr, "\nExtract ERROR \'%s\'\n\n", cline);

   exit(1);
}

void HandleAtEscape(char *ln)
{
   int i;

   while (i = Wfnd_substr(ln, "@(@)"))
   {
      Wstrcpy(ln+i, ln+i+3);
      ln += i;
   }
}
/*===========================================================================*/
/* These routines do basic file stuff                                        */
/*===========================================================================*/

void PutLn(EXTENV *EE, char *line)
{
   int ExtLn, h, i=0, k;
   static int j=0;
   char *tln;
/* 
 * Check if line needs to be joined with next line
 */
   if (EE->Joining)
   {
      while(line[i]) i++;
      if (i)
      {
         i--;
         while(Mciswspace(line[i]) && i) i--;
      }
      ExtLn = (line[i] == '\\') && (i);
      if (ExtLn) ExtLn = line[i-1] == '@';
/*
 *    If we are extending a line, or have an extended line in memory,
 *    save the present line, and merge it with any previously stored lines
 */
      if ( ExtLn || JoinLn )
      {
         tln = malloc(i + j);
         for (k=0; k != j; k++) tln[k] = JoinLn[k];
         if (ExtLn) h = i + j - 1;
         else h = i + j + 1;
         for (; k < h; k++) tln[k] = line[k-j];
         tln[k] = '\n';
         tln[k+1] = '\0';
         j = h;
         if (JoinLn) free(JoinLn);
         JoinLn = tln;
      }
      else tln = line;
   }
   else 
   {
      tln = line;
      ExtLn = 0;
   }
/*
 * If this line wasn't extended, can finally dump to file
 */
   if (!ExtLn)
   {
      EE->FpOut->LineNo++;
      if (!LnCount)
      {
         ApplyFlags(EE, tln);
         HandleAtEscape(tln);
         fputs(tln, EE->FpOut->Fp);
      }
      else if (EE->FpOut->LineNo == LnNums[nLnNums])
      {
         fprintf(Warn, 
                 "\nLine %d of extracted file corresponds to line %d of \'%s\'\n",
                 EE->FpOut->LineNo, EE->FpIn->LineNo, EE->FpIn->Fnam);
         nLnNums--;
         if (nLnNums == 0)
         {
            fprintf(Warn, "\n\nEXTRACT finished translating line numbers.\n\n");
            exit(0);
         }
      }
      if (JoinLn) free(JoinLn);
      JoinLn = NULL;
      j = 0;
   }
}

int GetLn(EXTENV *EE, char *line)
{
   if (ExtDone) return(0);
   EE->FpIn->LineNo++;
   return( (int) fgets(line, LNLEN, EE->FpIn->Fp) );
}

FILE2 *OpenFile(EXTENV *EE, char *Fnam, char *mode)
{
   char yorn;
   FILE2 *fp;

   fp = (FILE2 *) malloc(sizeof(*fp));
   Wstrcpy(fp->Fnam, Fnam);
   fp->LineNo = 0;

   if (mode[0] == 'w')
   {
      fp->prev = EE->FpOut;
      if ( Wstrcmp(Fnam, "stdout") )
      {
         fp->Fp = stdout;
         return(fp);
      }
      else if ( Wstrcmp(Fnam, "stderr") )
      {
         fp->Fp = stderr;
         return(fp);
      }

      if (EE->Flags[F_Verb] > 2) fprintf(Warn, "Creating file %s.\n", Fnam);

      if (EE->Flags[F_Query])
      {
         if ( !access(Fnam, 0) )
         {
            fprintf(Warn, "File %s already exists.  Overwrite?", Fnam);
            fflush(stdin);
            yorn = getchar();
            if ( (yorn != 'y') && (yorn != 'Y') ) exit(0);
         }
      }
   }
   else if ( (mode[0] == 'r') && (mode[1] == '\0') )
   {
      fp->prev = EE->FpIn;
      if ( Wstrcmp(Fnam, "stdin") )
      {
         fp->Fp = stdin;
         return(fp);
      }

      if (EE->Flags[F_Verb] > 2) 
         fprintf(Warn, "Opening file \'%s\' for input . . .\n", Fnam);
      
      if ( access(Fnam, 0) )
      {
         fprintf(Warn, "Cannot find input file \'%s\'\n", Fnam);
         exit(1);
      }
   }

   fp->Fp = fopen(Fnam, mode);
   if (fp->Fp == NULL) ExtErr(EE, "Error opening file %s",Fnam);
   return(fp);
}

void CloseFile(EXTENV *EE, FILE2 *fp)
{
   if (JoinLn) if (EE->FpOut == fp) PutLn(EE, "\0");
   if (EE->Flags[F_Verb] > 2) fprintf(Warn, "Closing file \'%s\'.\n", fp->Fnam);

   if ( (fp->Fp != stderr) && (fp->Fp != stdin) && (fp->Fp != stdout) )
   {
      if ( fclose(fp->Fp) == EOF )
         ExtErr(EE, "Error closing file %s", fp->Fnam);
   }
   free(fp);
}  /* end close_file */


/*===========================================================================*/
/*  These functions all deal with breaking lines into their respective words */
/*===========================================================================*/

static WORDS *GetWord(char *wrd)
/*****************************************************************************/
/* PURPOSE: Safely allocates word of correct length                          */
/* RETURNS: Allocated WORD.                                                  */
/*****************************************************************************/
{
   WORDS *wp;
   wp = malloc(sizeof(WORDS));
   wp->word = malloc( (Wstrlen(wrd)+1)*sizeof(char) );
   Wstrcpy(wp->word, wrd);
   wp->next = NULL;
   return(wp);
}

static WORDS *KillWord(WORDS *wbase, WORDS *wkill)
/*****************************************************************************/
/* PURPOSE: Kills single word wkill in list of words starting with wbase.    */
/* RETURNS: Possibly new wbase.                                              */
/*****************************************************************************/
{
   WORDS *wptr;

   if (wkill == wbase) wbase = wbase->next;
   else
   {
      for (wptr=wbase; wptr->next != wkill; wptr = wptr->next);
      wptr->next = wkill->next;
   }
   free(wkill->word);
   free(wkill);
   return(wbase);
}

static void KillWords(WORDS *wbase)
/*****************************************************************************/
/* PURPOSE: Frees space used by words, starting at wbase.                    */
/*****************************************************************************/
{
   while(wbase) wbase = KillWord(wbase, wbase);
}

void PrintWords(WORDS *wbase)
/*****************************************************************************/
/* PURPOSE: print words pointed to by wbase (debugging routine)              */
/*****************************************************************************/
{
   printf("Words: ");
   while(wbase)
   {
      printf("'%s' ",wbase->word);
      wbase = wbase->next;
   }
   printf("\n");
}

WORDS *GetVars(char *line, char Ab, char Ae)
/*****************************************************************************/
/* PURPOSE: splits a line into its seperate variables for @declare.  Ab and  */
/*          Ae are the array beginning and ending characters for your        */
/*          language ([] for C, and () for Fortran).  Variables are          */
/*          seperated by whitespace(s) and/or a comma.                       */
/*****************************************************************************/
{
   int i=0, j, k;
   WORDS *wbase=NULL, *wp;
   static WORDS *wptr=NULL;
   char wrd[LNLEN];

   if (line == NULL)
   {
      wptr = NULL;
      return(NULL);
   }
   while(Mciswspace(line[i])) i++;
   if (line[i] == '\0') return(NULL);
   wbase = GetWord(" ");
   if (wptr)
   {
      wp = wptr;
      wptr->next = wbase;
   }
   else wp = wbase;
   wptr = wbase;

   while(line[i])
   {
      j = 0;
      while(line[i] != ',')  /* get one word */
      {
         if (line[i] == '@')  /* check for sticky space */
         {
            if (line[i+1] == '^')
            {
               wrd[j++] = ' ';
               i += 2;
               continue;
            }
         }
         if (Mciswspace(line[i]))
         {
            while(Mciswspace(line[i])) i++;
            if (line[i] != Ab) break;
            else continue;
         }
         if (line[i] == Ab)  /* have an array declaration */
         {
            k = 0;
            do
            {
               wrd[j++] = line[i];
               if (line[i] == Ab) k++;
               else if (line[i] == Ae) k--;
               i++;
            }
            while(k);
            if (!line[i]) break;
         }
         else wrd[j++] = line[i++];
      }
      wrd[j] = '\0';
      wptr->next = GetWord(wrd);
      wptr = wptr->next;
      if (line[i] == ',') 
      {
         i++;
         while(Mciswspace(line[i])) i++;
      }
   }
   if (wptr == wbase) wptr = wbase = KillWord(wp, wbase);
   else wbase = KillWord(wp, wbase);
   return(wbase);
}

WORDS *GetArgs(EXTENV *EE, char *line)
/*****************************************************************************/
/* PURPOSE: splits a line into its seperate words by splitting on whitespcs, */
/*          accepts args in double quotes as one arg.                        */
/*****************************************************************************/
{
   int i=0, j;
   WORDS *wptr, *wbase=NULL;
   char word[LNLEN];

   while(Mciswspace(line[i])) i++;
   wptr = wbase = GetWord(" ");

   while(line[i])
   {
      if (line[i] == '\"')
      {
         i++;
         for (j=0; (line[i] != '\"') && line[i]; word[j++] = line[i++]);
         if (!line[i]) ExtErr(EE, "Unmatched double quote.");
         i++;
      }
      else
      {
         j = 0;
         while(!Mciswspace(line[i]) && line[i])
         {
            if (line[i] != '@' || line[i+1] != '^') 
               word[j++] = line[i++];
            else  /* sticky space */
            {
               word[j++] = ' ';
               i += 2;
            }
         }
      }
      word[j] = '\0';
      wptr->next = GetWord(word);
      wptr = wptr->next;
      while(Mciswspace(line[i])) i++;
   }
   return( KillWord(wbase, wbase) );
}

WORDS *GetWords(char *line)
/*****************************************************************************/
/* PURPOSE: splits a line into its seperate words by splitting on whitespcs  */
/*****************************************************************************/
{
   int i=0, j;
   WORDS *wptr, *wbase;
   char word[LNLEN];

   while(Mciswspace(line[i])) i++;
   wptr = wbase = GetWord(" ");

   while(line[i])
   {
      j = 0;
      while(!Mciswspace(line[i]) && line[i])
      {
         if (line[i] != '@' || line[i+1] != '^') 
            word[j++] = line[i++];
         else  /* sticky space */
         {
            word[j++] = ' ';
            i += 2;
         }
      }
      word[j] = '\0';
      wptr->next = GetWord(word);
      wptr = wptr->next;
      while(Mciswspace(line[i])) i++;
   }
   return( KillWord(wbase, wbase) );
}

FILE *CreateListFile(EXTENV *EE, char *EndStr, int EndLen, char *line,
                     char *tline)
{
   FILE2 fp, *FpHold;
   char fsave[6];
   int i, joining;

   joining = EE->Joining;
   EE->Joining = 0;
   sprintf(fp.Fnam, "Line%d_of_%s\n",EE->FpIn->LineNo, EE->FpIn->Fnam);
   fsave[0] = EE->Flags[F_Case];
   fsave[1] = EE->Flags[F_RemBlank];
   fsave[2] = EE->Flags[F_Ugly];
   fsave[3] = EE->Flags[F_RepTab];
   fsave[4] = EE->Flags[F_Clint];
   fsave[5] = EE->Flags[F_LLWarn];
   EE->Flags[F_Case] = EE->Flags[F_RemBlank] = EE->Flags[F_Ugly] =
                       EE->Flags[F_RepTab] = EE->Flags[F_Clint]  =
                       EE->Flags[F_LLWarn] = 0;
   fp.LineNo = 0;
   fp.Fp = tmpfile();
   FpHold = EE->FpOut;
   EE->FpOut = &fp;
   while(GetLn(EE, line))
   {
      i = commandcpy(tline, line) + 1;
      if (i == EndLen) if ( WstrcmpN(tline, EndStr, EndLen) ) break;
      HandleLine(EE, line);
   }
   EE->FpOut = FpHold;
   EE->Flags[F_Case]     = fsave[0];
   EE->Flags[F_RemBlank] = fsave[1];
   EE->Flags[F_Ugly]     = fsave[2];
   EE->Flags[F_RepTab]   = fsave[3];
   EE->Flags[F_Clint]    = fsave[4];
   EE->Flags[F_LLWarn]   = fsave[5];
   EE->Joining = joining;
   return(fp.Fp);
}

WORDS *fGetWords(EXTENV *EE, char *EndStr, int EndLen, char *line, char *tline)
/*****************************************************************************/
/* PURPOSE: Gets words from the input file until EndStr is found.            */
/*****************************************************************************/
{
   FILE *fp;
   WORDS *wptr, *wp;

   fp = CreateListFile(EE, EndStr, EndLen, line, tline);
   rewind(fp);
   if ( fgets(line, LNLEN, fp) )
   {
      do /* skip leading blank lines */
      {
         wp = wptr = GetWords(line);
         if (wp == NULL) if ( !fgets(line, LNLEN, fp) ) break;
      }
      while (wp == NULL);

      while( fgets(line, LNLEN, fp) ) 
      {
         while (wp->next) wp = wp->next;
         wp->next = GetWords(line);
      }
   }
   fclose(fp);
   return(wptr);
}

WORDS *fGetVars(EXTENV *EE, char *EndStr, int EndLen, char *line, char *tline,
                char Ab, char Ae)
/*****************************************************************************/
/* PURPOSE: Gets variables from the input file until EndStr is found.        */
/*****************************************************************************/
{
   FILE *fp;
   WORDS *wptr=NULL, *wp;

   fp = CreateListFile(EE, EndStr, EndLen, line, tline);
   rewind(fp);

   if ( fgets(line, LNLEN, fp) )
   {
      do
      {
         wptr = GetVars(line, Ab, Ae);
         if (!wptr) if ( !fgets(line, LNLEN, fp) ) break;
      }
      while (wptr == NULL); /* skip leading blank lines */
      while( fgets(line, LNLEN, fp) ) GetVars(line, Ab, Ae);
      GetVars(NULL, Ab, Ae);
   }
   fclose(fp);
   return(wptr);
}


WORDS *GetKeys(char *line)
/*****************************************************************************/
/* PURPOSE: Gets keyargs from keyline, puts a space at end.                  */
/*****************************************************************************/
{
   int i=0, j;
   WORDS *wptr, *wbase;
   char word[LNLEN];

   while(Mciswspace(line[i])) i++;
   wptr = wbase = GetWord(" ");

   while(line[i])
   {
      word[0] = ' ';
      for (j=1; !Mciswspace(line[i]); word[j++] = line[i++]);
      word[j++] = ' ';
      word[j] = '\0';
      wptr->next = GetWord(word);
      wptr = wptr->next;
      while(Mciswspace(line[i])) i++;
   }
   return( KillWord(wbase,wbase) );
}

WORDS *CreateKeyLine0(EXTENV *EE, WORDS *wbase, char *ln)
{
   WORDS *wp, *wp0;

   wp = GetKeys(ln);
   if (wp)
   {
      if (!wbase) wbase = wp;
      else
      {
         for (wp0=wbase; wp0->next; wp0 = wp0->next);
         wp0->next = wp;
      }
      while (wp->next) wp = wp->next;
      if (Wfnd_substr(wp->word, "@\\"))  /* ln extension */
      {
         wbase = KillWord(wbase, wp);
         assert(GetLn(EE, ln));
         CreateKeyLine0(EE, wbase, ln);
      }
   }
   return(wbase);
}

char *CreateKeyLine(EXTENV *EE, char *ln)
{
   char *tln;
   WORDS *wp, *wbase;
   int i;

   wbase = CreateKeyLine0(EE, NULL, ln);
   for (wp=wbase, i=0; wp; wp = wp->next) i += Wstrlen(wp->word)+1;
   if (i >= LNLEN) ExtErr(EE, "Lame-ass static ARGSTACK allocation exceeded");
   tln = malloc((i+1)*sizeof(char));
   assert(tln);
   for (wp=wbase, i=0; wp; wp = wp->next)
   {
      i += WstrcpyLOW(tln+i, wp->word);
      tln[i++] = ' ';
   }
   tln[i] = '\0';
   KillWords(wbase);

   return(tln);
}

void UpLowWords(char cas, WORDS *wbase)
/*****************************************************************************/
/* PURPOSE: if cas == 'u', upcases all words, otherwise, lowcases all words. */
/*****************************************************************************/
{
   void (*fcase)(char *);

   if (cas == 'u') fcase = Wsupcase;
   else fcase = Wslowcase;

   while(wbase)
   {
      fcase(wbase->word);
      wbase = wbase->next;
   }
}

void RemQuoteWords(WORDS *wp)
/*****************************************************************************/
/* PURPOSE: Removes quotes around words, if they exist, and stops when a     */
/*          word starts with -                                               */
/*****************************************************************************/
{
   int i;
   while (wp)
   {
      if (wp->word[0] == '-') break;
      if (wp->word[0] == '\"')
      {
         i = Wstrcpy(wp->word, wp->word+1) - 1;
	 assert(wp->word[i] == '\"');
	 wp->word[i] = '\0';
      }
      wp = wp->next;
   }
}

WORDS *SortWords(char *cas, WORDS *wbase)
/*****************************************************************************/
/* PURPOSE: sorts words in alphabetic order, and up or low cases them based  */
/*          on *cas.                                                         */
/*****************************************************************************/
{
   int i;
   WORDS *wbase2=NULL, *wptr, *wptr2, *prev;

   if (cas) UpLowWords(*cas, wbase);

   while(wbase)
   {
/*
 *    Find largest word left in original list
 */
      wptr2 = wbase;
      for (wptr=wbase->next; wptr; wptr=wptr->next)
      {
         for (i=0; !(wptr->word[i] - wptr2->word[i]) && (i < SUBLEN); i++);
         if (wptr->word[i] > wptr2->word[i]) wptr2 = wptr;
      }
/*
 *    Remove largest word from original list
 */
      for (wptr=wbase; (wptr != wptr2); wptr = wptr->next) prev = wptr;
      if (wptr == wbase) wbase = wbase->next;
      else prev->next = wptr->next;
/*
 *    Put largest word on second list
 */
      wptr2->next = wbase2;
      wbase2 = wptr2;
   }
   return(wbase2);
}

int CountWords(WORDS *wp)
/*****************************************************************************/
/* RETURNS: Number of words in list starting at wp                           */
/*****************************************************************************/
{
   int i;
   for (i=0; wp; wp = wp->next, i++);
   return(i);
}

/*===========================================================================*/
/* These routines all work on extract's macros.                              */
/*===========================================================================*/
EXTMAC *FindMac(char *handle)
{
   int i;
   EXTMAC *ptr;

   i = Wstrlen(handle);
   for(ptr=MacroBase; ptr; ptr=ptr->next)
   {
      if (ptr->HanLen == i + 3)
         if( WstrcmpN(&(ptr->Handle[2]), handle, i) ) 
            if( ptr->Handle[i+2] == ')' ) break;
   }
   return(ptr);
}

/************************************************************************/
/*   The routines push_macro & pop_macro are the heart of extract's     */
/*   macro substitution utility.  A macro is defined by:                */
/*   @define <handle> @<substitution>@                                  */
/*   The @define must followed by one and only one space.               */
/*   The handle is everything until                                     */
/*   the next whitespace.  The begin and end of the substitute string   */
/*   are demarked by the @ character.  Therefore, if we wanted to       */
/*   substitute "joe" for "bob" in the text, we could have following    */
/*   definition:                                                        */
/*   @define bob @joe@                                                  */
/*   the delimiter is @(handle)                                         */
/*   So, using the macro we've defined above,                           */
/*   we would have the following:                                       */
/*   "Well, @(bob) is a fairy."                                         */
/*   Once extracted, this would read, "Well, joe is a fairy.".          */
/*   Macros are based on a stack, so to use old @define's you must      */
/*   do an @undef.                                                      */
/************************************************************************/

EXTMAC *PushMacro2(EXTENV *EE, int PUNY, char *handle, char *sub)
{
   EXTMAC *mp;
   PUNYMAC *pp;

   mp = Wmalloc(sizeof(EXTMAC));
   mp->next = MacroBase;
   MacroBase = mp;
   mp->HanLen = Wstrlen(handle) + 3;
   mp->Handle = Wmalloc(mp->HanLen+1);
   mp->Handle[0] = '@';
   mp->Handle[1] = '(';
   Wstrcpy(mp->Handle+2, handle);
   mp->Handle[mp->HanLen-1] = ')';
   mp->Handle[mp->HanLen] = '\0';
   mp->SubLen = Wstrlen(sub);
   mp->Sub = Wmalloc(mp->SubLen+1);
   Wstrcpy(mp->Sub, sub);
   if ( Wfnd_substr(mp->Sub, mp->Handle) )
      ExtErr(EE, "No recursive macro definitions allowed.");
   if (PUNY)
   {
      pp = Wmalloc(sizeof(PUNYMAC));
      pp->next = EE->MyPunyMacs;
      EE->MyPunyMacs = pp;
      pp->mp = mp;
   }
   return(mp);
}

void PushMacro(EXTENV *EE, char *line)
{
   int i, j;
   char *h, *s, *t;

   h = line + 8;
   for (i=8; (!Mciswspace(line[i])); i++)
      if (line[i] == '@' || line[i] == '(' || line[i] == ')')
         ExtErr(EE, "Prohibited character in macro handle, line=\'%s\'",line);
   j = i;  /* where handle ends */
   i++;
   while( (Mciswspace(line[i])) && (line[i]) ) i++;
   if (line[i++] != '@') ExtErr(EE, "Bad macro definition: \'%s\'.", line);
   s = line + i;
   while (line[i]) i++;
   while (line[i] != '@') i--;
   if (s-1 == line + i) ExtErr(EE, "Bad macro definition: \'%s\'.", line);
   line[i] = '\0';
   line[j] = '\0';
   PushMacro2(EE, EE->Flags[F_FragMac], h, s);
}

int PopThisMacro(EXTENV *EE, EXTMAC *killme)
{
   int i;
   EXTMAC *ptr, *tptr;

   for(ptr=MacroBase; ptr && ptr != killme; ptr=ptr->next) tptr = ptr;
   if (ptr)
   {
      if (ptr == MacroBase) MacroBase = ptr->next;
      else tptr->next = ptr->next;
      free(ptr->Handle);
      free(ptr->Sub);
      free(ptr);
      return(1);
   }
   return(0);
}

int PopMacro2(EXTENV *EE, char *handle)
{
   int i;
   EXTMAC *ptr, *tptr;

   i = Wstrlen(handle);
   for(ptr=MacroBase; ptr; ptr=ptr->next)
   {
      if (ptr->HanLen == i + 3)
         if( WstrcmpN(&(ptr->Handle[2]), handle, i) ) 
            if( ptr->Handle[i+2] == ')' ) break;
      tptr = ptr;
   }
   if (ptr)
   {
      if (ptr == MacroBase) MacroBase = ptr->next;
      else tptr->next = ptr->next;
      free(ptr->Handle);
      free(ptr->Sub);
      free(ptr);
      return(1);
   }
   return(0);
}

int PopMacro(EXTENV *EE, char *line)
{
   char ch, *han;
   int i, j;

   han = line + 7;
   for (i=0; han[i] && !Mciswspace(han[i]); i++)
      if (han[i] == '(' || han[i] == ')' || han[i] == '@')
         ExtErr(EE, "Malformed @undef: \'%s\'", line);
   ch = han[i];
   han[i] = '\0';
   j = PopMacro2(EE, han);
   han[i] = ch;
   return(j);
}

void MakeMacSub(char *line, int I, EXTMAC *mp)
/*****************************************************************************/
/* PURPOSE: substitute mp->Sub at &line[I].                                  */
/*****************************************************************************/
{
   char ch1, ch='l';
   char *p, *st, *sub=mp->Sub;
   char lstr[32];
   int i=I, k, Spcs=0, len=mp->SubLen, sublen=mp->SubLen, hanlen=mp->HanLen;
   void (*cpyfuncN)(char *, char *, int);
   cpyfuncN = WstrcpyN;

   if (i > 2)  /* could have some formatting going on */
   {
/*
 *    If we have @up or @low, set cpyfuncN appropriatly
 */
      if (line[i-1] == 'p') /* maybe @up */
      {
         if ( (line[i-2] == 'u') && (line[i-3] == '@') )
         {
            i -= 3;
            cpyfuncN = WstrcpyN_UP;
         }
      }
      else if (i > 3)
      {
         if (line[i-4] == '@')
         {
            if (line[i-3] == 'l' && line[i-2] == 'o' && line[i-1] == 'w')
            {
               i -= 4;
               cpyfuncN = WstrcpyN_LOW;
            }
            else if (line[i-3] == 'l' && line[i-2] == 'e' && line[i-1] == 'n')
            {
               sprintf(lstr, "%d", mp->SubLen);
               len = sublen = Wstrlen(lstr);
               sub = lstr;
               i -= 4;
            }
         }
      }
/*
 *    See if we have formating of type @#[l,r,c] going on
 */
      if (i > 2)
      {
         ch1 = Mlowcase(line[i-1]);
         if ( (ch1 == 'l') || (ch1 == 'r') || (ch1 == 'c') )
         {
            if (Mcisnum(line[i-2]))
            {
               for (k=i-3; k && Mcisnum(line[k]); k--);
               if (line[k] == '@') /* it is one of those formats */
               {
                  line[i-1] = '\0'; /* gonna overwrite this later anyway */
                  sscanf(line+k+1, "%d", &len);
                  if (len < sublen) sublen = len;
                  i = k;
                  ch = ch1;
               }
            }
         }
      }
   }
   hanlen += I - i;
/*
 * Figure out how many spaces to put before mp->Sub due to formatting
 */
   if (len != sublen)
   {
      if (ch == 'r') Spcs = len - sublen;
      else if (ch == 'c') Spcs = (len - sublen) / 2;
   }
/*
 * If formatted Sub longer than handle, move last part of line to right
 */
   if (len > hanlen)
   {
      p = line + I + mp->HanLen;
      k = len - hanlen;  /* number of elements to move string */
      st = p - 1;
      while (*p) p++;
      do p[k] = *p; while (--p != st);
   }
/*
 * If Macro handle longer than formatted Sub, move last part of line to left
 */
   else if (len != hanlen) Wstrcpy(line+i+len, line+I+mp->HanLen);
   for (k=Spcs; k; k--) line[i++] = ' ';  /* handle preceding spaces */
   cpyfuncN(line+i, sub, sublen);     /* Copy Macro sub string */
   i += sublen;                           /* handle trailing spaces */
   for (k=len - Spcs - sublen; k; k--) line[i++] = ' ';
}

int ExpandMacro(EXTMAC *macp, char *line)
{
   int i, j, k, len, Expanded=0;
   char ch, tline[LNLEN];
   int (*cpyfunc)(char *, char *);

   while ( (i = Wfnd_substr(line, macp->Handle)) )
   {
      Expanded = 1;
      MakeMacSub(line, i-1, macp);
   }
   return(Expanded);
}

int ExpandThisMacro(EXTENV *EE, char *line, int i, int hlen)
{
   EXTMAC *mp;
   
   for (mp=MacroBase; mp; mp = mp->next)
      if (mp->HanLen == hlen) if ( WstrcmpN(line+i, mp->Handle, hlen) ) break;
   if (mp)
   {
      MakeMacSub(line, i, mp);
      return(1);
   }
   else return(0);
}

void MacroSub(EXTENV *EE, char *line)
{
   char *p;
   int i, hlen, il=0, DONE=1;
   EXTMAC *macp;

/*
 * Try substituting macros from left to right in line; if this fails, use
 * slower but more general method
 */
   while ( i = Wfnd_substr(line+il, "@(") )
   {
      il += i - 1;
      p = line + il + 2;
      for (hlen=2; (*p) && (*p != ')'); hlen++, p++);
      if (*p) hlen++;
      else return;  /* no macros without end paren */
      if (!ExpandThisMacro(EE, line, il, hlen))
      {
         DONE=0;
         break;
      }
   }
   if (!DONE)
   {
      macp=MacroBase; 
      while(macp)
      {
         i = Wfnd_substr(line, "@(");
         if (!i) break;
         if ( ExpandMacro(macp, line) ) macp = MacroBase;
         else macp = macp->next;
      }
   }
}  /* end of MacroSub */

void KillMyMacros(EXTENV *EE)
{
   EXTMAC *mp;

   while(MacroBase != EE->MyMacBeg)
   {
      mp = MacroBase;
      MacroBase = mp->next;
      free(mp->Handle);
      free(mp->Sub);
      free(mp);
   }
}


/*===========================================================================*/
/* These functions deal with key manipulations.                              */
/*===========================================================================*/
void KillThisKey(EXTENV *EE, KEYS *DeadKey)
{
   char line[LNLEN];
   KEYS *key, *prev=NULL;
   ARGSTACK *args;

   assert(EE->KeyBase != NULL);
   for (key=EE->KeyBase; key != DeadKey; key = key->next) prev = key;

   assert( PopThisMacro(EE, key->KeyMac) );  /* pop automatic macro */
/*
 * Remove key from list
 */
   if (key == EE->KeyBase) EE->KeyBase = key->next;
   else prev->next = key->next;

   while (key->ArgStack)
   {
      args = key->ArgStack->next;
      free(key->ArgStack);
      key->ArgStack = args;
   }
   if (key->MyArgs) free(key->MyArgs);
   free(key->KeyHandle);
   free(key->Match);
   free(key);
}

void KillKey(EXTENV *EE, char *s)
{
   int slen;
   KEYS *key, *prev=NULL;

   slen = Wstrlen(s);
   key = EE->KeyBase;
   while(key)
   {
      if (slen+2 == key->HanLen) /* possible match if they're same length */
      {
         if ( WstrcmpN(s, &key->KeyHandle[1], slen) )
         {
            KillThisKey(EE, key);
            if (prev) key = prev->next;
            else key = EE->KeyBase;
         }
         else {  prev = key;  key = key->next;  }
      }
      else {  prev = key;  key = key->next;  }
   }
}

void AddKey(EXTENV *EE, char *s)
{
   char *cp, *cp2;
   int i, j, BegAt, EndAt, len, err=0;
   KEYS *key;

   key = Wmalloc(sizeof(KEYS));
   key->next = EE->KeyBase;
   EE->KeyBase = key;
   for(i=0; s[i] != '=' && s[i]; i++);
   if (!(s[i])) ExtErr(NULL, "Bad key input \'%s\'.", s);
   if (!(s[i+1])) ExtErr(NULL, "Bad key input \'%s\'.", s);
   key->HanLen = i + 2;
   key->KeyHandle = Wmalloc(key->HanLen + 1);
   key->KeyHandle[0] = '@';
   WstrcpyN_LOW(key->KeyHandle+1, s, i);
   key->KeyHandle[key->HanLen-1] = ' ';
   key->KeyHandle[key->HanLen] = '\0';
   cp2 = s + i + 1;
   for (i=0; !Mciswspace(cp2[i]) && cp2[i]; i++);
   if (!i) ExtErr(NULL, "Bad key input \'%s\'.", s);
   len = i + 2;
   BegAt = (*cp2 == '@');
   EndAt = (cp2[i-1] == '@') && (i > 1);
   if (BegAt)
   {
      cp2++;
      j = 0;
      len -= 2;
      i--;
   }
   else j = 1;
   if (EndAt)
   {
      len -= 2;
      i--;
   }
   if ( i < 0 || len < 0) ExtErr(NULL, "Bad key input \'%s\'.", s);
   key->Match = Wmalloc(len+1);
   if (!BegAt) key->Match[0] = ' ';
   WstrcpyN_LOW(key->Match+j, cp2, i);
   if (!EndAt) key->Match[len-1] = ' ';
   key->Match[len] = '\0';

   key->MyArgs = (ARGSTACK *) Wmalloc(sizeof(ARGSTACK));
   key->MyArgs->Not = 1;
   key->MyArgs->KeyArgs[0] = '\0';
   key->ArgStack = NULL;
/*
 * Add automatic key macro
 */
   key->KeyHandle[key->HanLen-1] = '\0';
   cp = cp2 = Wmalloc(len+3);
   if (*key->Match != ' ') *cp++ = '@';
   cp += Wstrcpy(cp, key->Match) - 1;
   if (*cp != ' ') {  cp++;  *cp++ = '@';  }
   *cp = '\0';
   if (*cp2 == ' ') cp = cp2 + 1;
   else cp = cp2;
   key->KeyMac = PushMacro2(EE, 0, key->KeyHandle, cp);
   key->KeyHandle[key->HanLen-1] = ' ';
   free(cp2);
}

void PushKey(EXTENV *EE, KEYS *Key)
{
   int i;
   ARGSTACK *NewArgs;

   i = sizeof(ARGSTACK);
   NewArgs = (ARGSTACK *) Wmalloc(i);
   WstrcpyN((void *) NewArgs, (void *) Key->MyArgs, i);
   NewArgs->next = Key->ArgStack;
   Key->ArgStack = NewArgs;
}

void PopKey(EXTENV *EE, KEYS *Key)
{
   if (Key->ArgStack == NULL)
   {
      ExtWarn(EE, "Trying to pop from key ( %s) with nonexistant stack.\n",
              Key->KeyHandle);
      return;
   }
   if (Key->MyArgs) free(Key->MyArgs);
   Key->MyArgs = Key->ArgStack;
   Key->ArgStack = Key->ArgStack->next;
}

void PeekKey(EXTENV *EE, KEYS *Key)
{
   if (Key->ArgStack == NULL)
   {
      ExtWarn(EE, "Trying to peek from key(%s) with nonexistant stack.\n",
              Key->KeyHandle);
      return;
   }
   if (Key->MyArgs == NULL) Key->MyArgs = Wmalloc(sizeof(ARGSTACK));
   WstrcpyN((void *) Key->MyArgs, (void *) Key->ArgStack, sizeof(ARGSTACK));
}

void CopyKeys(EXTENV *EE1, EXTENV *EE2)
{
   KEYS *Key, *nKey, *tKey1, *tKey2;
   ARGSTACK *ap, *ap2;

   if (EE2)
   {
      if (EE2->KeyBase)
      {
         nKey = (KEYS *) malloc(sizeof(KEYS));
         if (EE1->KeyBase == NULL) EE1->KeyBase = nKey;
         else
         {
            for (Key=EE1->KeyBase; Key->next; Key = Key->next);
            Key->next = nKey;
         }
         nKey->next = NULL;
         tKey1 = nKey;
         for (Key=EE2->KeyBase; Key; Key = Key->next)  /* for all Key in OldEnv */
         {
/*
 *          Do not define keys that have already been defined on command line
 */
            for (tKey2=EE1->KeyBase; tKey2 != tKey1; tKey2 = tKey2->next)
               if (Wstrcmp(tKey2->KeyHandle, Key->KeyHandle)) break;
            if (tKey2 == tKey1)
            {
               nKey->HanLen = Key->HanLen;
               nKey->KeyHandle = Wmalloc(Key->HanLen+1);
               Wstrcpy(nKey->KeyHandle, Key->KeyHandle);
               nKey->Match = malloc( Wstrlen(Key->Match)+1 );
               Wstrcpy(nKey->Match, Key->Match);
               nKey->KeyMac = PushMacro2(EE1, 0, nKey->KeyHandle, nKey->Match);
               nKey->next = (KEYS *) malloc(sizeof(KEYS));
               assert(nKey->next);
               nKey->next->next = NULL;
/*
 *             copy MyArgs and ArgStack
 */
               nKey->MyArgs = (ARGSTACK *) malloc(sizeof(ARGSTACK));
               WstrcpyN((void *) nKey->MyArgs, (void *) Key->MyArgs,
                        sizeof(ARGSTACK));
               if (Key->ArgStack)
               {
                  ap2 = nKey->ArgStack = (ARGSTACK *) malloc(sizeof(ARGSTACK));
                  WstrcpyN((void *) nKey->ArgStack, (void *) Key->ArgStack,
                           sizeof(ARGSTACK));
                  for (ap=Key->ArgStack->next; ap; ap=ap->next)
                  {
                     ap2->next = (ARGSTACK *) malloc(sizeof(ARGSTACK));
                     ap2 = ap2->next;
                     WstrcpyN((void *) ap2, (void *) ap, sizeof(ARGSTACK));
                  }
                  ap2->next = NULL;
               }
               else nKey->ArgStack = NULL;

               nKey = nKey->next;
            }
         }
         if (nKey == EE1->KeyBase) EE1->KeyBase = nKey->next;
         else
         {
            for (Key=EE1->KeyBase; Key->next != nKey; Key = Key->next);
            Key->next = nKey->next;
         }
         if (nKey) free(nKey);
      }
   }
}

KEYS *IsKeyLn(EXTENV *EE, char *line)
{
   int i;
   KEYS *Key;

   for (i=0; !Mciswspace(line[i]) && line[i]; i++);
   i++;
   for(Key=EE->KeyBase; Key; Key = Key->next)
      if (Key->HanLen == i)
         if ( WstrcmpN(Key->KeyHandle, line, Key->HanLen) ) break;
   return(Key);
}

void HandleKeyLn(EXTENV *EE, char *line, KEYS *Key)
{
   char *cptr, *cp, tln[LNLEN];
   int i, j, k, argmatch, OneLn=0, CHSTAK=0;
   WORDS *wp, *wbase;
   void FindKeyMatch(EXTENV *EE, KEYS *Key);

   Wsafe_slowcase(line, LNLEN);
/*
 * If it's a 1-line keyline
 */
   for (i=0; (line[i]) && (line[i] != '`'); i++);
   if (line[i]) 
   {
      OneLn = i + 1;
      line[i] = '\0';
      PushKey(EE, Key);
   }

   i = Key->HanLen;
   cptr = Key->MyArgs->KeyArgs;
/*
 * Check if we are changing the argstack
 */
   if (line[i] == '@')
   {
      if ( WstrcmpN(&line[i], "@printargs", 10) )
      {
         i = 0;
         if (Key->MyArgs->Not) 
         {
            line[i++] = '!';
            line[i++] = ' ';
         }
         Wstrcpy(&line[i], cptr);
         fprintf(Warn, "Keyargs: \'%s\'\n", line);
         return;
      }
      CHSTAK = 1;
      if ( WstrcmpN(&line[i], "@push", 5) ) 
      {
         PushKey(EE, Key);
         PeekKey(EE, Key);
      }
      else if ( WstrcmpN(&line[i], "@pop", 4) ) PopKey(EE, Key);
      else if ( WstrcmpN(&line[i], "@peek", 5) ) PeekKey(EE, Key);
      else CHSTAK = 0;
   }
/*
 * See if we are adding/removing to/from MyArgs
 */
   if (!CHSTAK)
   {
      if ( (line[i] == '-') || (line[i] == '+') )
      {
         i += 2;
         Wstrcpy(tln, line+i);
         wbase = CreateKeyLine0(EE, NULL, tln);
         for(wp=wbase; wp; wp = wp->next)
         {
            k = Wfnd_substr(cptr, wp->word);
            j = Wstrlen(wp->word);

            if (line[i-2] == '+')
            {
               if (Key->MyArgs->Not) 
               {
                  if (k) Wstrcpy(&cptr[k-1], &cptr[k-1+j]);
               }
               else if (!k) 
               {
                  k = Wstrlen(cptr);
                  if (k == 0) cptr[k++] = ' ';
                  keycpy(&cptr[k], wp->word);
               }
            }
            else 
            {
               if (Key->MyArgs->Not) 
               {
                  if (!k)
                  {
                     k = Wstrlen(cptr);
                     if (k == 0) cptr[k++] = ' ';
                     keycpy(&cptr[k], wp->word);
                  }
               }
               else if (k) Wstrcpy(&cptr[k-1], &cptr[k-1+j]);
            }
         }
         KillWords(wbase);
      }
/*
 *    Otherwise, making a new MyArgs
 */
      else
      {
         if (line[i] ==  '!')
         {
            Key->MyArgs->Not = 1;
            i += 2;
         }
         else Key->MyArgs->Not = 0;
         cptr[0] = ' ';
         Wstrcpy(tln, line+i-1);
         cp = CreateKeyLine(EE, tln);
         if (cp)
         {
            Wstrcpy(cptr+1, cp);
            free(cp);
         }
         else cptr[1] = '\0';
      }
   }

   argmatch = Wfnd_substr(Key->MyArgs->KeyArgs, Key->Match);
   if (Key->MyArgs->Not) argmatch = !argmatch;

   if (OneLn)
   {
/*
 *    Get one line, and handle it
 */
      if (argmatch)
      {
         Wstrcpy(line, &line[OneLn]);
         for(i=0; line[i]; i++);
         while (line[i] != '`') i--;
         line[i++] = '\n';
         line[i] = '\0';
         HandleLine(EE, line);
      }
/*
 *    Restore key to previous state
 */
      PopKey(EE, Key);
      i = Wstrcpy(line, Key->KeyHandle);
      if (Key->MyArgs->Not)
      {
         line[i++] = '!';
         line[i++] = ' ';
      }
      Wstrcpy(&line[i], Key->MyArgs->KeyArgs);
      HandleLine(EE, line);
   }
   else if (!argmatch) FindKeyMatch(EE, Key);
}

void FindKeyMatch(EXTENV *EE, KEYS *Key)
{
   int j, k, argmatch=0;
   char line[LNLEN], tline[LNLEN];

   j = Key->HanLen + 1;
   k = EE->Joining;
   EE->Joining = 0;
   while(!argmatch)
   {
      argmatch = !GetLn(EE, line);
      if (EE->ExtCmndOn[EC_MacSub]) MacroSub(EE, line);
      keycpy(tline, line);
      if (!argmatch)
      {
         argmatch = WstrcmpN(tline, Key->KeyHandle, Key->HanLen);
         if (argmatch) HandleKeyLn(EE, tline, Key);
      }
   }
   EE->Joining = k;
}


/*===========================================================================*/
/* Rest of file is misc catagory :-)                                         */
/*===========================================================================*/

int icalc(EXTENV *EE, char line[])
{
   int i, k=0;
   int istack[100];

   if ( Mcisnum(line[0]) || (line[0] == '-' && Mcisnum(line[1])) )
      i = Wstr2int(line, &istack[k]);
   else ExtErr(EE, "Non-numeric string in @iexp: \'%s\'", line);
   while ( Mciswspace(line[i]) ) i++;

   while(line[i])
   {
      if ( Mcisnum(line[i]) || (line[i] == '-' && Mcisnum(line[i+1])) )
         i += Wstr2int(&line[i], &istack[++k]);
      else
      {
         switch(line[i++])
         {
         case '+':
            istack[k-1] += istack[k];
            k--;
            break;
         case '-':
            istack[k-1] = istack[k] - istack[k-1];
            k--;
            break;
         case '/':
            istack[k-1] = istack[k] / istack[k-1];
            k--;
            break;
         case '*':
            istack[k-1] = istack[k] * istack[k-1];
            k--;
            break;
         case '%':
            istack[k-1] = istack[k] % istack[k-1];
            k--;
            break;
         case 'a':  /* absolute value */
            if (istack[k] < 0) istack[k] = -istack[k];
            break;
#if 0
         case 'p':  /* print stack */
            for (j=0; j <= k; j++) printf(" %d ",istack[j]);
            printf("!\n");
            break;
#endif
         default:
            ExtErr(EE, 
                   "Unrecognized character/non-numeric string in @iexp: \'%s\'",
                   line);
         }
      }
      while ( Mciswspace(line[i]) ) i++;
   }
   return(istack[k]);
}

void MakeLnButtUgly(EXTENV *EE, char *line)
{
   char comm='*', ext='$';
   int i, k;
   static int LNSKIP=1;

   if (EE->Flags[F_Ugly] == 3)
   {
      comm = '!';
      ext = '&';
   }
/*
 *  All comment lines begin with '*'; all other lines must be upcase
 */
   if ( !Mciswspace(line[0]) && !Mcisnum(line[0]) ) line[0] = comm;
   else 
   {
/*      fprintf(stderr, "line0=%c, %d, %d\n",line[0], !Mciswspace(line[0]), !Mcisnum(line[0])); */
      for (i=0; Mciswspace(line[i]); i++);
/*
 *    if line is blank, make it a comment
 */
      if (line[i] == '\0')
      {
         if (EE->Flags[F_Ugly] != 3)
         {
            line[0] = comm;
            line[1] = '\n';
            line[2] = '\0';
            return;
         }
      }
      if (EE->Flags[F_Case] == 1) Wsafe_supcase(line, 72);
      else if (EE->Flags[F_Case] == 2) Wsafe_slowcase(line, 72);
/*
 *    Use only $ for continuation
 */
      if ( !Mciswspace(line[5]) ) 
      {
         if ( (line[5]) && (line[0] != comm) ) line[5] = ext;
      }
      else  /* Right justify labels to col 5 */
      {
         for (i=0; ( (i < 5) && (!Mcisnum(line[i])) ); i++);
         if (i < 5)
         {
            sscanf(&line[i], "%d", &k);
            for (i=0; i < 5; i++) line[i] = ' ';
            sprintf(line, "%5d", k);
            line[5] = ' ';
         }
      }
   }

/*
 * Change lines of ---- to blank lines 
 */
   if (EE->Flags[F_Ugly] == 2)
   {
      if (line[0] == comm)
      {
         for (i=1; ( (Mciswspace(line[i]) || line[i] == '-') ); i++);
         if (line[i] == '\0')
         {
            if (LNSKIP) line[0] = '\0';
            else
            {
               line[0] = comm;
               line[1] = '\n';
               line[2] = '\0';
            }
            LNSKIP = !LNSKIP;
         }
      }
   }
}

void HandleIfdef(EXTENV *EE, char line[])
{
   char tline[LNLEN];
   int i, j, k=7, defined, KeepOn;

   if (line[7] == '!')
   {
      k++;
      while(Mciswspace(line[k])) k++;
   }
   for(i=k; !Mciswspace(line[i]); i++) tline[i-k] = line[i];
   tline[i-k] = '\0';
   defined = (int) FindMac(tline);
   if (line[7] == '!') defined = !defined;
   if (GetLn(EE, line)) KeepOn = 1;
   else KeepOn = 0;
   if (KeepOn) j = commandcpy(tline, line);
   if (defined)  /* loop over calls to HandleLine */
   {
      while( KeepOn )
      {
         if (j == 9) KeepOn = !WstrcmpN(tline, "@endifdef ", 10);
         if (KeepOn)
         {
            HandleLine(EE, line);
            KeepOn = GetLn(EE, line);
            if (!KeepOn)
               fprintf(stderr, "File %s ended inside of an @ifdef\n",
                       EE->FpIn->Fnam);
            j = commandcpy(tline, line);
         }
      }
   }
   else  /* do not call HandleLine while skipping */
   {
      i = EE->Joining;
      EE->Joining = 0;
      while( KeepOn )
      {
         if (j == 9)
         {
            if (WstrcmpN(tline, "@endifdef ", 10)) KeepOn--;
         }
         else if (j == 6) if (WstrcmpN(tline, "@ifdef ", 7)) KeepOn++;
         if (KeepOn)
         {
            if (!GetLn(EE, line))
            {
               fprintf(stderr, "File %s ended inside of %d @ifdefs\n",
                       EE->FpIn->Fnam, KeepOn);
               KeepOn = 0;
            }
            else if (EE->ExtCmndOn[EC_MacSub]) MacroSub(EE, line);
            j = commandcpy(tline, line);
         }
      }
      EE->Joining = i;
   }
}

void HandleDec(EXTENV *EE, char *line)
{
   char tline[LNLEN];
   char *outln, *endstr=NULL;
   char *cas, ch, Ab, Ae;
   enum LANG WhatLang;
   int i, k, EndLen=0, istart, istart2=(-1), LnLen;
   int EXTENDLINE=1, SORT=1;
   WORDS *wptr, *wp, *wp0;

   LnLen = EE->Flags[F_LnLen];
   if (EE->Flags[F_Lang] == 'c')
   {
      WhatLang = LangC;
      if (LnLen == 0) LnLen = 79;
      Ab = '[';
      Ae = ']';
   }
   else if (EE->Flags[F_Lang] == 'm')
   {
      WhatLang = LangMake;
      if (LnLen == 0) LnLen = 79;
      Ae = Ab = '\"';
   }
   else
   {
      if (EE->Flags[F_Lang] == '9')
      {
         WhatLang = LangF90;
         if (LnLen == 0) LnLen = 77;
      }
      else
      {
         WhatLang = LangF77;
         if (LnLen == 0) LnLen = 71;
      }
      Ab = '(';
      Ae = ')';
   }
   switch(EE->Flags[F_Case])
   {
   case 0:
      cas = NULL;
      break;
   case 1:
      ch = 'u';
      cas = &ch;
      break;
   case 2:
      ch = 'l';
      cas = &ch;
      break;
   }

   outln = malloc(LnLen+10);
   for (i=10; line[i] != '\"'; i++)  outln[i-10] = line[i];
   Wsafe_mws2spc(&line[i+1]);
   if (line[i+1])
   {
      EXTENDLINE = (Mupcase(line[i+2]) != 'N');
      if ( (line[i+2]) && (line[i+3]) )
      {
         SORT = (Mupcase(line[i+4]) != 'N');
         if ( (line[i+4]) && (line[i+5]) )
         {
            if (line[i+6] == '\"')
            {
                for (k=i+7; line[k] != '\"'; k++) if (!line[k]) ExtErr(EE, "Unmatched quote on line %d of basefile %s", EE->FpIn->LineNo, EE->FpIn->Fnam);
                EndLen = k - (i+7);
                endstr = (char *) malloc(EndLen+1);
                for (k=0; k != EndLen; k++) endstr[k] = line[k+i+7];
                endstr[EndLen] = '\0';
                k += i + 8;
                if (line[k]) k++;
            }
            else k = i + 6;
            if ( Mcisnum(line[k]) )
            {
               Wstr2int(&line[k], &istart2);
               istart2--;
            }
         }
      }
   }
   istart = i - 10;
   if (istart2 == -1) istart2 = istart;
   wp0 = wptr = fGetVars(EE, "@enddeclare ", 12, line, tline, Ab, Ae);

   if (EXTENDLINE)
   {
      if (WhatLang == LangMake) LnLen -= 2;
   }
   else if (WhatLang == LangC) LnLen--;
   if (SORT) wp0 = wptr = SortWords(cas, wptr);
/*
 * After sorting, find last parameter and add end string to it
 */
   if (endstr)
   {
      for (wp=wptr; wp->next; wp = wp->next);
      sprintf(tline, "%s%s", wp->word, endstr);
      wp0 = wptr = KillWord(wp0, wp);
      if (wp0)
      {
         for (wp=wptr; wp->next; wp = wp->next);
         wp->next = GetWord(tline);
      }
      else
         wp0 = wptr = GetWord(tline);
   }

   while(wptr)
   {
      for(i=istart; i <= LnLen; i++)
      {
         outln[i] = wptr->word[i-istart];
         if (!outln[i]) break;
      }
      if (i > LnLen)
      {
         if (istart == istart2) /* parameter too long to fit on any line */
            ExtErr(EE, "Parameter \'%s\' too long to fit on @DECLARE line",
                   wptr->word);
         i = istart;
         if (!EXTENDLINE) 
         {
            i -= 2;
            if (WhatLang == LangC) outln[i++] = ';';
         }
         else
         {
            if (WhatLang == LangMake) outln[i++] = '\\';
            else i--;
            if (EE->Flags[F_Lang] == '9')
            {
               while(i <= LnLen) outln[i++] = ' ';
               i = LnLen + 1;
               outln[i++] = ' ';
               outln[i++] = '&';
            }
            else if (EE->Flags[F_Ugly] == 3)
            {
               while(i < 72) outln[i++] = ' ';
               i = 72;
               outln[i++] = '&';
            }
         }
         outln[i++] = '\n';
         outln[i] = '\0';
         HandleLine(EE, outln);
         istart = istart2;
         if (EXTENDLINE)
         {
            for(i=0; i < istart2; i++) outln[i] = ' ';
            if (EE->Flags[F_Lang] == 'f') outln[5] = '$';
         }
      }
      else 
      {
         wptr = wptr->next;
         if (WhatLang != LangMake) outln[i++] = ',';
         outln[i++] = ' ';
         istart = i;
      }
   }
   if (WhatLang == LangMake) i--;
   else i -= 2;
   if (endstr) free(endstr);
   outln[i++] = '\n';
   outln[i] = '\0';
   KillWords(wp0);
   HandleLine(EE, outln);
   free(outln);
}

void HandleMultidef(EXTENV *EE, char *line)
{
   WORDS *wp, *wp0;
   char tline[LNLEN], cline[LNLEN];
   char *han=line+10;
   int i, j, k;
   
   for (i=10; ((!Mciswspace(line[i])) && line[i]); i++);
   if (line[i]) line[i++] = '\0';
   for (j=i; ( (line[j]) && Mciswspace(line[j]) ); j++);
   if (line[j]) /* one-line multidef */
      wp0 = GetWords(&line[j]);
   else
   {
      han = Wmalloc(i-10);
      Wstrcpy(han, line+10);
      k = EE->Joining;
      EE->Joining = 0;
      wp0 = fGetWords(EE, "@endmultidef ", 13, line, tline);
      EE->Joining = k;
   }
   for (wp=wp0; wp; wp = wp->next) PushMacro2(EE, EE->Flags[F_FragMac], han, wp->word);
   KillWords(wp0);
   if (han != line+10) free(han);
}

void DumpSkip(EXTENV *EE, FILE *fpout, char *begstr, char *endstr)
/*
 * Dumps to file/skips lines between matching begstr and endstr
 */
{
   char ln[LNLEN], tln[LNLEN];
   int ibeg, iend, KeepOn=1, i, k;

   k = EE->Joining;
   EE->Joining = 0;
   ibeg = Wstrlen(begstr);
   iend = Wstrlen(endstr);
   do
   {
      if ( GetLn(EE, ln) )
      {
         i = commandcpy(tln, ln) + 1;
         if (EE->ExtCmndOn[EC_MacSub]) MacroSub(EE, tln);
         if (i == ibeg) if ( WstrcmpN(tln, begstr, ibeg) ) KeepOn++;
         if (i == iend) if ( WstrcmpN(tln, endstr, iend) ) KeepOn--;
         if (fpout && KeepOn) fputs(ln, fpout);
      }
      else break;
   }
   while (KeepOn);
   if (fpout) fflush(fpout);
   EE->Joining = k;
}

void HandleWhile(EXTENV *EE, char line[])
{
   FILE2 tfp, *OldFp;
   WORDS *wp, *wp2;
   char tline[LNLEN];
   char *han;
   int KeepOn, i;
   static int inest=0;

   inest++;
/*
 * Define while line definitions
 */
   wp2 = GetWords(&line[10]);
   if (wp2 == NULL) ExtErr(EE, "Malformed @whiledef=\'%s\'",line);
   i = Wstrlen(wp2->word) + 1;
   han = Wmalloc(i);
   Wstrcpy(han, wp2->word);

   for (wp=wp2->next; wp; wp = wp->next)
      PushMacro2(EE, EE->Flags[F_FragMac], han, wp->word);

   KillWords(wp2);

/*
 * Open temporary file, and dump while loop to it
 */
   sprintf(tfp.Fnam, "Whiledeftmpfile%d", inest);
   tfp.LineNo = 0;
   tfp.Fp = tmpfile(); /* fopen(tfp.Fnam, "w+"); */
   DumpSkip(EE, tfp.Fp, "@whiledef ", "@endwhile ");

   OldFp = EE->FpIn;
   tfp.prev = OldFp;
   EE->FpIn = &tfp;

   while ( FindMac(han) )
   {
      rewind(tfp.Fp);
      while( GetLn(EE, line) ) HandleLine(EE, line);
      PopMacro2(EE, han);
   }

   EE->FpIn = OldFp;
   fclose(tfp.Fp);
   free(han);
   inest--;
}

char GetIntComp(EXTENV *EE, char *ln, int *A1CONST, int *A2CONST,
                int *ia1, int *ia2, char *mac1, char *mac2)
/*
 * Expects comparison line of form arg1 [<,>,!,=] arg2;  
 * This routine finds arg1 and arg2.  Note that if
 * arg1 or arg2 is a macro, it cannot begin with a number or -
 * Returns type of comparison (<, =, !)
 */
{
   EXTMAC *mp;
   WORDS *wp, *wp0, *wp1;
   char comp = '<';

   *ia1 = *ia2 = *A1CONST = *A2CONST = 0;
   if (mac1) *mac1 = '\0';
   if (mac2) *mac2 = '\0';

   wp = GetWords(ln);
   if (wp == NULL || wp->next == NULL || wp->next->next == NULL)
      ExtErr(EE, "Invalid integer condition: '%s'\n", ln);

   { wp0 = wp; wp1 = wp->next->next; }
   if (wp->next->word[0] == '>') { wp1 = wp; wp0 = wp->next->next; }
   else if (wp->next->word[0] == '=') comp = '=';
   else if (wp->next->word[0] == '!') comp = '!';
   else if (wp->next->word[0] != '<')
      ExtErr(EE, "Invalid integer condition: '%s'\n", ln);

   if (Mcisnum(wp0->word[0]) || wp0->word[0] == '-')
   {
      *A1CONST = 1;
      if (sscanf(wp0->word, "%d", ia1) != 1)
         ExtErr(EE, "Invalid integer condition: '%s'\n", ln);
   }
   else if (mac1) sprintf(mac1, "@(%s)", wp0->word);
   else
   {
      *A1CONST = 1;
      mp = FindMac(wp0->word);
      if (!mp) ExtErr(EE, "Undefined macro in integer condition: '%s'\n", ln);
      if (sscanf(mp->Sub, "%d", ia1) != 1)
         ExtErr(EE, "Invalid macro in integer condition: '%s'\n", ln);
   }
   if (Mcisnum(wp1->word[0]) || wp1->word[0] == '-')
   {
      *A2CONST = 1;
      if (sscanf(wp1->word, "%d", ia2) != 1)
         ExtErr(EE, "Invalid integer condition: '%s'\n", ln);
   }
   else if (mac2) sprintf(mac2, "@(%s)", wp1->word);
   else
   {
      *A1CONST = 1;
      mp = FindMac(wp1->word);
      if (!mp) ExtErr(EE, "Undefined macro in integer condition: '%s'\n", ln);
      if (sscanf(mp->Sub, "%d", ia2) != 1)
         ExtErr(EE, "Invalid macro in integer condition: '%s'\n", ln);
   }
   KillWords(wp);
   return(comp);
}

int Getiarg(EXTENV *EE, int ARGCONST, int ival, char *mac)
{
   int i;
   char ln[LNLEN];

   if (ARGCONST) return(ival);
   Wstrcpy(ln, mac);
   MacroSub(EE, ln);
   if (sscanf(ln, "%d", &i) != 1)
      ExtErr(EE, "Invalid @iwhile macro: '%s'\n", mac);
   return(i);
}

int MIfCond(EXTENV *EE, char *ln)
/*
 * Expects ln of machandle1 [=,!,~] machandle2
 * where machandle is either or macro handle, or if it begins with ",
 * a string literal (white spaces have to come from @^, and there is no
 * matching closing ")
 * comparators:  = : equal;    ! : not equal;    ~ : is substring of
 */
{
   WORDS *wp;
   EXTMAC *mp1, *mp2;
   char *comp1, *comp2;
   int iret=0;

   wp = GetWords(ln);
   if (!wp || !wp->next || !wp->next->next)
      ExtErr(EE, "Invalid macro condition: '%s'\n", ln);

   if (wp->word[0] == '"') /* word is string literal, not macro */
      comp1 = wp->word + 1;
   else
   {
      mp1 = FindMac(wp->word);
      if (!mp1) ExtErr(EE, "Undefined macro in condition: '%s'\n", ln);
      comp1 = mp1->Sub;
   }
   if (wp->next->next->word[0] == '"') /* word is string literal, not macro */
      comp2 = wp->next->next->word + 1;
   else
   {
      mp2 = FindMac(wp->next->next->word);
      if (!mp2) ExtErr(EE, "Undefined macros in condition: '%s'\n", ln);
      comp2 = mp2->Sub;
   }

   if (wp->next->word[0] == '=') iret = Wstrcmp(comp2, comp1);
   else if (wp->next->word[0] == '!') iret = !Wstrcmp(comp2, comp1);
   else if (wp->next->word[0] == '~') iret = Wfnd_substr(comp2, comp1);
   else ExtErr(EE, "Invalid macro condition operator: '%s'\n", ln);

   KillWords(wp);
   return(iret);
}

void HandleMIf(EXTENV *EE, char *ln)
/*
 * Expects ln of @mif handle1 [<,>,=,!] handle2
 */
{
   if ( MIfCond(EE, ln+5) )
   {
      SETMODE(mode, MODE_MIF);
      modedepth[MCMIF]++;
   }
   else DumpSkip(EE, NULL, "@mif ", "@endmif ");
}

void HandleIIf(EXTENV *EE, char *ln)
/*
 * Expects ln of @iif int1 [<,>,=,!] int2
 */
{
   char ch;
   int i, j, ia1, ia2;
   ch = GetIntComp(EE, ln+5, &i, &j, &ia1, &ia2, NULL, NULL);
   if (ch == '=') i = (ia1 == ia2);
   else if (ch == '!') i = (ia1 != ia2);
   else if (ch == '<') i = (ia1 < ia2);
   if (!i) /* skip */
      DumpSkip(EE, NULL, "@iif ", "@endiif ");
   else
   {
      SETMODE(mode, MODE_IIF);
      modedepth[MCIIF]++;
   }
}

void HandleIwhile(EXTENV *EE, char *ln)
{
   int A1CONST, A2CONST, ia1, ia2, KeepOn;
   static int inest=0;
   FILE2 tfp, *OldFp;
   char mac1[HANLEN], mac2[HANLEN];
   char comp;

   inest++;
   comp = GetIntComp(EE, ln+8, &A1CONST, &A2CONST, &ia1, &ia2, mac1, mac2);

/*
 * Open temporary file, and dump while loop to it
 */
   sprintf(tfp.Fnam, "Iwhiletmpfile%d", inest);
   tfp.LineNo = 0;
   tfp.Fp = tmpfile(); /* fopen(tfp.Fnam, "w+"); */
   DumpSkip(EE, tfp.Fp, "@iwhile ", "@endiwhile ");

   OldFp = EE->FpIn;
   tfp.prev = OldFp;
   EE->FpIn = &tfp;

   ia1 = Getiarg(EE, A1CONST, ia1, mac1);
   ia2 = Getiarg(EE, A2CONST, ia2, mac2);
   if (comp == '<') KeepOn = (ia1 < ia2);
   else if (comp == '=') KeepOn = (ia1 == ia2);
   else if (comp == '!') KeepOn = (ia1 != ia2);
   while (KeepOn)
   {
      rewind(tfp.Fp);
      while( GetLn(EE, ln) ) HandleLine(EE, ln);
      ia1 = Getiarg(EE, A1CONST, ia1, mac1);
      ia2 = Getiarg(EE, A2CONST, ia2, mac2);
      if (comp == '<') KeepOn = (ia1 < ia2);
      else if (comp == '=') KeepOn = (ia1 == ia2);
      else if (comp == '!') KeepOn = (ia1 != ia2);
   }

   EE->FpIn = OldFp;
   fclose(tfp.Fp);
   inest--;
}



void ApplyFlags(EXTENV *EE, char *line)
{
   char tline[LNLEN], *flag;
   int i, j;
   INDENT *indptr;
   extern INDENT *indbase;

   flag = EE->Flags;

   if (flag[F_RemBlank]) Wremove_trailing_blanks(line);
   if (indbase)
   {
      Wtab2spcs(line, 8);
      indptr = indbase;
      do
      {
         j = indptr->start;
         if (indptr->nspac > 0)
         {
            Wstrcpy(tline, &line[j]);
            for (i=j; i < j + indptr->nspac; i++) line[i] = ' ';
            Wstrcpy(&line[i], tline);
         }
         else if (indptr->nspac < 0) Wstrcpy(&line[j+indptr->nspac], &line[j]);
         indptr = indptr->next;
      }
      while (indptr != indbase);
   }
   else if (flag[F_RepTab]) Wtab2spcs(line, flag[F_RepTab]);
   if (flag[F_Ugly]) MakeLnButtUgly(EE, line);
   else
   {
      if (flag[F_Case] == 1) Wsafe_supcase(line, LNLEN);
      else if (flag[F_Case] == 2) Wsafe_slowcase(line, LNLEN);
   }
   if (flag[F_Clint])
   {
      if (flag[F_Lang] == 'f')
         if (!( !Mciswspace(line[0]) && !Mcisnum(line[0]) ))
            Wsafe_slowcase(line, 72);
   }

   if (flag[F_LLWarn])
   {
      if ( (flag[F_LLWarn] > 1) || (flag[F_Lang] != 'f') ||
           Mciswspace(line[0]) || Mcisnum(line[0]) )
      {
         i = Wstrlen(line) - 1;
         while (Mciswspace(line[i])) i--;
         if (i > flag[F_LnLen])
            fprintf(Warn,
                    "\nWARNING: Line %d of file \'%s\' is %d characters long!\n",
                    EE->FpIn->LineNo, EE->FpIn->Fnam, i+1);
      }
   }
}

INDENT *AddIndent(EXTENV *EE, int start, int nspaces)
{
   INDENT *indptr;
   indptr = (INDENT *) malloc(sizeof(INDENT));
   if (indbase == NULL)
   {
      indbase = indptr;
      indbase->next = indbase;
      indbase->prev = indbase;
   }
   else
   {
      indptr->prev = indbase->prev;
      indptr->next = indbase;
      indbase->prev->next = indptr;
      indbase->prev = indptr;
   }
   indptr->start = start - 1;
   indptr->nspac = nspaces;
   return(indptr);
}

void KillIndent(EXTENV *EE, INDENT *indptr)
{
   INDENT *ip;

   if (indbase)
   {
      if (indptr == indbase) ip = indbase;
      else for(ip=indbase->next; ip != indptr && ip != indbase; ip = ip->next);
      if (ip != indptr) ExtErr(EE, "Error in indention freeing");

      ip->prev->next = ip->next;
      ip->next->prev = ip->prev;
      if (ip == indbase)
      {
         if (indbase->next == indbase) indbase = NULL;
         else indbase = indbase->next;
         free(ip);
      }
   }
   else ExtWarn(EE, "unmatched @ENDINDENT");
}

void PrintUsage()
{
   fprintf(Warn, "\nExtract v%s: Written by R. Clint Whaley.\n", version);
   fprintf(Warn, "Report bugs to: rwhaley@cs.utk.edu,\n");
   fprintf(Warn, "_after_ scoping the homepage: www.cs.utk.edu/~rwhaley/EXTRACT/Extract.html\n");
   fprintf(Warn, 
           "\nExtract3.0: Victor\'s Revenge -- bells, whistles, a gong, and\n");
   fprintf(Warn, "            a bag hanging off the side.\n");
   fprintf(Warn, 
           "\nExtract3.1: Andy Strikes Back -- bells, whistles, a gong, \n");
   fprintf(Warn, 
           "            a bag hanging off the side, and a toupee on top.\n");
   fprintf(Warn, 
           "\nExtract4.0: This Time, Its Personal -- bells, whistles, a gong, \n");
   fprintf(Warn, 
           "            a bag hanging off the side, a toupee on top, and\n");
   fprintf(Warn,
           "            chrome all around.\n");
   fprintf(Warn, "\nUser's guide and docs at:\n");
   fprintf(Warn, "\n   www.cs.utk.edu/~rwhaley/EXTRACT/Extract.html\n\n");
   fprintf(Warn, "\nUSAGE:");
   fprintf(Warn,
           "\n\nextract [-<flags>] [key1=match1, ...,  keyN=matchN]\n\n");
   fprintf(Warn,
           "Those items in [] are optional, while those in <> are to be\n");
   fprintf(Warn,"replaced by the appropriate string.\n");
   fprintf(Warn, 
"All flags have the option 0.  This means do not perform the\n");
   fprintf(Warn, 
"operation indicated by the flag.  For instance -case0 means do not change case.\n");
   fprintf(Warn, 
"This can be used to override the defaults setup by your ~/.extractrc file.\n");
   fprintf(Warn, "\nThe available flags are:\n");
   fprintf(Warn, 
      "  -o <outfile> : use file <outfile> for output rather than stdout.\n");
   fprintf(Warn,
      "  -b <basefile> : use file <basefile> for input rather than stdin.\n");
   fprintf(Warn, 
   "  -case[0,U,L]: change case of output file. U=upcase, L=lowcase.\n");
   fprintf(Warn, "  -RepTab[0][#]: replace tabs with # spaces.  # defaults to 8.\n");
   fprintf(Warn, 
           "  -Remtblank[0]: remove trailing blanks at the end of each line\n");
   fprintf(Warn, "  -LAPACK[0,1,2,3]: Make code look like LAPACK coding style.\n");
   fprintf(Warn, "  -verb[0,1,2,3]: Vary the verbosity of extract.\n");
   fprintf(Warn, "  -LnLen[0]#: set maximal number of columns for line length warning.\n");
   fprintf(Warn, "  -LLWarn[0,1,2]: Line length warnings: 0: none, 1: non-comment, 2: always\n");
   fprintf(Warn, 
      "  -fmode[0,Q,A]:  File mode.  0: default - overwrite if file exists;\n");
   fprintf(Warn, "                  Q: Query before overwriting, A: Append.\n");
   fprintf(Warn, "  -lang[0,f77,C,M] Language extracted file is.\n");
   fprintf(Warn, "  -addkeys[0]: Makes it so keys are always inherited.\n");
   fprintf(Warn, "  -punymac[0]: Makes it so macros in in-line extract files are automatically\n");
   fprintf(Warn, 
           "               popped before returning to the @extract line.\n");
   fprintf(Warn, "               NOTE: this flag is never inherited.\n");
   fprintf(Warn, 
   "  -punyflags[0]: Says that @extract being done should not inherit\n");
   fprintf(Warn, "                present flag settings.\n");
   fprintf(Warn, 
"   -localprocs[0]: If true, makes it so extract procedures and functions are\n");
   fprintf(Warn,
"                   undefined before returning to the calling @extract line\n");
   fprintf(Warn, "  -def <handle> \"<replacement>\".\n");
   fprintf(Warn, "  -indent <col> <nspaces>\n");
   fprintf(Warn, 
   "  -trans \"Ln#1, ..., Ln#N\": translate extracted line numbers to basefile\n");
   fprintf(Warn, "                            line numbers.\n");
   fprintf(Warn, 
     "  -no@<extract,skip,def,ifdef,whiledef,indent,key,abort,macsub,endext,print,exp,declare,addkey,echo,iwhile,proc,output,iif,mif,all>[0]:\n");
   fprintf(Warn, "     turn off basefile commands.\n");
   exit(1);
}

void ExtInit(EXTENV *EE, WORDS *wp)
{
   char *fin=NULL, *fout=NULL, *flags, *ec, *access;
   char line[LNLEN];
   int i, j, err;
   WORDS *p, *p2;

   EE->clindent = NULL;
   EE->MyPunyMacs = NULL;
   EE->MyProcs = NULL;
   EE->Joining = 1;
   p = wp;
   flags = EE->Flags;
   ec = EE->ExtCmndOn;
   access = "w";
   EE->KeyBase = NULL;

   while (p)
   {
      err = 0;
      Wsafe_slowcase(p->word, LNLEN);
/*
 *    parameter is flag
 */
      if (p->word[0] == '-')
      {
         if ( WstrcmpN(p->word+1, "multidef", 8) )
         {
            p2 = p = p->next;
            if (!p) ExtErr(NULL, "No handle for commandline macro definition");
            if (!p->next)
               ExtErr(NULL, "No substring for commandline macro definition");
            while (p->next)
            {
               if (p->next->word[0] == '-') break;
               sprintf(line, "@define %s @%s@\n",p2->word, p->next->word);
               PushMacro(EE, line);
               p = p->next;
            }
         }
         else if ( WstrcmpN(&p->word[1], "def", 3) )
         {
/*
 *          Push commandline macro onto stack
 */
            p = p->next;
            if (!p) ExtErr(NULL, "No handle for commandline macro definition");
            if (!p->next)
               ExtErr(NULL, "No substring for commandline macro definition");
            PushMacro2(EE, 1, p->word, p->next->word);
            p = p->next;
         }
         else if ( (p->word[1] == 'o') && (p->word[2] == '\0') )
         {
            p = p->next;
            if (p) fout = p->word;
         }
         else if ( (p->word[1] == 'b') && (p->word[2] == '\0') )
         {
            p = p->next;
            if (p) fin = p->word;
         }
         else if ( WstrcmpN(&p->word[1], "case", 4) )
         {
            if (p->word[5] == 'u') flags[F_Case] = 1;
            else if (p->word[5] == 'l') flags[F_Case] = 2;
            else if (p->word[5] == '0' || p->word[5] == '\0') flags[F_Case] = 0;
            else err = 1;
         }
         else if ( WstrcmpN(&p->word[1], "reptab", 6) )
         {
            if (p->word[7] == '\0') flags[F_RepTab] = 8;
            else 
            {
               sscanf(&p->word[7], "%d", &i);
               flags[F_RepTab] = i;
            }
         }
         else if ( WstrcmpN(&p->word[1], "remtblank", 9) )
         {
            flags[F_RemBlank] = (p->word[10] != '0');
         }
         else if ( WstrcmpN(&p->word[1], "lapack", 6) )
         {
            if (p->word[7] == '0') flags[F_Ugly] = 0;
            else if (p->word[7] == '2') flags[F_Ugly] = 2;
            else if (p->word[7] == '3') flags[F_Ugly] = 3;
            else 
            {
               flags[F_Ugly] = 1;
               flags[F_Case] = 1;
            }
         }
         else if ( WstrcmpN(&p->word[1], "verb", 4) )
         {
            if (p->word[5] == '1') flags[F_Verb] = 1;
            else if (p->word[5] == '2') flags[F_Verb] = 2;
            else if (p->word[5] == '3') flags[F_Verb] = 3;
            else flags[F_Verb] = 0;
         }
         else if ( WstrcmpN(&p->word[1], "lnlen", 5) )
         {
            sscanf(&p->word[6], "%d", &i);
            flags[F_LnLen] = i;
         }
         else if ( WstrcmpN(&p->word[1], "llwarn", 6) )
         {
            sscanf(&p->word[7], "%d", &i);
            flags[F_LLWarn] = i;
         }
         else if ( WstrcmpN(&p->word[1], "fmode", 5) )
         {
            if (p->word[6] == 'a') access = "a";
            else access = "w";
            flags[F_Query] = (p->word[6] == 'q');
         }
         else if ( WstrcmpN(&p->word[1], "lang", 4) )
         {
            flags[F_Lang] = 'f';
            if (p->word[5] == 'c') flags[F_Lang] = 'c';
            else if (p->word[5] == 'm') flags[F_Lang] = 'm';
            else if (p->word[5] == 'f')
               if (p->word[6] == '9') flags[F_Lang] = '9';
         }
         else if ( WstrcmpN(&p->word[1], "trans", 5) )
         {
            fprintf(Warn, "\nFlag \'-trans\' not yet implemented.\n");
         }
         else if ( WstrcmpN(&p->word[1], "addkeys", 7) )
         {
            if (p->word[8] == '0') flags[F_AddKeys] = 0;
            else flags[F_AddKeys] = 1;
         }
         else if ( WstrcmpN(&p->word[1], "localprocs", 10) )
         {
            if (p->word[11] == '0') flags[F_LocalProcs] = 0;
            else flags[F_LocalProcs] = 1;
         }
         else if ( WstrcmpN(&p->word[1], "punymac", 7) )
         {
            if (p->word[8] == '0') flags[F_FragMac] = 0;
            else flags[F_FragMac] = 1;
         }
         else if ( WstrcmpN(&p->word[1], "punyflags", 9) )
         {
            if (p->word[10] == '0') flags[F_FragFlag] = 0;
            else flags[F_FragFlag] = 1;
         }
         else if ( WstrcmpN(&p->word[1], "clint", 5) )
         {
            if (p->word[6] == '0') flags[F_Clint] = 0;
            else flags[F_Clint] = 1;
         }
         else if ( WstrcmpN(&p->word[1], "indent", 6) )
         {
            p = p->next;
            sscanf(p->word, "%d", &i);
            p = p->next;
            sscanf(p->word, "%d", &j);
            EE->clindent = AddIndent(EE, i, j);
         }
         else if ( WstrcmpN(&p->word[1], "help", 4) ) PrintUsage();
         else if ( WstrcmpN(&p->word[1], "no@", 3) )
         {
            if ( WstrcmpN(&p->word[4], "extract", 7) ) 
               ec[EC_Extract] = p->word[11] == '0';
            else if ( WstrcmpN(&p->word[4], "skip", 4) ) 
               ec[EC_Skip] = p->word[8] == '0';
            else if ( WstrcmpN(&p->word[4], "def", 3) ) 
               ec[EC_Define] = p->word[7] == '0';
            else if ( WstrcmpN(&p->word[4], "ifdef", 5) ) 
               ec[EC_Ifdef] = p->word[9] == '0';
            else if ( WstrcmpN(&p->word[4], "whiledef", 8) ) 
               ec[EC_While] = p->word[12] == '0';
            else if ( WstrcmpN(&p->word[4], "indent", 6) ) 
               ec[EC_Indent] = p->word[10] == '0';
            else if ( WstrcmpN(&p->word[4], "key", 3) ) 
               ec[EC_Key] = p->word[7] == '0';
            else if ( WstrcmpN(&p->word[4], "abort", 5) ) 
               ec[EC_Abort] = p->word[9] == '0';
            else if ( WstrcmpN(&p->word[4], "macsub", 6) ) 
               ec[EC_MacSub] = p->word[10] == '0';
            else if ( WstrcmpN(&p->word[4], "endext", 6) ) 
               ec[EC_EndExt] = p->word[10] == '0';
            else if ( WstrcmpN(&p->word[4], "print", 5) ) 
               ec[EC_EndExt] = p->word[9] == '0';
            else if ( WstrcmpN(&p->word[4], "exp", 3) ) 
               ec[EC_Exp] = p->word[7] == '0';
            else if ( WstrcmpN(&p->word[4], "declare", 7) ) 
               ec[EC_Dec] = p->word[7] == '0';
            else if ( WstrcmpN(&p->word[4], "addkey", 6) ) 
               ec[EC_AddKey] = p->word[6] == '0';
            else if ( WstrcmpN(&p->word[4], "echo", 4) ) 
               ec[EC_Echo] = p->word[4] == '0';
            else if ( WstrcmpN(&p->word[4], "iwhile", 6) ) 
               ec[EC_Iwhile] = p->word[6] == '0';
            else if ( WstrcmpN(&p->word[4], "output", 6) ) 
               ec[EC_Output] = p->word[6] == '0';
            else if ( WstrcmpN(&p->word[4], "iif", 3) ) 
               ec[EC_Iif] = p->word[6] == '0';
            else if ( WstrcmpN(&p->word[4], "mif", 3) ) 
               ec[EC_Mif] = p->word[6] == '0';
            else if ( WstrcmpN(&p->word[4], "all", 3) ) 
            {
               if (p->word[7] == '0') CharSet(EC_nExtCmnds, ec, 1);
               else
               {
                  CharSet(EC_nExtCmnds, ec, 0);
                  ec[EC_Output] = 1;
               }
            }
            else err = 1;
         }
         else err = 1;
         if (err) fprintf(Warn, "\n\nUnknown flag \'%s\' ignored.\n\n", p->word);
      }
/*
 *    Parameter is setting up keys
 */
      else AddKey(EE, p->word);
      p = p->next;
   }
   if (fin) EE->FpIn = OpenFile(EE, fin, "r");
   if (fout) EE->FpOut = OpenFile(EE, fout, access);
   KillWords(wp);
/*
 * Must set LnLen if we want warnings
 */
   if (flags[F_LLWarn])
   {
      if (!flags[F_LnLen])
      {
         if (flags[F_Lang] == 'f') flags[F_LnLen] = 71;
         else flags[F_LnLen] = 80;
      }
   }
/*
 * Never replace tabs in Makefiles
 */
   if (flags[F_Lang] == 'm') flags[F_RepTab] = 0;
}


void Extract(EXTENV *OldEnv, WORDS *wp)
{
   char line[LNLEN];
   EXTENV EE;
   PUNYMAC *pp;
   KEYS *kp;
   EXTPROC *fup;
   void KillProc(EXTENV *EE, EXTPROC *fpkill);

   EE.FpIn = NULL;
   EE.FpOut = NULL;
   if (OldEnv)
   {
      if (OldEnv->Flags[F_FragFlag]) CharSet(F_nFlags, EE.Flags, 0);
      else WstrcpyN((void *) EE.Flags, (void *) OldEnv->Flags, F_nFlags);
      EE.Flags[F_FragMac] = 0;
      WstrcpyN((void *) EE.ExtCmndOn, (void *) OldEnv->ExtCmndOn, EC_nExtCmnds);
      fflush(OldEnv->FpOut->Fp);  /* flush oldenv's outfile */
   }
   else
   {
      CharSet(F_nFlags, EE.Flags, 0);
      EE.Flags[F_Lang] = 'f';
      CharSet(EC_nExtCmnds, EE.ExtCmndOn, 1);
   }

/*
 * If no input/output or keys are specified, they are inherited
 */
   if (OldEnv) EE.FpIn = OldEnv->FpIn;
   if (OldEnv) EE.FpOut = OldEnv->FpOut;

   ExtInit(&EE, wp);

   if (EE.FpIn  == NULL) EE.FpIn  = OpenFile(&EE, "stdin", "r");
   if (EE.FpOut == NULL) EE.FpOut = OpenFile(&EE, "stdout", "w");
/*
 * Print 'extract starting' message, if desired
 */
   if (EE.Flags[F_Verb])
   {
      if (!OldEnv)
      {
         fprintf(Warn, "\nBegin commandline extract on files: in=\'%s\', out=\'%s\'.\n",
                 EE.FpIn->Fnam, EE.FpOut->Fnam);
      }
      else if (EE.Flags[F_Verb] > 1)
      {
         fprintf(Warn, "  Begin basefile extract on files: in=\'%s\', out=\'%s\'.\n",
                 EE.FpIn->Fnam, EE.FpOut->Fnam);
      }
   }

/*
 * If keys are inherited, they do not affect OldEnv's keys, so we must copy
 */
   if ( (!EE.KeyBase) || (EE.Flags[F_AddKeys]) ) CopyKeys(&EE, OldEnv);

/*
 * Store where my macros begin
 */
   sprintf(line, "@__MyMacBeg__%d", &EE);
   PushMacro2(&EE, 0, line, "");
   EE.MyMacBeg = MacroBase;

/*
 * Read in and handle the file
 */
   while( GetLn(&EE, line) )
   {
      HandleLine(&EE, line);
   }

   ExtDone = 0;
/*
 * Print 'extract done' message, if desired
 */
   if (EE.Flags[F_Verb])
   {
      if (!OldEnv)
      {
         fprintf(Warn, 
"Done  commandline extract. Files: in=\'%s\', out=\'%s\'; Lines: in=%d, out=%d.\n",
            EE.FpIn->Fnam, EE.FpOut->Fnam, EE.FpIn->LineNo, EE.FpOut->LineNo);
      }
      else if (EE.Flags[F_Verb] > 1)
      {
         fprintf(Warn, 
"  Done  basefile extract. Files: in=\'%s\', out=\'%s\'; Lines: in=%d, out=%d.\n",
            EE.FpIn->Fnam, EE.FpOut->Fnam, EE.FpIn->LineNo, EE.FpOut->LineNo);
      }
   }

/*
 * Close files
 */
   if (OldEnv == NULL) CloseFile(&EE, EE.FpIn);
   else if (EE.FpIn != OldEnv->FpIn) CloseFile(&EE, EE.FpIn);
   if (OldEnv == NULL) CloseFile(&EE, EE.FpOut);
   else if (EE.FpOut != OldEnv->FpOut) CloseFile(&EE, EE.FpOut);

/*
 * Undefine puny macros
 */
   while(pp = EE.MyPunyMacs)
   {
      EE.MyPunyMacs = pp->next;
      PopThisMacro(&EE, pp->mp);
      free(pp);
   }
/*
 * If Fragile macros are set, free all macros defined by this extract session
 */
   if (EE.Flags[F_FragMac]) KillMyMacros(&EE);
/*
 * Pop MyMacBeg
 */
   sprintf(line, "__MyMagBeg__%d", &EE);
   PopMacro2(&EE, line);

/*
 * Free my keys
 */
   while(kp = EE.KeyBase) KillThisKey(&EE, EE.KeyBase);
/*
 * Free my procedures
 */
   if (EE.MyProcs)
   {
      while (AllProcs != EE.MyProcs)
      {
         fup = AllProcs->next;
         KillProc(&EE, AllProcs);
         AllProcs = fup;
      }
      fup = AllProcs->next;
      KillProc(&EE, AllProcs);
      AllProcs = fup;
   }
   if (EE.clindent) KillIndent(&EE, EE.clindent);
}

/*
 *  ==================================================================
 *                     Extract procedures and functions
 *  ==================================================================
 */
void KillProc0(EXTENV *EE, EXTPROC **basep, EXTPROC **myprocs, EXTPROC *ppkill)
{
   EXTPROC *fp;
   if (ppkill)
   {
      free(ppkill->ProcNam);
      free(ppkill->FileNam);
      KillWords(ppkill->argnams);
      if (ppkill == *basep)
      {
         *basep = (*basep)->next;
         if (ppkill == *myprocs) *myprocs = NULL;
      }
      else
      {
         for (fp=(*basep); fp->next != ppkill ; fp = fp->next);
         if (ppkill == *myprocs) *myprocs = fp;
         fp->next = ppkill->next;
      }
      free(ppkill);
   }
}

void KillProc(EXTENV *EE, EXTPROC *fpkill)
{
   KillProc0(EE, &AllProcs, &(EE->MyProcs), fpkill);
}

void KillFunc(EXTENV *EE, EXTPROC *fpkill)
{
   KillProc0(EE, &AllFuncs, &(EE->MyFuncs), fpkill);
}

EXTPROC *FindProc(EXTENV *EE, EXTPROC *basep, char *proc)
{
   EXTPROC *pp;
   for (pp=basep; pp; pp = pp->next)
      if (Wstrcmp(proc, pp->ProcNam)) break;
   return(pp);
}

void PopProc(EXTENV *EE, char *proc)
{
   EXTPROC *pp;
   if (AllProcs)
   {
      pp = FindProc(EE, AllProcs, proc);
      if (pp) KillProc(EE, pp);
      else ExtWarn(EE, "Nonsensical @UNDEFPROC:  %s", proc);
   }
   else ExtWarn(EE, "Nonsensical @UNDEFPROC:  %s", proc);
}

void PopFunc(EXTENV *EE, char *func)
{
   EXTPROC *pp;
   if (AllFuncs)
   {
      pp = FindProc(EE, AllFuncs, func);
      if (pp) KillFunc(EE, pp);
      else ExtWarn(EE, "Nonsensical @UNDEFFUNC:  %s", func);
   }
   else ExtWarn(EE, "Nonsensical @UNDEFFUNC:  %s", func);
}

void AddProc0(EXTENV *EE, EXTPROC **basep, EXTPROC **myprocs, EXTPROC *fpadd)
{
   if (*myprocs == NULL) *myprocs = fpadd;
   fpadd->next = *basep;
   *basep = fpadd;
}

void PushProc0(EXTENV *EE, EXTPROC **basep, EXTPROC **myfuncs, char *ln)
/*
 * expects ln of form "<procnam> [arg1 ... argN]"
 */
{
   EXTPROC *pp;
   WORDS *wp, *wpbase;
   FILE *fp;
   char *cp;
   int i;

   pp = malloc(sizeof(EXTPROC));
   wpbase = wp = GetWords(ln);
   if (!wpbase)
   {
      if (*basep == AllProcs)
         ExtErr(EE, "@BEGINPROC must have a PROCNAME");
      else ExtErr(EE, "@BEGINFUNC must have a FUNCNAME");
   }

   i = Wstrlen(wp->word) + 1;
   pp->ProcNam = malloc(i);
   Wstrcpy(pp->ProcNam, wp->word);

   pp->argnams = KillWord(wp, wp);
   pp->nargs = CountWords(pp->argnams);

   cp = tmpnam(NULL);
   if (cp == NULL) ExtErr(EE, "Out of tmpnams!!!");
   i = Wstrlen(cp) + 1;
   pp->FileNam = malloc(i*sizeof(char));
   Wstrcpy(pp->FileNam, cp);
/*
 * Dump procedure to tmpfile
 */
   fp = fopen(pp->FileNam, "w");
   if (*basep == AllProcs) DumpSkip(EE, fp, "@beginproc ", "@endproc ");
   else DumpSkip(EE, fp, "@beginfunc ", "@endfunc ");
   fclose(fp);

   AddProc0(EE, basep, myfuncs, pp);
}

void PushProc(EXTENV *EE, char *ln)
/*
 * expects ln of form "@beginproc <procnam> [arg1 ... argN]"
 */
{
   PushProc0(EE, &AllProcs, &(EE->MyProcs), ln+11);
}

void PushFunc(EXTENV *EE, char *ln)
/*
 * expects ln of form "@beginfunc <procnam> [arg1 ... argN]"
 */
{
   PushProc0(EE, &AllFuncs, &(EE->MyFuncs), ln+11);
}

void HandleProcCall0(EXTENV *EE, EXTPROC *basep, char *ln)
/*
 * expects ln of form "<proc/func> [arg1 ... argN]"
 */
{
   WORDS *wbase, *wp, *ew, *ap, *dp;
   EXTPROC *pp;

   wbase = wp = GetWords(ln);
   pp = FindProc(EE, basep, wp->word);
   if (!pp) ExtErr(EE, "Call to undefined proc/func %s", wp->word);
   ew = GetWord("-b");
   ew->next = GetWord(pp->FileNam);
   wp = ew->next;
   if (EE->Flags[F_LocalProcs] || basep == AllFuncs)
   {
     wp->next = GetWord("-punymac");
     wp = wp->next;
     if (basep == AllFuncs)
     {
        wp->next = GetWord("-no@output");
        wp = wp->next;
     }
   }
   for (dp=wbase->next, ap = pp->argnams; ap; ap = ap->next, dp = dp->next)
   {
      wp->next = GetWord("-def");
      wp = wp->next;
      wp->next = GetWord(ap->word);
      wp = wp->next;
      wp->next = GetWord(dp->word);
      wp = wp->next;
   }
   KillWords(wbase);
   Extract(EE, ew);
}

void HandleProcCall(EXTENV *EE, char *ln)
/*
 * expects ln of form "@callproc <procnam> [arg1 ... argN]"
 */
{
   HandleProcCall0(EE, AllProcs, ln+10);
}

int LnIsExtCmnd(EXTENV *EE, char *line)
{
   int icalc(EXTENV *EE, char line[]);
   int i, j, k, KeepOn, DONE=1;
   char tline[LNLEN], *Use;
   INDENT *indptr;
   WORDS *wp, *wp0;
   KEYS *Key;

   Use = EE->ExtCmndOn;
/*
 * If first non-whitespace is not an @, line is not extract command
 */
   for (i=0; Mciswspace(line[i]); i++);
   if (line[i] != '@') return(0);

   i = commandcpy(tline, &line[i]) + 1;

   switch(i)
   {
   case 5:
      if (WstrcmpN(tline, "@iif ", 4))
      {
         if ( !Use[EC_Iif] ) return(0);
         HandleIIf(EE, tline);
      }
      else if (WstrcmpN(tline, "@mif ", 4))
      {
         if ( !Use[EC_Mif] ) return(0);
         HandleMIf(EE, tline);
      }
      else DONE = 0;
      break;
   case  6:
      if (WstrcmpN(tline, "@skip ", 6))
      {
         if ( !Use[EC_Skip] ) return(0);
      }
      else if (WstrcmpN(tline, "@echo ", 6))
      {
         if (Use[EC_Echo])
         {
            for (k=0; line[k] != '@'; k++);
            k += 6;
            PutLn(EE, line+k);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@iexp ", 6))
      {
         if ( !Use[EC_Exp] ) return(0);
         for (i=6; Mciswspace(tline[i]); i++);
         j=0;
         while(!Mciswspace(tline[i])) line[j++] = tline[i++]; /* get mac handle */
         line[j] = '\0';
         keycpy(tline, &tline[i]);
         i = icalc(EE, tline);
         PopMacro2(EE, line); /* replace any previous definition */
         sprintf(tline, "%d", i);
         PushMacro2(EE, EE->Flags[F_FragMac], line, tline);
      }
      else DONE = 0;
      break;
   case  7:
      if (WstrcmpN(tline, "@undef ", 7))
      {
         if ( Use[EC_Define] ) 
         {
            if ( !PopMacro(EE, tline) )
               ExtWarn(EE, "Nonsensical @UNDEF:  %s", line);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@ifdef ", 7))
      {
         if (!Use[EC_Ifdef]) return(0);
         HandleIfdef(EE, tline);
      }
      else if (WstrcmpN(tline, "@abort ", 7))
      {
         if (Use[EC_Abort])
         {
            CloseFile(EE, EE->FpIn);
            CloseFile(EE, EE->FpOut);
            ExtErr(EE, "Extract aborted with message `%s`", &tline[7]);
            exit(1);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@print ", 7))
      {
         if (Use[EC_Print]) fprintf(Warn, "%s", &tline[7]);
         else return(0);
      }
      else DONE = 0;
      break;
   case  8:
      if (WstrcmpN(tline, "@define ", 8))
      {
         if ( Use[EC_Define] ) PushMacro(EE, tline);
         else return(0);
      }
      else if (WstrcmpN(tline, "@system ", 8))
      {
         i = Wstrcpy(line, &tline[9]);
         while (line[i] != '\"') i--;
         line[i++] = '\n';
         line[i++] = '\0';
         system(line);
      }
      else if (WstrcmpN(tline, "@iwhile ", 8))
      {
         if (!Use[EC_Iwhile]) return(0);
         HandleIwhile(EE, tline);
      }
      else if (WstrcmpN(tline, "@endmif ", 8))
      {
         if ( !Use[EC_Mif] ) return(0);
         if (INMODE(mode, MODE_MIF))
         {
            if (modedepth[MCMIF] > 0)
            {
               modedepth[MCMIF]--;
               if (!(modedepth[MCMIF])) KILLMODE(mode, MODE_MIF);
            }
            else ExtErr(EE, "Internal mode error:  `%s`", tline);
         }
         else ExtWarn(EE, "Nonsensical @ENDMIF");
      }
      else if (WstrcmpN(tline, "@endiif ", 8))
      {
         if ( !Use[EC_Iif] ) return(0);
         if (INMODE(mode, MODE_IIF))
         {
            if (modedepth[MCIIF] > 0)
            {
               modedepth[MCIIF]--;
               if (!(modedepth[MCIIF])) KILLMODE(mode, MODE_IIF);
            }
            else ExtErr(EE, "Internal mode error:  `%s`", tline);
         }
         else ExtWarn(EE, "Nonsensical @ENDIIF");
      }
      else DONE = 0;
      break;
   case  9:
      if (WstrcmpN(tline, "@extract ", 9))
      {
         if ( Use[EC_Extract] ) 
         {
            Wstrcpy(tline, &tline[9]);
            wp = GetArgs(EE, tline);
            Extract(EE, wp);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@declare ", 9))
      {
         if (!Use[EC_Dec]) return(0);
         HandleDec(EE, tline);
      }
      else if (WstrcmpN(tline, "@addkeys ",9))
      {
         if ( Use[EC_AddKey] )
         {
            wp0 = wp = GetWords(&tline[9]);
            while (wp)
            {
               AddKey(EE, wp->word);
               wp = wp->next;
            }
            KillWords(wp0);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@endskip ", 9))
      {
         if ( Use[EC_Skip] ) ExtWarn(EE, "unmatched @ENDSKIP");
         else return(0);
      }
      else if (WstrcmpN(tline, "@endproc ", 9))
      {
         if ( Use[EC_Proc] ) ExtWarn(EE, "unmatched @ENDPROC");
         else return(0);
      }
      else DONE = 0;
      break;
   case 10:
      if (WstrcmpN(tline, "@whiledef ", 10))
      {
         if (!Use[EC_While]) return(0);
         HandleWhile(EE, tline);
      }
      else if (WstrcmpN(tline, "@multidef ", 10))
      {
         if (!Use[EC_Define]) return(0);
         HandleMultidef(EE, tline);
      }
      else if (WstrcmpN(tline, "@callproc ", 10))
      {
         if (!Use[EC_Proc]) return(0);
         HandleProcCall(EE, tline);
      }
      else if (WstrcmpN(tline, "@killkeys ", 10))
      {
         if ( Use[EC_AddKey] )
         {
            wp0 = wp = GetWords(&tline[10]);
            while (wp)
            {
               KillKey(EE, wp->word);
               wp = wp->next;
            }
            KillWords(wp0);
         }
         else return(0);
      }
      else if (WstrcmpN(tline, "@endwhile ", 10))
      {
         if ( Use[EC_While] ) ExtWarn(EE, "unmatched @ENDWHILE");
         else return(0);
      }
      else if (WstrcmpN(tline, "@endifdef ", 10))
      {
         if ( Use[EC_Ifdef] ) ExtWarn(EE, "unmatched @ENDIFDEF");
         else return(0);
      }
      else if (WstrcmpN(tline, "@undefall ", 10))
      {
         if ( Use[EC_Define] )
         {
            keycpy(tline, &tline[10]);
/*
 *          If undefining all of one handle
 */
            if (tline[0])
            {
               Wstrcpy(line, "@undef ");
               i = 10;
               for (i=10; ( !Mciswspace(tline[i]) && tline[i] ); i++)
                  line[i-3] = tline[i];
               line[i-3] = '\0';
               while( PopMacro(EE, line) );
            }
/*
 *          If undefining all handles
 */
            else KillMyMacros(EE);
         }
         else return(0);
      }
      else DONE = 0;
      break;
   case 11:
      if (WstrcmpN(tline, "@beginskip ", 11))
      {
         if ( Use[EC_Skip] ) DumpSkip(EE, NULL, "@beginskip ", "@endskip ");
         else return(0);
      }
      else if (WstrcmpN(tline, "@endindent ", 11))
      {
         if ( Use[EC_Indent] ) KillIndent(EE, indbase->prev);
         else return(0);
      }
      else if (WstrcmpN(tline, "@beginproc ", 11))
      {
         if (Use[EC_Proc]) PushProc(EE, tline);
         else return(0);
      }
      else if (WstrcmpN(tline, "@endiwhile ", 11))
      {
         if ( Use[EC_Iwhile] ) ExtWarn(EE, "unmatched @ENDIWHILE");
         else return(0);
      }
      else DONE = 0;
      break;
   case 12:
      if (WstrcmpN(tline, "@enddeclare ", 12)) 
      {
         if ( Use[EC_Dec] ) ExtWarn(EE, "unmatched @enddeclare");
         else return(0);
      }
      else if (WstrcmpN(tline, "@endextract ", 12))
      {
         if ( Use[EC_EndExt] ) ExtDone = 1;
         else return(0);
      }
      else DONE = 0;
      break;
   case 13:
      if (WstrcmpN(tline, "@beginindent ", 13))
      {
         if ( Use[EC_Indent] )
         {
            keycpy(tline, line);
            sscanf(&tline[13], "%d", &j);
            for (i=13; Mcisnum(tline[i]); i++);
            sscanf(&tline[++i], "%d", &k);
            AddIndent(EE, j, k);
         }
         else return(0);
      }
      else DONE = 0;
      break;
   default:
      DONE = 0;
      break;
   }
/* 
 * Must be @<keyhandle>, a line continuation (@\) or an unassociated @ sign
 */
   if (!DONE)
   {
      if (Use[EC_Key])
      {
         keycpy(tline, line);
         Key = IsKeyLn(EE, tline);
         if (Key) HandleKeyLn(EE, tline, Key);
         else 
         {
            if (tline[1] != '\\') /* don't warn about line continuation */
            {
               if ( !(tline[1] == '(' && tline[2] == '@' && tline[3] == ')') )
                  ExtWarn(EE, "Non-associated @");
            }
            return(0);
         }
      }
      else return(0);
   }
   return(1);
}

void HandleLine(EXTENV *EE, char *line)
{
/*
 * If line is not an extract command, apply flags and write to file
 */
   if (EE->ExtCmndOn[EC_MacSub]) MacroSub(EE, line);
   if ( !LnIsExtCmnd(EE, line) )
   {
      if (EE->ExtCmndOn[EC_Output]) PutLn(EE, line);
      else ExtErr(EE, "Output in prohibited mode: %s", line);
   }
}


main(int nargs, char *args[])
{
   char line[LNLEN], *path;
   int i;
   FILE *fp;
   WORDS *wp, *wp2=NULL, *wp3;

   Warn = stderr;
   path = getenv("HOME");
   i = Wstrcpy(line, path);
   Wstrcpy(&line[i], "/.extractrc");
   fp = fopen(line, "r"); 
   if (fp)
   {
      if ( fgets(line, LNLEN, fp) ) wp2 = GetWords(line);
      fclose(fp);
   }
   if (nargs > 1)
   {
      wp3 = wp = GetWord(args[1]);
      for (i=2; i < nargs; i++)
      {
         wp->next = GetWord(args[i]);
         wp = wp->next;
      }
      wp = wp3;
      if (wp2)  /* add commandline words to end of  .extractrc words */
      {
         for (wp3=wp2; wp3->next; wp3 = wp3->next);
         wp3->next = wp;
         wp = wp2;
      }
   }
   else if (fp == NULL) wp = GetWord("-help");
   else wp = wp2;
   Extract(NULL, wp);
   exit(0);
}
/************************************************************************/
/*  This program is distributed under the terms of the Gnu              */
/*  General Public License (GPL), with the following two exceptions:    */
/*  (1) Clause (9), dealing with updating the GPL automatically, is     */
/*      specifically disallowed by the author.  The author will         */
/*      determine if a newer GPL version is still appropriate.          */
/*  (2) The basefiles extract accepts as input, and the extracted       */
/*      files it produces as output, are specifically designated as     */
/*      as outside the scope if this license (i.e. they are *not*       */
/*      required by this license to be GPL).                            */
/*  The full, unaltered, text of the GPL is included below.             */
/************************************************************************/

/*
                             GNU GENERAL PUBLIC LICENSE

                                Version 2, June 1991

        Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass
        Ave, Cambridge, MA 02139, USA. Everyone is permitted to copy and
        distribute verbatim copies of this license document, but changing it
        is not allowed.

                                      Preamble

        The licenses for most software are designed to take away your
        freedom to share and change it. By contrast, the GNU General Public
        License is intended to guarantee your freedom to share and change
        free software--to make sure the software is free for all its users.
        This General Public License applies to most of the Free Software
        Foundation's software and to any other program whose authors commit
        to using it. (Some other Free Software Foundation software is
        covered by the GNU Library General Public License instead.) You can
        apply it to your programs, too.

        When we speak of free software, we are referring to freedom, not
        price. Our General Public Licenses are designed to make sure that
        you have the freedom to distribute copies of free software (and
        charge for this service if you wish), that you receive source code
        or can get it if you want it, that you can change the software or
        use pieces of it in new free programs; and that you know you can do
        these things.

        To protect your rights, we need to make restrictions that forbid
        anyone to deny you these rights or to ask you to surrender the
        rights. These restrictions translate to certain responsibilities for
        you if you distribute copies of the software, or if you modify it.

        For example, if you distribute copies of such a program, whether
        gratis or for a fee, you must give the recipients all the rights
        that you have. You must make sure that they, too, receive or can get
        the source code. And you must show them these terms so they know
        their rights.

        We protect your rights with two steps: (1) copyright the software,
        and (2) offer you this license which gives you legal permission to
        copy, distribute and/or modify the software.

        Also, for each author's protection and ours, we want to make certain
        that everyone understands that there is no warranty for this free
        software. If the software is modified by someone else and passed on,
        we want its recipients to know that what they have is not the
        original, so that any problems introduced by others will not reflect
        on the original authors' reputations.

        Finally, any free program is threatened constantly by software
        patents. We wish to avoid the danger that redistributors of a free
        program will individually obtain patent licenses, in effect making
        the program proprietary. To prevent this, we have made it clear that
        any patent must be licensed for everyone's free use or not licensed
        at all.

        The precise terms and conditions for copying, distribution and
        modification follow.

                             GNU GENERAL PUBLIC LICENSE
          TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

        0. This License applies to any program or other work which contains
        a notice placed by the copyright holder saying it may be distributed
        under the terms of this General Public License. The "Program",
        below, refers to any such program or work, and a "work based on the
        Program" means either the Program or any derivative work under
        copyright law: that is to say, a work containing the Program or a
        portion of it, either verbatim or with modifications and/or
        translated into another language. (Hereinafter, translation is
        included without limitation in the term "modification".) Each
        licensee is addressed as "you".

        Activities other than copying, distribution and modification are not
        covered by this License; they are outside its scope. The act of
        running the Program is not restricted, and the output from the
        Program is covered only if its contents constitute a work based on
        the Program (independent of having been made by running the
        Program). Whether that is true depends on what the Program does.

        1. You may copy and distribute verbatim copies of the Program's
        source code as you receive it, in any medium, provided that you
        conspicuously and appropriately publish on each copy an appropriate
        copyright notice and disclaimer of warranty; keep intact all the
        notices that refer to this License and to the absence of any
        warranty; and give any other recipients of the Program a copy of
        this License along with the Program.

        You may charge a fee for the physical act of transferring a copy,
        and you may at your option offer warranty protection in exchange for
        a fee.

        2. You may modify your copy or copies of the Program or any portion
        of it, thus forming a work based on the Program, and copy and
        distribute such modifications or work under the terms of Section 1
        above, provided that you also meet all of these conditions:

        a) You must cause the modified files to carry prominent notices
        stating that you changed the files and the date of any change.

        b) You must cause any work that you distribute or publish, that in
        whole or in part contains or is derived from the Program or any part
        thereof, to be licensed as a whole at no charge to all third parties
        under the terms of this License.

        c) If the modified program normally reads commands interactively
        when run, you must cause it, when started running for such
        interactive use in the most ordinary way, to print or display an
        announcement including an appropriate copyright notice and a notice
        that there is no warranty (or else, saying that you provide a
        warranty) and that users may redistribute the program under these
        conditions, and telling the user how to view a copy of this License.
        (Exception: if the Program itself is interactive but does not
        normally print such an announcement, your work based on the Program
        is not required to print an announcement.)

        These requirements apply to the modified work as a whole. If
        identifiable sections of that work are not derived from the Program,
        and can be reasonably considered independent and separate works in
        themselves, then this License, and its terms, do not apply to those
        sections when you distribute them as separate works. But when you
        distribute the same sections as part of a whole which is a work
        based on the Program, the distribution of the whole must be on the
        terms of this License, whose permissions for other licensees extend
        to the entire whole, and thus to each and every part regardless of
        who wrote it.

        Thus, it is not the intent of this section to claim rights or
        contest your rights to work written entirely by you; rather, the
        intent is to exercise the right to control the distribution of
        derivative or collective works based on the Program.

        In addition, mere aggregation of another work not based on the
        Program with the Program (or with a work based on the Program) on a
        volume of a storage or distribution medium does not bring the other
        work under the scope of this License.

        3. You may copy and distribute the Program (or a work based on it,
        under Section 2) in object code or executable form under the terms
        of Sections 1 and 2 above provided that you also do one of the
        following:

        a) Accompany it with the complete corresponding machine-readable
        source code, which must be distributed under the terms of Sections 1
        and 2 above on a medium customarily used for software interchange;
        or,

        b) Accompany it with a written offer, valid for at least three
        years, to give any third party, for a charge no more than your cost
        of physically performing source distribution, a complete
        machine-readable copy of the corresponding source code, to be
        distributed under the terms of Sections 1 and 2 above on a medium
        customarily used for software interchange; or,

        c) Accompany it with the information you received as to the offer to
        distribute corresponding source code. (This alternative is allowed
        only for noncommercial distribution and only if you received the
        program in object code or executable form with such an offer, in
        accord with Subsection b above.)

        The source code for a work means the preferred form of the work for
        making modifications to it. For an executable work, complete source
        code means all the source code for all modules it contains, plus any
        associated interface definition files, plus the scripts used to
        control compilation and installation of the executable. However, as
        a special exception, the source code distributed need not include
        anything that is normally distributed (in either source or binary
        form) with the major components (compiler, kernel, and so on) of the
        operating system on which the executable runs, unless that component
        itself accompanies the executable.

        If distribution of executable or object code is made by offering
        access to copy from a designated place, then offering equivalent
        access to copy the source code from the same place counts as
        distribution of the source code, even though third parties are not
        compelled to copy the source along with the object code.

        4. You may not copy, modify, sublicense, or distribute the Program
        except as expressly provided under this License. Any attempt
        otherwise to copy, modify, sublicense or distribute the Program is
        void, and will automatically terminate your rights under this
        License. However, parties who have received copies, or rights, from
        you under this License will not have their licenses terminated so
        long as such parties remain in full compliance.

        5. You are not required to accept this License, since you have not
        signed it. However, nothing else grants you permission to modify or
        distribute the Program or its derivative works. These actions are
        prohibited by law if you do not accept this License. Therefore, by
        modifying or distributing the Program (or any work based on the
        Program), you indicate your acceptance of this License to do so, and
        all its terms and conditions for copying, distributing or modifying
        the Program or works based on it.

        6. Each time you redistribute the Program (or any work based on the
        Program), the recipient automatically receives a license from the
        original licensor to copy, distribute or modify the Program subject
        to these terms and conditions. You may not impose any further
        restrictions on the recipients' exercise of the rights granted
        herein. You are not responsible for enforcing compliance by third
        parties to this License.

        7. If, as a consequence of a court judgment or allegation of patent
        infringement or for any other reason (not limited to patent issues),
        conditions are imposed on you (whether by court order, agreement or
        otherwise) that contradict the conditions of this License, they do
        not excuse you from the conditions of this License. If you cannot
        distribute so as to satisfy simultaneously your obligations under
        this License and any other pertinent obligations, then as a
        consequence you may not distribute the Program at all. For example,
        if a patent license would not permit royalty-free redistribution of
        the Program by all those who receive copies directly or indirectly
        through you, then the only way you could satisfy both it and this
        License would be to refrain entirely from distribution of the
        Program.

        If any portion of this section is held invalid or unenforceable
        under any particular circumstance, the balance of the section is
        intended to apply and the section as a whole is intended to apply in
        other circumstances.

        It is not the purpose of this section to induce you to infringe any
        patents or other property right claims or to contest validity of any
        such claims; this section has the sole purpose of protecting the
        integrity of the free software distribution system, which is
        implemented by public license practices. Many people have made
        generous contributions to the wide range of software distributed
        through that system in reliance on consistent application of that
        system; it is up to the author/donor to decide if he or she is
        willing to distribute software through any other system and a
        licensee cannot impose that choice.

        This section is intended to make thoroughly clear what is believed
        to be a consequence of the rest of this License.

        8. If the distribution and/or use of the Program is restricted in
        certain countries either by patents or by copyrighted interfaces,
        the original copyright holder who places the Program under this
        License may add an explicit geographical distribution limitation
        excluding those countries, so that distribution is permitted only in
        or among countries not thus excluded. In such case, this License
        incorporates the limitation as if written in the body of this
        License.

        9. The Free Software Foundation may publish revised and/or new
        versions of the General Public License from time to time. Such new
        versions will be similar in spirit to the present version, but may
        differ in detail to address new problems or concerns.

        Each version is given a distinguishing version number. If the
        Program specifies a version number of this License which applies to
        it and "any later version", you have the option of following the
        terms and conditions either of that version or of any later version
        published by the Free Software Foundation. If the Program does not
        specify a version number of this License, you may choose any version
        ever published by the Free Software Foundation.

        10. If you wish to incorporate parts of the Program into other free
        programs whose distribution conditions are different, write to the
        author to ask for permission. For software which is copyrighted by
        the Free Software Foundation, write to the Free Software Foundation;
        we sometimes make exceptions for this. Our decision will be guided
        by the two goals of preserving the free status of all derivatives of
        our free software and of promoting the sharing and reuse of software
        generally.

                                    NO WARRANTY

        11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
        WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
        EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
        OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
        THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
        PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
        PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
        DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
        CORRECTION.

        12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
        WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
        AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
        FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
        PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
        RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
        FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
        SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
        SUCH DAMAGES.

                            END OF TERMS AND CONDITIONS
*/
