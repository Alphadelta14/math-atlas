@ROUT ATL_utrmmR
#include "atlas_misc.h"

/* cases: LN, UT, LT, UN ... LC/UC included */
#ifdef Upper_
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h)) /* LN & UT share same header */
      #ifdef Conj_
         #define ATL_utrmmR Mjoin(PATL,utrmmR_UC)
         #define RUC 1
      #else
         #define ATL_utrmmR Mjoin(PATL,utrmmR_UT)
         #define RUT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h)) /* LT & UN share same header */
      #define ATL_utrmmR Mjoin(PATL,utrmmR_UN)
      #define RUN 1
   #endif
#else /* lower */
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h)) /* LT & UN share same header */
      #ifdef Conj_
         #define ATL_utrmmR Mjoin(PATL,utrmmR_LC)
         #define RLC 1
      #else
         #define ATL_utrmmR Mjoin(PATL,utrmmR_LT)
         #define RLT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h)) /* LN & UT share same header */
      #define ATL_utrmmR Mjoin(PATL,utrmmR_LN)
      #define RLN 1
   #endif
#endif

int ATL_utrmmR
   (const enum ATLAS_DIAG Diag,
    ATL_CINT M,         /* it's actually M */
    ATL_CINT N,         /* it's actually N*/
    const SCALAR alpha, 
    const TYPE *A,      /* A is always tri-matrix: here left one */ 
    ATL_CINT lda,
    TYPE *X,            /* it's B: the output and full matrix*/
    ATL_CINT ldx)
{
   void *vp=NULL;
   TYPE *pt, *pr, *pc;
   size_t sz, szC, szT, szR;
   size_t szFull, szPan, szCorner;
   int tnu, tku, tuu, ntfu, tKr;
   const int MU = ATL_TRMMK_MU, 
             NU = ATL_TRMMK_NU, 
             KU = ATL_TRMMK_KU,
             VLEN = ATL_TRMMK_VLEN; 
   int K = ((N+KU-1)/KU)*KU; 
   int nmu = (M+MU-1)/MU, nnu=(N+NU-1)/NU; 
   int mb=nmu*MU, nb=nnu*NU;
   ammkern_t trmmK_b0 = Mjoin(PATL,trmmK_b0);
   ammkern_t trmmK_b1 =  Mjoin(PATL,trmmK_b1);
   #ifdef TCPLX
      ammkern_t trmmK_bn = Mjoin(PATL,trmmK_bn);
      TYPE ONE[2] = {ATL_rone, ATL_rzero}, ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   cm2am_t l2a; 
   tcm2am_t r2a; 
   ablk2cmat_t blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
/*
 * fails if N is greater than KB, need to recurse with smaller value
 */
   if (N > ATL_TRMM_KB)
      return(2);
/*
 * Selecting copy routines...
 * multiplying with alpha in copy routines:
 *    MxM/2, MXN
 */
   if (SCALAR_IS_ONE(alpha))
   {
      #ifdef Upper_
         if (Diag == AtlasUnit)
            r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
         else
            r2a = Mjoin(PATL,trmm_a2blk_Up_a1);
      #else
         if (Diag == AtlasUnit)
            r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
         else
            r2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
      #endif 
      l2a = Mjoin(PATL,trmm_b2blk_a1);
   }
   else
   {
      if (M > N/2) /* multiply alpha in tri-copy*/
      {
         l2a = Mjoin(PATL,trmm_b2blk_a1);
         if (SCALAR_IS_NONE(alpha))
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aN);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Up_aN);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aN);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Lo_aN);
         #endif 
         }
         else /* alphaX, since alpha can't be 0 here */
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aX);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Up_aX);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Lo_aX);
         #endif 
         }
      }
      else /* multiply alpha in gemm copy */
      {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         #endif 
         if (SCALAR_IS_NONE(alpha))
            l2a = Mjoin(PATL,trmm_b2blk_aN);
         else
            l2a = Mjoin(PATL,trmm_b2blk_aX);

      }
   }
/*
 * calculate and allocate memory for workspace 
 */
   tnu = NU, tku = KU;
   tuu = Mmax(tnu, tku);
   /* first do full blocks */
   ntfu = N/tuu;
   tKr = N - ntfu*tuu;
   szFull = (ntfu*(ntfu+1)/2) * tuu * tuu;
   /* now the partial panel */
   #if ( (!defined(Upper_) && !defined(Trans_)) || \
            (defined(Upper_) && defined(Trans_)) )
      szPan = ((tKr+tku-1)/tku)*ntfu * tuu * tku;
   #else
      szPan = ((tKr+tnu-1)/tnu)*ntfu * tuu * tnu;
   #endif
   /* finally the partial block */
   szCorner = ((tKr + tnu - 1)/tnu) * ((tKr + tku - 1)/tku) * tnu * tku;
   szT = szFull + szPan + szCorner;
   szR = mb*K;
   szR += MU*KU;
   szC = (((MU*NU+VLEN-1)/VLEN)*VLEN)*nmu*nnu;
   sz = ATL_MulBySize(szT + szR + szC + 3*ATL_Cachelen);
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp) return(2);
   pt = ATL_AlignPtr(vp);
   pr = pt + (szT SHIFT);
   pr = ATL_AlignPtr(pr);
   pc = pr + (szR SHIFT);
   pc = ATL_AlignPtr(pc);
   #ifdef TCPLX
      l2a(N, M, alpha, X, ldx, pr, pr+szR);
      r2a(N, alpha, A, lda, pt, pt+szT);
      trmmK_b0(nmu, nnu, K, pr+szR, pt+szT, pc,     pr,     pt+szT, pc+szC);
      trmmK_b0(nmu, nnu, K, pr,     pt+szT, pc+szC, pr,     pt,     pc);
      trmmK_bn(nmu, nnu, K, pr,     pt,     pc,     pr+szR, pt,     pc+szC);
      trmmK_b1(nmu, nnu, K, pr+szR, pt,     pc+szC, pr+szR, pt+szT, pc);
      blk2c(M, N, ONE, pc, pc+szC, ZERO, X, ldx);
   #else
      l2a(N, M, alpha, X, ldx, pr);
      r2a(N, alpha, A, lda, pt);
      trmmK_b0(nmu, nnu, K, pr, pt, pc, pr, pt, pc);
      blk2c(M, N, ATL_rone, pc, ATL_rzero, X, ldx);
   #endif
   free(vp); 
   return(0);
}
@ROUT ATL_utrmmL
#include "atlas_misc.h"

/* cases: LN, UT, LT, UN ... LC/UC included */
#ifdef Upper_
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h)) /* LN & UT share same header file*/
      #ifdef Conj_
         #define ATL_utrmmL Mjoin(PATL,utrmmL_UC)
         #define LUC 1
      #else
         #define ATL_utrmmL Mjoin(PATL,utrmmL_UT)
         #define LUT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h)) /* LT & UN share same header file*/
      #define ATL_utrmmL Mjoin(PATL,utrmmL_UN)
      #define LUN 1
   #endif
#else /* lower */
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h))
      #ifdef Conj_
         #define ATL_utrmmL Mjoin(PATL,utrmmL_LC)
         #define LLC 1
      #else
         #define ATL_utrmmL Mjoin(PATL,utrmmL_LT)
         #define LLT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h))
      #define ATL_utrmmL Mjoin(PATL,utrmmL_LN)
      #define LLN 1
   #endif
#endif

int ATL_utrmmL
   (const enum ATLAS_DIAG Diag,
    ATL_CINT M,         /* it's actually M */
    ATL_CINT N,         /* it's actually N*/
    const SCALAR alpha, 
    const TYPE *A,      /* A is always tri-matrix: here left one */ 
    ATL_CINT lda,
    TYPE *X,            /* it's B: the output and full matrix*/
    ATL_CINT ldx)
{
   void *vp=NULL;
   TYPE *pt, *pr, *pc;
   size_t sz, szC, szT, szR;
   size_t szFull, szPan, szCorner;
   int tmu, tku, tuu, ntfu, tKr;
   const int MU = ATL_TRMMK_MU, 
             NU = ATL_TRMMK_NU, 
             KU = ATL_TRMMK_KU,
             VLEN = ATL_TRMMK_VLEN; 
   int K = ((M+KU-1)/KU)*KU; 
   int nmu = (M+MU-1)/MU, nnu=(N+NU-1)/NU; 
   int mb=nmu*MU, nb=nnu*NU;
   ammkern_t trmmK_b0 = Mjoin(PATL,trmmK_b0);
   ammkern_t trmmK_b1 =  Mjoin(PATL,trmmK_b1);
   #ifdef TCPLX
      ammkern_t trmmK_bn = Mjoin(PATL,trmmK_bn);
      TYPE ONE[2] = {ATL_rone, ATL_rzero}, ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   tcm2am_t l2a; 
   cm2am_t r2a;
   ablk2cmat_t blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
/*
 * fails if M is greater than KB to recurse with smaller value
 */
   if (M > ATL_TRMM_KB)
      return(2);
/*
 * Selecting copy routines...
 * multiplying with alpha in copy routines:
 *    MxM/2, MXN
 */
   if (SCALAR_IS_ONE(alpha))
   {
      #ifdef Upper_
         if (Diag == AtlasUnit)
            l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
         else
            l2a = Mjoin(PATL,trmm_a2blk_Up_a1);
      #else
         if (Diag == AtlasUnit)
            l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
         else
            l2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
      #endif 
      r2a = Mjoin(PATL,trmm_b2blk_a1);
   }
   else
   {
      if (N > M/2) /* multiply alpha in tri-copy*/
      {
         r2a = Mjoin(PATL,trmm_b2blk_a1);
         if (SCALAR_IS_NONE(alpha))
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aN);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_aN);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aN);
            else   
               l2a = Mjoin(PATL,trmm_a2blk_Lo_aN);
         #endif 
         }
         else /* alphaX, since alpha can't be 0 here */
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aX);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_aX);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
            else   
               l2a = Mjoin(PATL,trmm_a2blk_Lo_aX);
         #endif 
         }
      }
      else /* multiply alpha in gemm copy */
      {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         #endif 
         if (SCALAR_IS_NONE(alpha))
            r2a = Mjoin(PATL,trmm_b2blk_aN);
         else
            r2a = Mjoin(PATL,trmm_b2blk_aX);
      }
   }
/*
 * calculate and allocate memory for workspace 
 */
#if 0
   szT = mb * K;
#else
   tmu = MU, tku = KU;
   tuu = Mmax(tmu, tku);
   /* first do full blocks */
   ntfu = M/tuu;
   tKr = M - ntfu*tuu;
   szFull = (ntfu*(ntfu+1)/2) * tuu * tuu;
   #if ( (!defined(Upper_) && !defined(Trans_)) || \
         (defined(Upper_) && defined(Trans_)) )
      szPan = ((tKr+tmu-1)/tmu)*ntfu * tuu * tmu;
   #else
      szPan = ((tKr+tku-1)/tku)*ntfu * tuu * tku;
   #endif
   /* finally the partial block */
   szCorner = ((tKr + tmu - 1)/tmu) * ((tKr + tku - 1)/tku) * tmu * tku;
   szT = szFull + szPan + szCorner;
#endif
   szR = nb*K;
   szR += NU*KU; /* ??? */
   szC = (((MU*NU+VLEN-1)/VLEN)*VLEN)*nmu*nnu; 
   sz = ATL_MulBySize(szT + szR + szC + 3*ATL_Cachelen);
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp) return(2);
   pt = ATL_AlignPtr(vp);
   pr = pt + (szT SHIFT);
   pr = ATL_AlignPtr(pr);
   pc = pr + (szR SHIFT);
   pc = ATL_AlignPtr(pc);
   #ifdef TCPLX
      l2a(M, alpha, A, lda, pt, pt+szT);
      r2a(M, N, alpha, X, ldx, pr, pr+szR);
      trmmK_b0(nmu, nnu, K, pt+szT, pr+szR, pc,     pt,     pr+szR, pc+szC);
      trmmK_b0(nmu, nnu, K, pt,     pr+szR, pc+szC, pt,     pr,     pc);
      trmmK_bn(nmu, nnu, K, pt,     pr,     pc,     pt+szT, pr,     pc+szC);
      trmmK_b1(nmu, nnu, K, pt+szT, pr,     pc+szC, pt+szT, pr+szR, pc);
      blk2c(M, N, ONE, pc, pc+szC, ZERO, X, ldx);
   #else
      l2a(M, alpha, A, lda, pt);
      r2a(M, N, alpha, X, ldx, pr);
      trmmK_b0(nmu, nnu, K, pt, pr, pc, pt, pr, pc);
      blk2c(M, N, ONE, pc, ZERO, X, ldx);
   #endif
   free(vp); 
   return(0);
}
@ROUT ATL_trmm_ST
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#ifdef Right_
   #define ATL_trmm_ST Mjoin(PATL,trmmR_ST)
    #define INCR 1
#else
    #define ATL_trmm_ST Mjoin(PATL,trmmL_ST)
    #define INCR ldb
#endif
/*#define DEBUG 1*/
int ATL_trmm_ST
(
   ATL_UINT bv,  /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */
   ATL_CSZT               NT,  /* number of diagonals in triangle */
   ATL_CSZT               NR,  /* number of right hand sides */
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
{
   int RECUR;
   RECUR=0;
   int res;
   #ifdef DEBUG
   printf("D=(%lu,%lu), SD=%c, UP=%c TA=%c DI=%c, alpha=%e\n", NT, NR,
          (bv&1)?'R':'L', (bv&2)?'U':'L', (bv&4)?'T':'N', (bv&16)?'N':'U',
          SVAL alpha);
   #endif
/*
 * FIXME: handle degenerate cases specially... no need to call micro-kernel 
 */
 #if 0
   if (NT == 1)
   {
      if (bv&16)   /* if non-unit, work to do, else nothing to do at M=1! */
      #ifdef TCPLX
      {
         /* Here Here. need to findout correct operations !*/
         Mjoin(PATL,scal)(NR, inv, B, INCR);
      }
      #else
         Mjoin(PATL,scal)(NR, alpha * *A, B, INCR);
      #endif
      else if (!SCALAR_IS_ONE(alpha))  /* unit may still need to scale! */
         Mjoin(PATL,scal)(NR, alpha, B, INCR);
   }
   else if (RECUR)  /* if told to */
      return(1);    /* do pure recursion */
   else
#endif
#if 1     /* default case uses utrmm */
   {
      ATL_UINT LN;
      void *vp;
      TYPE *diag, *T, *R, *w;
      int nmu, nnu, K;
      #ifdef TCPLX
         enum ATLAS_TRANS TRANSA= ((bv&12)==12) ? AtlasConjTrans :  AtlasTrans;
      #else
         #define TRANSA AtlasTrans
      #endif
      int (*utrmm)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   #if 1
   #ifdef Right_
      int Mjoin(PATL,utrmmR_LN)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmR_UT)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmR_LT)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmR_UN)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      #ifdef TCPLX
      int Mjoin(PATL,utrmmR_UC)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmR_LC)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      #endif
   #else
      int Mjoin(PATL,utrmmL_LN)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmL_UT)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmL_LT)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmL_UN)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      #ifdef TCPLX
      int Mjoin(PATL,utrmmL_UC)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      int Mjoin(PATL,utrmmL_LC)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      #endif
   #endif
   #endif
/*
 *    NOTE:
 *       C T U 
 * LNUT  0 0 0 -- LN = 0 
 *       0 1 1 -- UT = 3
 *       1 1 1 -- UC = 7
 *
 * LTUN  0 1 0 -- LT = 2
 *       1 1 0 -- LC = 6
 *       0 0 1 -- UN = 1
 *       
 */
   {  
      int ctu = (bv >> 1) & 7;
   #ifdef Right_
      if (!ctu)
         utrmm = Mjoin(PATL,utrmmR_LN);
      else if (ctu == 2)
         utrmm = Mjoin(PATL,utrmmR_LT);
      #ifdef TCPLX
         else if (ctu == 6)
            utrmm = Mjoin(PATL,utrmmR_LC);
      #endif
      else if (ctu == 1)
         utrmm = Mjoin(PATL,utrmmR_UN);
      else if (ctu == 3)
         utrmm = Mjoin(PATL,utrmmR_UT);
      #ifdef TCPLX
      else if (ctu == 7)
         utrmm = Mjoin(PATL,utrmmR_UC);
      #endif
      else
      {
           fprintf(stderr,"**** Unknown TRMM Right case!!\n");
           /*assert(0);*/
           return(1);
      }
   #else
      if (!ctu)
         utrmm = Mjoin(PATL,utrmmL_LN);
      else if (ctu == 2)
         utrmm = Mjoin(PATL,utrmmL_LT);
      #ifdef TCPLX
         else if (ctu == 6)
           utrmm = Mjoin(PATL,utrmmL_LC);
      #endif
      else if (ctu == 1)
         utrmm = Mjoin(PATL,utrmmL_UN);
      else if (ctu == 3)
         utrmm = Mjoin(PATL,utrmmL_UT);
      #ifdef TCPLX
         else if (ctu == 7)
            utrmm = Mjoin(PATL,utrmmL_UC);
      #endif
      else
      {
           fprintf(stderr, "**** Unknown TRMM Left case!!\n");
           /*assert(0);*/
           return(1);
      }
   #endif
   }
   if (bv & 1)
      res = utrmm((bv&16)?AtlasNonUnit:AtlasUnit, NR, NT, alpha, A, lda, B, ldb);
   else
      res = utrmm((bv&16)?AtlasNonUnit:AtlasUnit, NT, NR, alpha, A, lda, B, ldb);
   return(res);
   }
#else
   else
   {
      enum ATLAS_TRANS TA;
      #ifdef Right_
         ATL_CSZT M = NR; 
         ATL_CSZT N = NT; 
      #else
         ATL_CSZT M = NT; 
         ATL_CSZT N = NR; 
      #endif
      #ifdef TCPLX
         if ((bv&12)==12)
            TA == AtlasConjTrans;
         else
      #endif
      TA = (bv&4) ? AtlasTrans:AtlasNoTrans;
      
      #ifdef DEBUG
      printf("D=(%u,%u), UP=%c TA=%c DI=%c, alpha=%e\n", M, N, (bv&2)?'U':'L',
             TA==AtlasTrans?'T':'N', (bv&16)?'N':'U', alpha);
      #endif
      #ifdef Right_
      Mjoin(PATL,trmm_APR)(AtlasRight, (bv&2)?AtlasUpper:AtlasLower, TA,
         (bv&16)?AtlasNonUnit:AtlasUnit, M, N, alpha, A, lda, B, ldb);
      #else
      Mjoin(PATL,trmm_APR)(AtlasLeft, (bv&2)?AtlasUpper:AtlasLower, TA,
         (bv&16)?AtlasNonUnit:AtlasUnit, M, N, alpha, A, lda, B, ldb);
      #endif
   }
#endif
   return(0);
}
@ROUT ATL_trmm
#include "atlas_misc.h"
#include "atlas_level3.h"
static unsigned int trmm_recR
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,trmmR_ST)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TB;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TB = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TB = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TB = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T + NR*((ldt+1)SHIFT);
         T1 = T;
         B = T + NR*rincT;
         Z0 = Z + NR*(ldz SHIFT);
         C = Z;
      }
      else                       /* LT or UN case */
      {
         Z0 = Z;
         T0 = T;
         B = T + NL*rincT;
         C = Z + NL*(ldz SHIFT);
         T1 = B + NL*cincT;
      }
     
      iret += trmm_recR(bv, NR, NRHS, alpha, T1, ldt, rincT, cincT, C, ldz);
      Mjoin(PATL,gemm)(AtlasNoTrans, TB, NRHS, NR, NL, alpha, Z0, ldz, B, ldt,
                       one, C, ldz);
      iret = 2 + trmm_recR(bv, NL, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      return(iret);
   }
   return(iret);
}

static unsigned int trmm_recL
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,trmmL_ST)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TA;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TA = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *A, *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TA = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TA = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T;
         A = T + NR*rincT;
         Z0 = Z;
         C = Z + (NR SHIFT);
         T1 = A + NR*cincT;
      }
      else                       /* LT or UN case */
      {
         T0 = T + NL*((ldt+1)SHIFT);
         T1 = T;
         A = T + NL*rincT;
         C = Z;
         Z0 = Z + (NL SHIFT);
      }
      iret = 2 + trmm_recL(bv, NL, NRHS, alpha, T1, ldt, rincT, cincT, C, ldz);
      Mjoin(PATL,gemm)(TA, AtlasNoTrans, NL, NRHS, NR, alpha, A, ldt, Z0, ldz,
                          one, C, ldz);
      iret += trmm_recL(bv, NR, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      return(iret);
   }
   return(iret);
}
void Mjoin(PATL,trmm)
(
   const enum ATLAS_SIDE  SD,
   const enum ATLAS_UPLO  UL,
   const enum ATLAS_TRANS TA,
   const enum ATLAS_DIAG  DI,
   ATL_CSZT               M,
   ATL_CSZT               N,
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
/*
 * Purpose
 * =======
 * ATL_trmm matrix operation
 *    B = alpha * op( A ) * X ,   or  B = alpha * X * op( A ),
 *
 * where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 * non-unit, upper or lower triangular matrix and op( A ) is one of
 *    op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
 *
 * The matrix X is overwritten on B.
 */
{
   ATL_SZT incR, incC;
   ATL_UINT r, bv = (SD == AtlasRight) ? 1 : 0;
            /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */

   if (!M || !N)  /* if either array is of size 0 */
      return;     /* return as there is nothing to do */
   if (SCALAR_IS_ZERO(alpha))                   /* alpha == 0 means */
   {
      Mjoin(PATL,gescal)(M, N, alpha, B, ldb);  /* only need to scale B */
      return;
   }
   if (UL == AtlasUpper)
   {
      bv |= 2;
      incR = lda SHIFT;
      incC = 1 SHIFT;
   }
   else
   {
      incR = 1 SHIFT;
      incC = lda SHIFT;
   }
   #ifdef TCPLX
      if (TA == AtlasConjTrans)
         bv |= (8|4);
      else
         bv |= TA == (AtlasTrans) ? 4 : 0;
   #else
      bv |= (TA == AtlasNoTrans) ? 0:4;
   #endif
   bv |= (DI == AtlasNonUnit) ? 16 : 0;
/*
 * LEFT: op(A) * X = alpha * B, A is MxM, X is MxN, B is MxN
 */
   if (SD == AtlasLeft)
      r = trmm_recL(bv, M, N, alpha, A, lda, incR, incC, B, ldb);
   else
      r = trmm_recR(bv, N, M, alpha, A, lda, incR, incC, B, ldb);
}
@ROUT trmmgen
#include "atlas_mmgen.h"
#include "atlas_type.h"

void GenTrCopyHeader(FILE *fp, char pre, char sd, char up0, char ta0, char up,
      char ta, ATL_mmnode_t *mp)
{
/*
 * Acopy always TRMM copy
 * LN: TT2blk-Lo
 * UT: TN2blk-Up
 * two additional cases: unit-diagonal, conjugate
 *
 * NOTE:
 *
 * format:
 *    ATL_da2blk_trmm_LLN_Lo_a1               ATL_dcpFromATt_Lo_a1_1x24_0
 */
/*
 * selecting correct copies from table:
 *    S  U  T  kernels   cpyA    cpB
 *    ---------------------------------
 *    L  L  N    TRMM=1   tAT,L   AN
 *    L  L  T    TRMM=2   tAN,L   AN
 *    L  U  N    TRMM=2   tAT,U   AN
 *    L  U  T    TRMM=1   tAN,U   AN
 *    R  L  N    TRMM=3    AT    tAN,L
 *    R  L  T    TRMM=4    AT    tAT,L
 *    R  U  N    TRMM=4    AT    tAN,U
 *    R  U  T    TRMM=3    AT    tAT,U
 *
 */
   int i, j;
   char *uplo;
   char *uld; /* _DiaU */
   const char al[3] = {'1', 'N', 'X'};
   unsigned int UR, kvec;
   const char uls[2] = {'L', 'U'};
   const char tas[2] = {'N', 'T'};
   char at, tta;

   kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
   uplo = (up == 'L')? "Lo" : "Up";
   if (sd == 'L')
   {
      at = (ta == 'N')? 'T' : 'N';
      UR = mp->mu;
   }
   else  /* R */
   {
      at = ta;
      UR = mp->nu;
   }
   for (j=0 ; j < 2; j++)
   {
      if (j == 1)
      {
         uld = "diagU_";
         fprintf(fp, "/*\n* Unit Diagonal \n*/\n");
      }
      else
         uld = "";

      for (i=0; i < 3; i++)
      {
/*
 *       copy name format
 *       ATL_<pre>cp[Into,From]A[N,T][g,k,y,r,s]_aX_<ku>x<nu>_<kvec>
 */
         if (pre == 'c' || pre == 'z')
         {
            tta = (at == 'N')? 'C' : 'H';
            fprintf(fp, "#ifdef Conj_\n");
            fprintf(fp,
      "#define ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c ATL_%ccpFromA%ct_%s_%sa%c_%ux%u_%u\n",
                  pre, sd, up0, ta0, uplo, uld, al[i],
                  pre, tta, uplo, uld, al[i], mp->ku, UR, kvec);
            fprintf(fp, "#else\n");
         }
         fprintf(fp,
      "#define ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c ATL_%ccpFromA%ct_%s_%sa%c_%ux%u_%u\n",
                 pre, sd, up0, ta0, uplo, uld, al[i],
                 pre, at, uplo, uld, al[i], mp->ku, UR, kvec);
         if (pre == 'c' || pre == 'z')
            fprintf(fp, "#endif\n");

         fprintf(fp, "void ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c", pre, sd, up0, ta0,
                 uplo, uld, al[i]);
         if (pre == 'd' || pre == 's')
            fprintf(fp, "(ATL_CSZT,const TYPE,const TYPE*,ATL_CSZT,TYPE*);\n");
         else
            fprintf(fp, "(ATL_CSZT,const TYPE*,const TYPE*, ATL_CSZT,TYPE*,TYPE*);\n");

         fprintf(fp, "#ifndef ATL_%ctrmm_a2blk_%s_%sa%c\n   #define "
            "ATL_%ctrmm_a2blk_%s_%sa%c ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c\n#endif\n",
                 pre, uplo, uld, al[i],  pre, uplo, uld, al[i],  pre, sd, up0,
                 ta0, uplo, uld, al[i]);
      }
   }

}

void GenTrmmHead(char pre, char *outd, char sd, char up, char ta,
      ATL_mmnode_t *mp)
{
   char *of;
   FILE *fp;
   int i, flg, k, L;
   char *uplo;
   const char *st[5] = {"VLEN", "KVEC", "MU", "NU", "KU"};
   char uld [6]; /* _DiaU */
   const char be[3] = {'0', '1', 'n'};
   const char al[3] = {'1', 'N', 'X'};
   unsigned int UR, kvec;
   const char uls[2] = {'L', 'U'};
   const char tas[2] = {'N', 'T'};
   char at;
   ATL_cpnode_t *cb;

   L = strlen(outd) + 24;
   of = malloc(L);
   assert(of);
/*
 * inclusion guard
 */
   k = sprintf(of, "%s/atlas_%cutrmm%c_%c%c.h", outd, pre, sd, up, ta);
   assert(k<L);
   fp = fopen(of, "w");
   assert(fp);
   free(of);
   fprintf(fp, "#ifndef ATLAS_%cTRMM%c_%c%c_H\n",
           toupper(pre), toupper(sd), toupper(up), toupper(ta));
   fprintf(fp, "   #define ATLAS_%cTRMM%c_%c%c_H 1\n\n",
           toupper(pre), toupper(sd), toupper(up), toupper(ta));

   fprintf(fp, "#include \"atlas_amm.h\"\n");
/*
 * data
 */
   assert(mp);
   fprintf(fp, "#define ATL_TRMM_%c%c%c_KB %d\n", sd, up, ta, mp->kbB);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_VLEN %d\n", sd, up, ta, mp->vlen);
   kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_KVEC %u\n", sd, up, ta, kvec);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_MU %d\n", sd, up, ta, mp->mu);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_NU %d\n", sd, up, ta, mp->nu);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_KU %d\n", sd, up, ta, mp->ku);

   for (i=0; i<5; i++)
   {
      fprintf(fp, "#ifndef ATL_TRMMK_%s\n", st[i]);
      fprintf(fp, "   #define ATL_TRMMK_%s ATL_TRMMK_%c%c%c_%s\n", st[i], sd, up,
              ta, st[i]);
      fprintf(fp, "#endif\n");
   }
   fprintf(fp, "#ifndef ATL_TRMM_KB\n");
   fprintf(fp, "   #define ATL_TRMM_KB ATL_TRMM_%c%c%c_KB\n", sd, up, ta);
   fprintf(fp, "#endif\n");
/*
 * kernel info
 */
   fprintf(fp, "/*\n* TRMM KERNEL INFO\n*/\n");
   for (i=0; i < 3; i++)
   {
      fprintf(fp,
"void ATL_%ctrmmK_%c%c%c_b%c(ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*, \n",
              pre, sd, up, ta, be[i]);
      fprintf(fp,
"                            TYPE*, const TYPE*, const TYPE*, const TYPE*);\n");
      fprintf(fp, "#ifndef ATL_%ctrmmK_b%c\n", pre, be[i]);
      fprintf(fp, "   #define ATL_%ctrmmK_b%c ATL_%ctrmmK_%c%c%c_b%c\n", pre,
              be[i], pre, sd, up, ta, be[i]);
      fprintf(fp, "#endif\n");
   }
/*
 * blk2C
 */
   fprintf(fp, "/*\n* BLK2C COPY\n*/\n");
   flg = (1<<CPF_CBLK);
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   cb = GetCopyNodeFromMM(flg, mp, NULL);
   assert(cb);
   cb->flag |= (1<<CPF_AL1);
   cb->flag |= (1<<CPF_BE0);
/*
 * blk2c copy is same as gemm... so we need gemm style blk2c copy
 * so, disable trmm flag for this specific copy routine
 */
   cb->flag &= ~(1<<CPF_TRMM);
   cb->rout = GetCopyName(cb, 0);
   fprintf(fp, "#define ATL_%cblk2c_trmm_%c%c%c_a1b0 %s\n",
              pre, sd, up, ta, cb->rout);
   fprintf(fp, "void ATL_%cblk2c_trmm_%c%c%c_a1b0", pre, sd, up, ta);
   if (pre == 'd' || pre == 's')
      fprintf(fp,
              "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,"
              "TYPE*, ATL_CSZT);\n");
   else
      fprintf(fp,
               "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,"
               "const SCALAR,TYPE*, ATL_CSZT);\n");
   fprintf(fp, "#ifndef ATL_%ctrmm_blk2c_a1b0\n   #define "
         "ATL_%ctrmm_blk2c_a1b0 ATL_%cblk2c_trmm_%c%c%c_a1b0\n#endif\n",
            pre, pre, pre, sd, up, ta);
   KillAllCopyNodes(cb);
/*
 * NOTE: depending on the side, Acopy and Bcopy changes
 * side = left: Acopy is trmm copy and Bcopy is gemm copy
 * side = right: Acopy is gemm copy and Bcopy is trmm copy although trmm copy is
 * a2blk and gemm copy is b2blk in header file
 */
/*
 * Bcopy: always gemm copy
 */
   fprintf(fp, "/*\n* B2BLK COPY\n*/\n");
   flg = 0;
   if (sd == 'R')
   {
      flg |= (1<<CPF_ABLK);
      flg |= (1<<CPF_TRANS);
   }

   flg |= (1<<CPF_TOBLK); /* b2blk*/
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   cb = GetCopyNodeFromMM(flg, mp, NULL);
   assert(cb);
   for (i=0; i < 3; i++)
   {
      if (al[i] == '1')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_ALX));
         cb->flag |= (1<<CPF_AL1);
      }
      else if (al[i] == 'N')
      {
         cb->flag &= ~((1<<CPF_ALX)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALN);
      }
      else if (al[i] == 'X')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALX);
      }
      if(i) free(cb->rout);
      cb->flag &= ~(1<<CPF_TRMM);
      cb->rout = GetCopyName(cb, 0);
      fprintf(fp, "#define ATL_%cb2blk_trmm_%c%c%c_a%c %s\n",
              pre, sd, up, ta, al[i], cb->rout);
      fprintf(fp, "void ATL_%cb2blk_trmm_%c%c%c_a%c", pre, sd, up, ta, al[i]);
         if (pre == 'd' || pre == 's')
            fprintf(fp,
            "(ATL_CSZT,ATL_CSZT,const TYPE,const TYPE*,ATL_CSZT,TYPE*);\n");
         else
            fprintf(fp, "(ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,"
                        "ATL_CSZT,TYPE*,TYPE*);\n");
         fprintf(fp, "#ifndef ATL_%ctrmm_b2blk_a%c\n   #define "
         "ATL_%ctrmm_b2blk_a%c ATL_%cb2blk_trmm_%c%c%c_a%c\n#endif\n",
            pre, al[i],  pre, al[i],  pre, sd, up, ta, al[i]);
   }
   KillAllCopyNodes(cb);
/*
 * In eaqch header file, we have two options.
 * LN/UT and LT/UN
 */
   fprintf(fp, "/*\n* A2BLK COPY\n*/\n");
   if (ta == 'N')
   {
      GenTrCopyHeader(fp, pre, sd, 'L', 'N', 'L', 'N', mp);
      GenTrCopyHeader(fp, pre, sd, 'L', 'N', 'U', 'T', mp);
   }
   else /* LT UN case */
   {
      GenTrCopyHeader(fp, pre, sd, 'L', 'T', 'L', 'T', mp);
      GenTrCopyHeader(fp, pre, sd, 'L', 'T', 'U', 'N', mp);
   }
   fprintf(fp, "#endif\n");
}


void GenMicroTrmm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
{
   int i, L;
   int trmmid=0;
   int mu=mb->mu, nu=mb->nu;
   char *ln, *mk;
   char rt[256];

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);
/*
 * TRMM=1 (left lower), 2 (left upper), 3 (right lower), 4 (right upper).
 * Transform:
 *    LLN : 1           RLN : 3
 *    LLT : 2           RLT : 4
 *    LUN : 2           RUN : 4
 *    LUT : 1           RUT:  3
 *
 *    transpose reverses the upper/lower
 */
   if (sd == 'R')
      trmmid = 2;
   if (ta == 'N')
      trmmid += (up=='L')? 1 : 2;
   else
      trmmid += (up=='L')? 2 : 1;

   i = sprintf(rt, "%s/ATL_%ctrmmK_%c%c%c_%ux%ux%u.c", outd, pre, sd, up, ta,
               mb->mu, mb->nu, mb->ku);
   assert(i<256);
   if (mb->rout) free(mb->rout);
   mb->rout = DupString(rt);

   mk = MMGetGenString(pre, mb);
   i = sprintf(ln, "%s TRMM=%d", mk, trmmid);
   /*printf("genstr = %s\n", ln);*/
   free(mk);
   assert(i < L);
   assert(!Sys2File(ln, NULL));
   free(ln);
}

void AddCopyDirective(FILE *fp, char *nam, char pre, char alc, unsigned int UR)
{
   int i, k;
   int sz;
   char *cpn, *ccpn;

   sz = strlen(nam);
   sz += 10; /* might be added: diagU_, [up,lo]_*/
   cpn = malloc(sz);
   assert(cpn);
/*
 * split the string at a1/aX/aN
 */
   assert(nam);
   k = strlen(nam);
   for (i=0; i < k; i++, nam++)
   {
      if (*nam == 'a')
      {
         assert(*(nam+1)!='\0'); /* assumption: must consists of a[1,N,X] */
         if ( *(nam+1) == '1' || *(nam+1) == 'N' || *(nam+1) == 'X')
            break;
      }
      cpn[i] = *nam;
   }
   cpn[i] = '\0';
/*
 * for conj: convert ATt to AHt, ANt to ACt
 */
   if (pre == 'z' || pre == 'c')
   {
      ccpn = malloc(sz);
      assert(ccpn);
      strcpy(ccpn, cpn);
      k = strlen(ccpn);
      for (i=0; i < k-2; i++)
      {
         if (ccpn[i] == 'A' && ccpn[i+1] == 'N' && ccpn[i+2] == 't')
            ccpn[i+1] = 'C';
         else if (ccpn[i] == 'A' && ccpn[i+1] == 'T' && ccpn[i+2] == 't')
            ccpn[i+1] = 'H';
      }
   }

   fprintf(fp, "#ifdef SCALAR\n  #undef SCALAR\n#endif\n");
   fprintf(fp, "#ifdef TYPE\n  #undef TYPE\n#endif\n");
   fprintf(fp, "#ifdef SREAL\n  #undef SREAL\n#endif\n");
   fprintf(fp, "#ifdef DREAL\n  #undef DREAL\n#endif\n");
   fprintf(fp, "#ifdef SCPLX\n  #undef SCPLX\n#endif\n");
   fprintf(fp, "#ifdef DCPLX\n  #undef DCPLX\n#endif\n");
   fprintf(fp, "#ifdef ALPHA1\n  #undef ALPHA1\n#endif\n");
   fprintf(fp, "#ifdef ALPHAN\n  #undef ALPHAN\n#endif\n");
   fprintf(fp, "#ifdef ALPHAN1\n  #undef ALPHAN1\n#endif\n");
   fprintf(fp, "#ifdef ALPHAX\n  #undef ALPHAX\n#endif\n");
   fprintf(fp, "#ifdef BETA1\n  #undef BETA1\n#endif\n");
   fprintf(fp, "#ifdef BETAN\n  #undef BETAN\n#endif\n");
   fprintf(fp, "#ifdef BETAN1\n  #undef BETAN1\n#endif\n");
   fprintf(fp, "#ifdef BETAX\n  #undef BETAX\n#endif\n");
/*
 * directives for type
 */
   if (pre == 's')
   {
      fprintf(fp, "#define SREAL 1\n");
      fprintf(fp, "#define TYPE float\n");
      fprintf(fp, "#define SCALAR TYPE\n");
   }
   else if (pre == 'd')
   {
      fprintf(fp, "#define DREAL 1\n");
      fprintf(fp, "#define TYPE double\n");
      fprintf(fp, "#define SCALAR TYPE\n");
   }
   else if (pre == 'c')
   {
      fprintf(fp, "#define SCPLX 1\n");
      fprintf(fp, "#define TYPE float\n");
      fprintf(fp, "#define SCALAR TYPE*\n");
   }
   else if (pre == 'z')
   {
      fprintf(fp, "#define DCPLX 1\n");
      fprintf(fp, "#define TYPE double\n");
      fprintf(fp, "#define SCALAR TYPE*\n");
   }
   else
   {
      printf("UNKNOWN TYPE\n");
      assert(0);
   }
/*
 * directives alpha
 */
   if (alc == '1')
      fprintf(fp, "#define ALPHA1 1\n");
   else if (alc == 'X')
      fprintf(fp, "#define ALPHAX 1\n");
   else if (alc == 'N')
   {
      fprintf(fp, "#define ALPHAN 1\n");
      fprintf(fp, "#define ALPHAN1 1\n");
   }
/*
 * UR &
 */
   fprintf(fp, "#define ATL_NU %u\n", UR);
   fprintf(fp, "\n#ifdef UnitDiag_\n");
   fprintf(fp, "   #ifdef Upper_\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sUp_diagU_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sUp_diagU_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') fprintf(fp, "      #endif\n");
   fprintf(fp, "   #else\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sLo_diagU_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sLo_diagU_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #endif\n");
   fprintf(fp, "#else\n");
   fprintf(fp, "   #ifdef Upper_\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sUp_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sUp_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #else\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sLo_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sLo_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #endif\n");
   fprintf(fp, "#endif\n\n");
   
   if (pre == 'z' || pre == 'c') 
      free(ccpn);
   free(cpn);
}

void GenTrCopy(ATL_cpnode_t *cb, char *outd, char pre, char sd, char up, char ta)
{
   int i, k, L;
   char *ln, *cpg;
   char rt[256];
   const char al[3] = {'1', 'N', 'X'};
   FILE *fp;

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);

   cb->flag &= ~(1<<CPF_TRANS);
   if (sd == 'L')
      cb->flag |= (ta=='N') ? (1<<CPF_TRANS) : 0;
   else
      cb->flag |= (ta=='T') ? (1<<CPF_TRANS) : 0;

   /*if (up == 'L')
      cb->flag |= (1<<CPF_LOWER);
   else
      cb->flag &= ~(1<<CPF_LOWER);
   */

   for (i=0; i < 3; i++)
   {
      if (al[i] == '1')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_ALX));
         cb->flag |= (1<<CPF_AL1);
      }
      else if (al[i] == 'N')
      {
         cb->flag &= ~((1<<CPF_ALX)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALN);
      }
      else if (al[i] == 'X')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALX);
      }
      cpg = GetCopyName(cb, 0);
      k = sprintf(rt, "%s/%s.c", outd, cpg);
      assert(k<256);
/*
 *    add copy directives at the start of the source file
 */
      fp = fopen(rt, "w");
      assert(fp);
      AddCopyDirective(fp, cpg, pre, al[i], cb->nu); /*always nu if not CPF_CBLK*/
      fclose(fp);

      free(cpg);

      if (cb->rout) free(cb->rout);
      cb->rout = DupString("ATL_tmp.c");
      cpg = GetCopyGenStr(cb);
      k = sprintf(ln, "%s", cpg);
      free(cpg);
      assert(k < L);
      assert(!Sys2File(ln, NULL));
/*
 *    append files
 */
      k = sprintf(ln, "cat %s  >> %s", cb->rout, rt);
      assert(k < L);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN CMD: '%s'\n", ln);
         assert(0);
      }
   }
   free(ln);
}

void GenCopyTrmm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
/*
 * LN/UT: tAT-L, tAN-U
 * LT/UN: tAN-L, tAT-U
 */
{
   int i, L, flg;
   char *ln, *rt;
   ATL_cpnode_t *cb;

/*
 * copy name format
 *    ATL_<pre>cp[Into,From]A[N,T][g,k,y,r,s,t]_aX_<ku>x<nu>_<kvec>
 */
   flg = (1<<CPF_TOBLK);
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   if (sd == 'L')
      flg |= (1<<CPF_ABLK);

   cb = GetCopyNodeFromMM(flg, mb, NULL);
   assert(cb);
/*
 * up is always 'L'... ta can be 'N' or 'T'
 *
 * LN/UT: tAT-L, tAN-U
 * LT/UN: tAN-L, tAT-U
 */
   /*printf("Case: %c%c%c\n", sd, up, ta);*/
   if (ta == 'N')
   {
      GenTrCopy(cb, outd, pre, sd, 'L', 'N');
      GenTrCopy(cb, outd, pre, sd, 'U', 'T');
   }
   else
   {
      GenTrCopy(cb, outd, pre, sd, 'L', 'T');
      GenTrCopy(cb, outd, pre, sd, 'U', 'N');
   }
   KillAllCopyNodes(cb);
}

void GenMakeTrmm(char pre, char *outd, char up, char *sds, char *tas,
                 ATL_mmnode_t **MBs)
{
   int k, i, UR;
   FILE *fp;
   char *fn, *typ, *comp, *sp, *flgs;
   const char be[3] = {'0', '1', 'n'};
   const char al[3] = {'1', 'N', 'X'};
   int bi, ai, kvec;
   char tta;

   k = strlen(outd) + 24;
   fn = malloc(k);
   assert(fn);
   i = sprintf(fn, "%s/Makefile", outd);
   fp = fopen(fn, "w");
   assert(fp);
   free(fn);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");

   fprintf(fp, "lib : %clib.grd\n", pre);
   fprintf(fp, "all : %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n\n", pre);

   fprintf(fp, "obj = ");
   if (pre == 'c' || pre == 's')
   {
      comp = "$(SKC)";
      flgs = "$(SKCFLAGS)";
   }
   else
   {
      comp = "$(DKC)";
      flgs = "$(DKCFLAGS)";
   }
   if (pre == 'z')
      typ = "DCPLX";
   else if (pre == 'c')
      typ = "SCPLX";
   else if (pre == 's')
      typ = "SREAL";
   else
      typ = "DREAL";

   for (k=0; k < 2; k++)  /* 0: objname, 1: target*/
   {
/*
 *    kernels
 */
      int s, di;
      for (s=i=0; s < 2; s++)
      {
         int it;
         char sd=sds[s];
         for (it=0; it < 2; it++)
         {
            ATL_mmnode_t *mp;
            char ta = tas[it];
            for (mp=MBs[i++]; mp; mp=mp->next)
            {
               for (bi=0; bi < 3; bi++)
               {
                  if (!k)
                     fprintf(fp, "\\\n      ATL_%ctrmmK_%c%c%c_b%c.o ",
                             pre, sd, up, ta, be[bi]);
                  else /* target phase */
                  {
                     fprintf(fp, "ATL_%ctrmmK_%c%c%c_b%c.o :"
                             " ATL_%ctrmmK_%c%c%c_%ux%ux%u.c $(deps)\n",
                              pre, sd, up, ta, be[bi],
                              pre, sd, up, ta, mp->mu, mp->nu, mp->ku);
                     fprintf(fp, "\t%s $(CDEFS2) -D%s=1 -DBETA%c=1 \\\n", comp,
                           typ, (be[bi]=='n')?'N':be[bi]);
                     sp = "        ";
                     if (FLAG_IS_SET(mp->flag, MMF_MVA))
                     {
                        fprintf(fp, "%s-DATL_MOVEA", sp);
                        sp = " ";
                     }
                     if (FLAG_IS_SET(mp->flag, MMF_MVB))
                     {
                        fprintf(fp, "%s-DATL_MOVEB", sp);
                        sp = " ";
                     }
                     if (FLAG_IS_SET(mp->flag, MMF_MVC))
                     {
                        fprintf(fp, "%s-DATL_MOVEC", sp);
                        sp = " ";
                     }
                     fprintf(fp, " \\\n        %s \\\n", flgs);
                     fprintf(fp,
                     "        -DATL_USERMM=ATL_%ctrmmK_%c%c%c_b%c \\\n"
                     "        -c -o ATL_%ctrmmK_%c%c%c_b%c.o \\\n",
                             pre, sd, up, ta, be[bi],
                             pre, sd, up, ta, be[bi]);
                     fprintf(fp, "        ATL_%ctrmmK_%c%c%c_%ux%ux%u.c \n",
                             pre, sd, up, ta, mp->mu, mp->nu, mp->ku);
                  }
               }
            }
         }
      }
/*
 *    copies
 *    e.g., ATL_zcpFromACt_Up_diagU_a1_1x4_0
 */
      for (di=0; di < 2; di++)
      {
         char *dia = di ? "_diagU": "";
         for (s=i=0; s < 2; s++)
         {
            int it;
            char sd=sds[s];
            for (it=0; it < 2; it++)
            {
               ATL_mmnode_t *mp;
               char ta = tas[it];
               for (mp=MBs[i++]; mp; mp=mp->next)
               {
                  UR = (sd=='L')? mp->mu : mp->nu;
                  kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
                  for (ai=0; ai < 3; ai++)
                  {
                     int ul;
                     for (ul=0; ul < 2; ul++)
                     {
                        int c;
                        const int NCNJ = ((pre == 'c' || pre == 'z')) ? 2:1; 
                        for (c=0; c < NCNJ; c++)
                        {
                           if (c)
                              tta = (ta == 'N')? 'C' : 'H';
                           else
                              tta = ta;
                           if (!k)
                           {
                              fprintf(fp,
                              "\\\n      ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o ",
                                   pre, tta, (ul?"Up":"Lo"), dia, al[ai], mp->ku,
                                   UR, kvec);
                           }
                           else
                           {
                              fprintf(fp, "ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o :"
                                       " ATL_%ccpFromA%ct_a%c_%ux%u_%u.c\n",
                                       pre, tta, (ul?"Up":"Lo"), dia, al[ai],
                                       mp->ku, UR, kvec,
                                       pre, ta, al[ai], mp->ku, UR, kvec);

                              fprintf(fp, "\t%s $(CDEFS2) %s", comp, flgs);
                              if (di)
                                 fprintf(fp, " -DUnitDiag_=1");
                              if (ul)
                                 fprintf(fp, " -DUpper_=1");
                              else
                                 fprintf(fp, " -DLower_=1");
                              if (c)
                                 fprintf(fp, " -DConj_=1");
                              fprintf(fp,
                                 " \\\n\t-c ATL_%ccpFromA%ct_a%c_%ux%u_%u.c \\\n",
                                   pre, ta, al[ai], mp->ku, UR, kvec);
                              fprintf(fp,
                                 "\t-o ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o\n",
                                   pre, tta, (ul?"Up":"Lo"), dia, al[ai], mp->ku,
                                   UR, kvec);
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (!k)
      {
         fprintf(fp, "\n\n%clib : %clib.grd\n", pre, pre);
         fprintf(fp, "%clib.grd : $(obj)\n", pre);
         fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
         fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n\ttouch %clib.grd\n\n", pre);
      }
   }
   fclose(fp);
}

void GenAllTrmm(char pre, char *outd)
{
   int L, i, s;
   char sds[2] = {'L', 'R'};
   char tas[2] = {'N', 'T'};
   char up='L';
   char *od;
   char fn[16];
   ATL_mmnode_t *MBs[4];
#if 1
/*
 * Delete and the re-create <pre>UTRSM subdir
 */
   L = strlen(outd) + 8 + 7;
   od = malloc(L);
   assert(od);
   i = sprintf(od, "rm -rf %s/%cUTRMM", outd, pre);
   assert(i < L);
   Sys2File(od, NULL);
   od[0]='m'; od[1]='k'; od[2]='d'; od[3]='i'; od[4]='r'; od[5]=' ';
   assert(!Sys2File(od, NULL));
#endif
   strcpy(fn, "trmmS_LN.sum");

   for (i=s=0; s < 2; s++)
   {
      char sd=sds[s];
      int it;
      for (it=0; it < 2; it++)
      {
         char ta = tas[it];
         ATL_mmnode_t *mb;
         fn[4] = sd;
         fn[7] = ta;
         mb = ReadMMFileWithPath(pre, "res", fn);
         assert(mb);
         MBs[i] = mb;
         GenMicroTrmm(pre, od+7, sd, up, ta, mb);
         GenCopyTrmm(pre, od+7, sd, up, ta, mb);
         GenTrmmHead(pre, od+7, sd, 'L', ta, mb);
         i++;
      }
   }
   GenMakeTrmm(pre, od+7, up, sds, tas, MBs);
   for (i=0; i < 4; i++)
      KillAllMMNodes(MBs[i]);
   free(od);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   /*fprintf(stderr,
"This will create the <pre>UTRMM subdir in <outdir>, and populate it with\n"
"all utrmm kernels and their Makefile.\n");*/
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -o <path>: what directory to output all files to?\n");
   fprintf(stderr, "   -p [s,d]: set type/precision prefix (d) \n"
           "      s/d will generate for complex (c/z) as well\n");

   exit(ierr ? ierr : -1);
}

char *GetFlags(int nargs, char **args, char *PRE)
{
   FILE *fpin=stdin;
   ATL_mmnode_t *mb=NULL, *bkb=NULL, *mp;
   char *outd=NULL;
   int i;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         outd = DupString(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!outd)
      outd = DupString("tmp");

   *PRE = pre;
   return(outd);
}

int main(int nargs, char **args)
{
   char *outd;
   char pre;
   outd = GetFlags(nargs, args, &pre);
   GenAllTrmm(pre, outd);
   free(outd);
   return(0);
}
@ROUT !
