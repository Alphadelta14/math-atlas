@ROUT ATL_sminfo
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(ATLAS_UPR,amm_kern.h))
@whiledef al N 1
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_a@(al).h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_a@(al).h))
#ifdef TCPLX
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromAHg_a@(al).h))
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromACg_a@(al).h))
#endif
@endwhile

#define ATL_DECL_ 1
#ifdef Right_
   #ifdef Upper_
      #error "Upper not supported"
   #else
      #ifdef Trans_
         #include Mstr(Mjoin(ATLAS_PRE,utrsmR_LT.h))
         #include Mstr(Mjoin(ATLAS_PRE,trsmRT_view.h))
         #define ATL_sminfo Mjoin(PATL,sminfoR_LT)
         #define INCA lda
         #define BV (1|4)
      #else
         #include Mstr(Mjoin(ATLAS_PRE,utrsmR_LN.h))
         #include Mstr(Mjoin(ATLAS_PRE,trsmRN_view.h))
         #define ATL_sminfo Mjoin(PATL,sminfoR_LN)
         #define INCA 1
         #define BV 1
      #endif
   #endif
#else  /* Left */
   #ifdef Upper_
      #error "Upper not supported"
   #else
      #ifdef Trans_
         #include Mstr(Mjoin(ATLAS_PRE,utrsmL_LT.h))
         #include Mstr(Mjoin(ATLAS_PRE,trsmLT_view.h))
         #define ATL_sminfo Mjoin(PATL,sminfoL_LT)
         #define INCA 1
         #define BV 4
      #else
         #include Mstr(Mjoin(ATLAS_PRE,utrsmL_LN.h))
         #include Mstr(Mjoin(ATLAS_PRE,trsmLN_view.h))
         #define ATL_sminfo Mjoin(PATL,sminfoL_LN)
         #define INCA lda
         #define BV 0
      #endif
   #endif
#endif
#undef ATL_DECL_
   /* bv: 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */
int ATL_sminfo
   (sminfo_t *ip, ATL_CUINT bv, ATL_CSZT N, ATL_CSZT R, 
    const SCALAR alpha, ATL_CSZT lda, ATL_CSZT ldb)
{
   int iv=ATL_VIEW_BEST_IDX, imm, icpA, icpB, icpC, k;
   int ALLT=0;
   float spf;
   #ifndef TCPLX
      ATL_iptr_t iptmp;
   #endif
   ATL_cparr_t *cp = (ATL_cparr_t *)&(ip->b2blk);
/*
 * Really need to see if its better to do gemm+trsm in this case, but for
 * now just assume not
 */
   if (N > ATL_VIEW_BEST_KB) /* inner product case */
   {
      int nb;
      for (; iv; iv--)
      {
         nb = ATL_GetViewKB(iv);
         if (N >= nb)
            break;
      }
      if (N > nb && iv < ATL_VIEW_BEST_IDX)
         iv++;
   }
   ALLT = ATL_trsm_allT(iv);
   ip->bv = (ALLT<<5) | bv;
   ATL_GetViewInfo(iv, spf, k, ip->rb, ip->kb, imm, icpA, icpB, k,k,k,k);
   icpA += icpA;
   icpB += icpB;
   #ifdef TCPLX
      ATL_AMM_info(imm, &ip->amm_b0, &ip->amm_b1, &ip->amm_bn, ip->mmflg,
                   ip->mu, ip->nu, ip->ku, k, k, k, k);
   #else
      ATL_AMM_info(imm, &ip->amm_b0, &ip->amm_b1, &iptmp, ip->mmflg,
                   ip->mu, ip->nu, ip->ku, k, k, k, k);
   #endif
   ip->utrsm = ATL_findutrsm(ALLT, ip->mu, ip->nu);
   if (ALLT)
   {
      k = ip->mu;
      ip->mu = ip->nu;
      ip->nu = k;
   }
   #ifdef Right_  /* LT_UN or LN_UT case */
      *cp = (ALLT) ? ATL_CpyFromATg_a1[icpB]:ATL_CpyFromATg_a1[icpA];
   #else
      *cp = (ALLT) ? ATL_CpyFromANg_a1[icpA]:ATL_CpyFromANg_a1[icpB];
   #endif
   cp = (ATL_cparr_t *)&(ip->a2blk);
   #ifdef Trans_  /* LT or UN case */
      if (bv&2) /* UN case */
      {
         #ifdef Right_
            ip->incA = 1 SHIFT;
         #else
            ip->incA = lda SHIFT;
         #endif
         #ifdef TCPLX
            if ((bv&8))  /* UC case! */
               #ifdef Right_ 
                  *cp  = (ALLT)?ATL_CpyFromAHg_aN[icpA]:ATL_CpyFromAHg_aN[icpB];
               #else
                  *cp  = (ALLT)?ATL_CpyFromACg_aN[icpB]:ATL_CpyFromACg_aN[icpA];
               #endif
            else
         #endif
         #ifdef Right_ 
            *cp = (ALLT) ? ATL_CpyFromANg_aN[icpA]:ATL_CpyFromANg_aN[icpB];
         #else
            *cp = (ALLT) ? ATL_CpyFromATg_aN[icpB]:ATL_CpyFromATg_aN[icpA];
         #endif
      }
      else      /* LT case */
      {
         #ifdef Right_
            ip->incA = lda SHIFT;
         #else
            ip->incA = 1 SHIFT;
         #endif
         #ifdef TCPLX
            if (bv&8) /* LH case! */
               #ifdef Right_ 
                  *cp  = (ALLT)?ATL_CpyFromAHg_aN[icpA]:ATL_CpyFromAHg_aN[icpB];
               #else
                  *cp  = (ALLT)?ATL_CpyFromACg_aN[icpB]:ATL_CpyFromACg_aN[icpA];
               #endif
            else
         #endif
         #ifdef Right_ 
            *cp = (ALLT) ? ATL_CpyFromATg_aN[icpA]:ATL_CpyFromATg_aN[icpB];
         #else
            *cp = (ALLT) ? ATL_CpyFromANg_aN[icpB]:ATL_CpyFromANg_aN[icpA];
         #endif
      }
   #else /* LN or UT case, these cases use incA backwards (negative) */
      if (bv&2)  /* UT case */
      {
         #ifdef Right_
            ip->incA = lda SHIFT;  
         #else
            ip->incA = 1 SHIFT;  
         #endif
         #ifdef TCPLX
            if (bv&8) /* UH case! */
               #ifdef Right_
                  *cp  = (ALLT)?ATL_CpyFromAHg_aN[icpA]:ATL_CpyFromAHg_aN[icpB];
               #else
                  *cp  = (ALLT)?ATL_CpyFromACg_aN[icpB]:ATL_CpyFromACg_aN[icpA];
               #endif
            else
         #endif
         #ifdef Right_
            *cp = (ALLT) ? ATL_CpyFromATg_aN[icpA]:ATL_CpyFromATg_aN[icpB];
         #else
            *cp = (ALLT) ? ATL_CpyFromANg_aN[icpB]:ATL_CpyFromANg_aN[icpA];
         #endif
      }
      else /* LN case */
      {
         #ifdef Right_
            ip->incA = 1 SHIFT;
         #else
            ip->incA = lda SHIFT;
         #endif
         #ifdef TCPLX
            if (bv&8) /* LC case! */
               #ifdef Right_
                  *cp  = (ALLT)?ATL_CpyFromAHg_aN[icpA]:ATL_CpyFromAHg_aN[icpB];
               #else
                  *cp  = (ALLT)?ATL_CpyFromACg_aN[icpB]:ATL_CpyFromACg_aN[icpA];
               #endif
            else
         #endif
         #ifdef Right_
            *cp = (ALLT) ? ATL_CpyFromANg_aN[icpA]:ATL_CpyFromANg_aN[icpB];
         #else
            *cp = (ALLT) ? ATL_CpyFromATg_aN[icpB]:ATL_CpyFromATg_aN[icpA];
         #endif
      }
   #endif
   return(iv);
}
@ROUT ATL_trsm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def contrib "Antoine Petitet"
#include "atlas_misc.h"
#include "atlas_level3.h"
static unsigned int trsm_recR
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,trsmR_IP)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TB;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TB = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TB = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TB = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T + NR*((ldt+1)SHIFT);
         T1 = T;
         B = T + NR*rincT;
         Z0 = Z + NR*(ldz SHIFT);
         C = Z;
      }
      else                       /* LT or UN case */
      {
         Z0 = Z;
         T0 = T;
         B = T + NL*rincT;
         C = Z + NL*(ldz SHIFT);
         T1 = B + NL*cincT;
      }
      iret = 2 + trsm_recR(bv, NL, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      Mjoin(PATL,gemm)(AtlasNoTrans, TB, NRHS, NR, NL, none, Z0, ldz, B, ldt,
                       alpha, C, ldz);
      iret += trsm_recR(bv, NR, NRHS, one, T1, ldt, rincT, cincT, C, ldz);
      return(iret);
   }
   return(iret);
}

static unsigned int trsm_recL
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,trsmL_IP)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TA;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TA = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *A, *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TA = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TA = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T;
         A = T + NL*rincT;
         Z0 = Z;
         C = Z + (NL SHIFT);
         T1 = A + NL*cincT;
      }
      else                       /* LT or UN case */
      {
         T0 = T + NR*((ldt+1)SHIFT);
         T1 = T;
         A = T + NR*rincT;
         C = Z;
         Z0 = Z + (NR SHIFT);
      }
      iret = 2 + trsm_recL(bv, NL, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      if (bv&1)  /* Right case */
         Mjoin(PATL,gemm)(AtlasNoTrans, TA, NR, NRHS, NL, none, Z0, ldz, A, ldt,
                          alpha, C, ldz);
      else       /* Left case */
         Mjoin(PATL,gemm)(TA, AtlasNoTrans, NR, NRHS, NL, none, A, ldt, Z0, ldz,
                          alpha, C, ldz);
      iret += trsm_recL(bv, NR, NRHS, one, T1, ldt, rincT, cincT, C, ldz);
      return(iret);
   }
   return(iret);
}
void Mjoin(PATL,trsm)
(
   const enum ATLAS_SIDE  SD,
   const enum ATLAS_UPLO  UL,
   const enum ATLAS_TRANS TA,
   const enum ATLAS_DIAG  DI,
   ATL_CSZT               M,
   ATL_CSZT               N,
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
/*
 * Purpose
 * =======
 * ATL_trsm solves one of the matrix equations
 *    op( A ) * X = alpha * B,   or  X * op( A ) = alpha * B,
 *
 * where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 * non-unit, upper or lower triangular matrix and op( A ) is one of
 *    op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
 *
 * The matrix X is overwritten on B.
 */
{
   ATL_SZT incR, incC;
   ATL_UINT r, bv = (SD == AtlasRight) ? 1 : 0;
            /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */

   if (!M || !N)  /* if either array is of size 0 */
      return;     /* return as there is nothing to do */
   if (SCALAR_IS_ZERO(alpha))                   /* alpha == 0 means */
   {                           
      Mjoin(PATL,gescal)(M, N, alpha, B, ldb);  /* only need to scale B */
      return;
   }
   if (UL == AtlasUpper)
   {
      bv |= 2;
      incR = lda SHIFT;
      incC = 1 SHIFT;
   }
   else
   {
      incR = 1 SHIFT;
      incC = lda SHIFT;
   }
   #ifdef TCPLX
      if (TA == AtlasConjTrans)
         bv |= (8|4);
      else
         bv |= TA == (AtlasTrans) ? 4 : 0;
   #else
      bv |= (TA == AtlasNoTrans) ? 0:4;
   #endif
   bv |= (DI == AtlasNonUnit) ? 16 : 0;
/*
 * LEFT: op(A) * X = alpha * B, A is MxM, X is MxN, B is MxN
 */
   if (SD == AtlasLeft)
      r = trsm_recL(bv, M, N, alpha, A, lda, incR, incC, B, ldb);
   else
      r = trsm_recR(bv, N, M, alpha, A, lda, incR, incC, B, ldb);
#ifdef DEBUG
   printf("Solved with %u recursive calls.\n", r);
#endif
@skip   Mjoin(PATL,trsm_APR)(SD, UL, TA, DI, M, N, alpha, A, lda, B, ldb);
}
@ROUT ATL_trsm_IP
#include "atlas_misc.h"
#include "atlas_lvl3.h"
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 
#ifdef Right_
   #define ATL_trsm_IP Mjoin(PATL,trsmR_IP)
    #define ATL_sminfoN Mjoin(PATL,sminfoR_LN)
    #define ATL_sminfoT Mjoin(PATL,sminfoR_LT)
    #define ATL_utrsm_alloc Mjoin(PATL,utrsmR_alloc)
    #define INCR 1
#else
    #define ATL_trsm_IP Mjoin(PATL,trsmL_IP)
    #define ATL_sminfoN Mjoin(PATL,sminfoL_LN)
    #define ATL_sminfoT Mjoin(PATL,sminfoL_LT)
    #define ATL_utrsm_alloc Mjoin(PATL,utrsmL_alloc)
    #define INCR ldb
#endif
int ATL_trsm_IP
(
   ATL_UINT bv,  /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */
   ATL_CSZT               NT,  /* number of diagonals in triangle */
   ATL_CSZT               NR,  /* number of right hand sides */
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
{
   int RECUR;
   RECUR=0;
   #ifdef DEBUG
   printf("D=(%u,%u), SD=%c, UP=%c TA=%c DI=%c, alpha=%e\n", NT, NR, 
          (bv&1)?'R':'L', (bv&2)?'U':'L', (bv&4)?'T':'N', (bv&16)?'N':'U', 
          SVAL alpha);
   #endif
   if (NT == 1)
   {
      if (bv&16)   /* if non-unit, work to do, else nothing to do at M=1! */
      #ifdef TCPLX
      {
         TYPE inv[2], tmp;
         *inv = *A;
         tmp = A[1];
         inv[1] = (bv&8) ? -tmp : tmp;
         if (SCALAR_IS_ONE(alpha))
         {  CXINV(inv, inv); }
         else
            Mjoin(PATL,cplxdivide)(1, inv, (TYPE*)alpha, 1, inv, 1);
         Mjoin(PATL,scal)(NR, inv, B, INCR);
      }
      #else
         Mjoin(PATL,scal)(NR, alpha / *A, B, INCR);
      #endif
      else if (!SCALAR_IS_ONE(alpha))  /* unit may still need to scale! */
         Mjoin(PATL,scal)(NR, alpha, B, INCR);
   }
   else if (RECUR)  /* if told to */
      return(1);    /* do pure recursion */
#if 1     /* default case uses utrsm */
   else
   {
      ATL_UINT LN;
      void *vp;
      TYPE *diag, *T, *R, *w;
      #ifdef TCPLX
         enum ATLAS_TRANS TRANSA= ((bv&12)==12) ? AtlasConjTrans :  AtlasTrans;
      #else
         #define TRANSA AtlasTrans
      #endif
      void (*utrsm)(sminfo_t*,const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R, 
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx,
         TYPE *diag, TYPE *L, TYPE *RW, TYPE *w);
      sminfo_t si;
      int ATL_sminfoN
         (sminfo_t *ip, ATL_CUINT bv, ATL_CSZT N, ATL_CSZT R, 
          const SCALAR alpha, ATL_CSZT lda, ATL_CSZT ldb);
      int ATL_sminfoT
         (sminfo_t *ip, ATL_CUINT bv, ATL_CSZT N, ATL_CSZT R, 
          const SCALAR alpha, ATL_CSZT lda, ATL_CSZT ldb);
   
      LN = bv & 6;
      LN = (!LN) |(LN == 6);
      if (LN) /* Lower,NoTrans & Upper,Trans use LN case */
         ATL_sminfoN(&si, bv, NT, NR, alpha, lda, ldb);
      else              /* Upper,NoTrans & Lower,Trans use LT case */
         ATL_sminfoT(&si, bv, NT, NR, alpha, lda, ldb);
      if (NT > si.kb)
         return(2);
      #ifdef DEBUG
         fprintf(stderr, "NT=%u, kb=%u\n", NT, si.kb);
      #endif
      vp = ATL_utrsm_alloc(&si, NT, &diag, &T, &R, &w);
      if (!vp)
         return(1);
      utrsm = si.utrsm;
      if (bv & 1)
         utrsm(&si, (bv&16)?AtlasNonUnit:AtlasUnit, NR, NT, alpha, A, lda, 
               B, ldb, diag, T, R, w);
      else
         utrsm(&si, (bv&16)?AtlasNonUnit:AtlasUnit, NT, NR, alpha, A, lda, 
               B, ldb, diag, T, R, w);
      free(vp);
   }
#else
   else
   {
      enum ATLAS_TRANS TA;
      #ifdef TCPLX
         if ((bv&12)==12)
            TA == AtlasConjTrans;
         else
      #endif
      TA = (bv&4) ? AtlasTrans:AtlasNoTrans;
      #ifdef DEBUG
      printf("D=(%u,%u), UP=%c TA=%c DI=%c, alpha=%e\n", M, N, (bv&2)?'U':'L', 
             TA==AtlasTrans?'T':'N', (bv&16)?'N':'U', alpha);
      #endif
      Mjoin(PATL,trsm_APR)(AtlasLeft, (bv&2)?AtlasUpper:AtlasLower, TA,
         (bv&16)?AtlasNonUnit:AtlasUnit, M, N, alpha, A, lda, B, ldb);
   }
#endif      
   return(0);
}
@ROUT ATL_utrsmR_alloc
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_misc.h"
#include "atlas_amm.h"
void* Mjoin(PATL,utrsmR_alloc)
   (sminfo_t *ip, int N, TYPE **Diag, TYPE **L, TYPE **R, TYPE **w)
{
   const int MU=ip->mu, NU=ip->nu;
   int mb = (N + NU - 1) / NU;
   const int NUNU = NU*NU;
   const int MUNU = MU*NU;
   void *vp;
   vp = malloc( ATL_MulBySize( N + (NUNU*mb*(mb+1)/2) + mb*MUNU + 2*MUNU )
                           + 4*ATL_Cachelen);
   if (vp)
   {
      *Diag = ATL_AlignPtr(vp);
      *L = (*Diag) + (N SHIFT);
      *L = ATL_AlignPtr(*L);
      *R = (*L) + ((NUNU*mb*(mb+1)/2) SHIFT);
      *R = ATL_AlignPtr(*R);
      *w = (*R) + ((mb*MUNU) SHIFT);
      *w = ATL_AlignPtr(*w);
   }
   return(vp);
}
   @endextract
@ROUT ATL_utrsmL_alloc
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_misc.h"
#include "atlas_amm.h"
void* Mjoin(PATL,utrsmL_alloc)
   (sminfo_t*ip, int N, TYPE **Diag, TYPE **L, TYPE **R, TYPE **w)
{
   const int MU = ip->mu, NU=ip->nu;
   int mb = (N + MU - 1) / MU;
   const int MUMU = MU*MU;
   const int MUNU = MU*NU;
   void *vp;
   vp = malloc( ATL_MulBySize( N + (MUMU*mb*(mb+1)/2) + mb*MUNU + 2*MUNU )
                           + 4*ATL_Cachelen);
   if (vp)
   {
      *Diag = ATL_AlignPtr(vp);
      *L = (*Diag) + (N SHIFT);
      *L = ATL_AlignPtr(*L);
      *R = (*L) + ((MUMU*mb*(mb+1)/2) SHIFT);
      *R = ATL_AlignPtr(*R);
      *w = (*R) + ((mb*MUNU) SHIFT);
      *w = ATL_AlignPtr(*w);
   }
   return(vp);
}
   @endextract
@BEGINSKIP
   All TRSM microkernels variants are generated from this file.
   Written by Rakib Hasan, heavily modifed by R. Clint Whaley to work
   with new framework and to be separately compilable.
@ENDSKIP
@ROUT ATL_utrsmL_LT_UN ATL_utrsmL_LN_UT ATL_utrsmR_LT_UN ATL_utrsmR_LN_UT
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_misc.h"
#include "atlas_amm.h"
@ROUT ATL_utrsmL_LT_UN ATL_utrsmL_LN_UT `@define SD @L@`
@ROUT ATL_utrsmR_LT_UN ATL_utrsmR_LN_UT `@define SD @R@`
@skip #ifdef Conj_
@skip    #define IsConj 1
@skip #else
@skip    #define IsConj 0
@skip #endif

@ROUT ATL_utrsmL_LT_UN
#define ATL_ntrcopy ATL_ntrcopyLTUN
#define ATL_ntrsm ATL_ntrsmLT
#define ATL_ntrsm_RR ATL_ntrsmLT_RR
#ifdef Upper_
@skip   #define ATL_ntrcopy ATL_ntrcopyU
@skip   #define ATL_ntrsm ATL_ntrsmUN
@skip   #define ATL_ntrsm_RR ATL_ntrsmUN_RR
   void ATL_utrsmL_UN
#else
@skip   #define ATL_ntrcopy ATL_ntrcopyL
@skip   #define ATL_ntrsm ATL_ntrsmLT
@skip   #define ATL_ntrsm_RR ATL_ntrsmLT_RR
   void ATL_utrsmL_LT
#endif
   (sminfo_t *ip, const enum ATLAS_DIAG Diag, 
    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A, ATL_CSZT lda, 
    TYPE *X, ATL_CSZT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t r2a = ip->b2blk;
   cm2am_t l2a = ip->a2blk;
   ATL_CSZT ainc = ip->incA;
   const int IsTrans = (ainc == (1 SHIFT));
   const int IsConj = (ip->bv & 8) != 0;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int MUMU = MU*MU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   @BEGINSKIP
   #ifdef Trans_
      #define ainc 1
   #else
      #define ainc lda
   #endif
   @ENDSKIP
@skip   const int ainc = (TA != AtlasNoTrans) ? 1 : lda;
@skip   const int IsConj = (TA == AtlasConjTrans);
   TYPE *l, *x=X;
   int mb = (N + MU - 1) / MU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += NU, x += (NU SHIFT)*ldx)
   {
      int mu, nu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      nu = Mmin(nu, NU);
      mu = Mmin(MU, N);
      Ac += ((N - mu) SHIFT) * (lda+1);
      xc += ((N - mu) SHIFT);

      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
@skip         ATL_ntrcopy(IsConj, mu, Ac, lda, L, MU, d);
         ATL_ntrcopy(IsConj, IsTrans, mu, Ac, lda, L, MU, d);
      if (mu == MU)
      {
         if (!UnitAlpha) { ATL_nscal(nu, alpha, xc, ldx); }
         ATL_ntrsm(nu, d, L, MU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, MU, xc, ldx);
      }

      for (i=N-mu, mbi=1, l=L+(MUMU SHIFT); 
            i > 0; i -= MU, mbi++, l+=(MUMU SHIFT))
      {
         mu = Mmin(i, MU);
         Ac -= (mu SHIFT) * (lda+1);
         xc -= (mu SHIFT);
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mb-mbi)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*MUMU;
            iL = l;
            r2a(MU, nu, ONE, xc+(mu SHIFT), ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, mu, NONE, Ac+mu*ainc, lda, rL, iL);
            #ifndef USE_TRANS
               amm_b0(1, 1, N-i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, N-i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, N-i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, N-i, iL, rR, w+MUNU, 
                      l+(mbi SHIFT)*MUMU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, N-i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, N-i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, N-i, iR, rL, w+MUNU, 
                      RW+(mb-mbi-1)*MUNU, l+(mbi SHIFT)*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(MU, nu, ONE, xc+mu, ldx, RW+((mb-mbi)*MUNU));
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, mu, NONE, Ac+mu*ainc, lda, l);
            #ifndef USE_TRANS
               amm_b0(1, 1, N-i, l, RW+(mb-mbi)*MUNU, w, 
                     l+mbi*MUMU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, RW+(mb-mbi)*MUNU, l, w, 
                     RW+(mb-mbi-1)*MUNU, l+mbi*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * MUMU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + ((N-i) SHIFT);
         if (DoCopy)
@skip            ATL_ntrcopy(IsConj, mu, Ac, lda, l, MU, d);
            ATL_ntrcopy(IsConj, IsTrans, mu, Ac, lda, l, MU, d);
         if (mu == MU)
            ATL_ntrsm(nu, d, l, MU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, MU, xc, ldx);
      }
   }
}
@skip #undef ainc
@ROUT ATL_utrsmL_LN_UT
#define ATL_ntrcopy ATL_ntrcopyLNUT
#define ATL_ntrsm ATL_ntrsmLN
#define ATL_ntrsm_RR ATL_ntrsmLN_RR
#ifdef Upper_
@skip   #define ATL_ntrcopy ATL_ntrcopyU
@skip   #define ATL_ntrsm ATL_ntrsmUT
@skip   #define ATL_ntrsm_RR ATL_ntrsmUT_RR
@skip   #define ainc 1
   void ATL_utrsmL_UT
#else
@skip   #define ATL_ntrcopy ATL_ntrcopyL
@skip   #define ATL_ntrsm ATL_ntrsmLN
@skip   #define ATL_ntrsm_RR ATL_ntrsmLN_RR
@skip   #define ainc lda
   void ATL_utrsmL_LN
#endif
   (sminfo_t *ip, const enum ATLAS_DIAG Diag, 
    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A, ATL_CINT lda, 
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t l2a = ip->a2blk;
   cm2am_t r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   ATL_CSZT ainc = ip->incA;
   const int IsTrans = (ainc == (1 SHIFT));
   const int IsConj = (ip->bv & 8) != 0;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int MUMU = MU*MU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + MU - 1) / MU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += NU, x += (NU SHIFT)*ldx)
   {
      int mu, nu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      nu = Mmin(nu,NU);
      mu = Mmin(MU, N);

      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
@skip         ATL_ntrcopy(IsConj, mu, Ac, lda, L, MU, d);
         ATL_ntrcopy(IsConj, IsTrans, mu, Ac, lda, L, MU, d);
      if (mu == MU)
      {
         if (!UnitAlpha) { ATL_nscal(nu, alpha, xc, ldx); }
         ATL_ntrsm(nu, d, L, MU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, MU, xc, ldx);
      }

      for (i=mu, mbi=1, l=L+(MUMU SHIFT); 
            i < N; i += MU, mbi++, l+=(MUMU SHIFT))
      {
         mu = Mmin(N-i, MU);
         Ac += (MU SHIFT) * (lda+1);
         xc += (MU SHIFT);
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mbi-1)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*MUMU;
            iL = l;
            r2a(MU, nu, ONE, xc-(MU SHIFT), ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, mu, NONE, Ac-i*ainc, lda, rL, iL);
            iR = RW;
            rR = iR + iRWoff;
            #ifndef USE_TRANS
               amm_b0(1, 1, i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, i, iL, rR, w+MUNU, l+(mbi SHIFT)*MUMU, RW, w);
            #else
               amm_b0(1, 1, i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, i, iR, rL, w+MUNU, RW, l+(mbi SHIFT)*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(MU, nu, ONE, xc-MU, ldx, RW+(mbi-1)*MUNU);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, mu, NONE, Ac-i*ainc, lda, l);
            #ifndef USE_TRANS
               amm_b0(1, 1, i, l, RW, w, l+mbi*MUMU, RW, w);
            #else
               amm_b0(1, 1, i, RW, l, w, RW, l+mbi*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * MUMU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + (i SHIFT);
         if (DoCopy)
@skip            ATL_ntrcopy(IsConj, mu, Ac, lda, l, MU, d);
            ATL_ntrcopy(IsConj, IsTrans, mu, Ac, lda, l, MU, d);
         if (mu == MU)
            ATL_ntrsm(nu, d, l, MU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, MU, xc, ldx);
      }
   }
}
@ROUT
void Mjoin(PATL,utrsmLUN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasNoTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmLUT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmLUC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasConjTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}
#endif

void Mjoin(PATL,utrsmLLN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasNoTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmLLT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmLLC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasConjTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}
#endif

#ifdef NO_AMM_NAME
   void Mjoin(PATL,trsm)
      (const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo, 
       const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
       ATL_CINT N, ATL_CINT R, const SCALAR alpha, 
       const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx)
#else
   int Mjoin(PATL,utrsmKL)
      (const enum ATLAS_UPLO Uplo, 
       const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
       ATL_CINT N, ATL_CINT R, const SCALAR alpha, 
       const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx)
#endif
{
   const int UPPER = (Uplo == AtlasUpper);
   void *vp;
   TYPE *diag, *L, *RW, *w;
   vp = GetWorkspaceL(N, &diag, &L, &RW, &w);
   #ifndef NO_AMM_NAME
      if (!vp) return(-1);
   #endif
   if (!UPPER)
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,utrsmLLN)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      else if (TA == AtlasTrans)
         Mjoin(PATL,utrsmLLT)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      #ifdef TCPLX
         else /* (TA == AtlasConjTrans) */
            Mjoin(PATL,utrsmLLC)(Diag, N, R, alpha, A, lda, X, ldx, 
                  diag, L, RW, w);
      #endif
   }
   else
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,utrsmLUN)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      else if (TA == AtlasTrans)
         Mjoin(PATL,utrsmLUT)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
   #ifdef TCPLX
      else /* (TA == AtlasConjTrans) */
         Mjoin(PATL,utrsmLUC)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
   #endif
   }
   free(vp);
   #ifndef NO_AMM_NAME
      return(0);
   #endif
}
@ROUT ATL_utrsmR_LT_UN
#define ATL_ntrcopy ATL_ntrcopyLTUN
#define ATL_ntrsm ATL_ntrsmLT
#define ATL_ntrsm_RR ATL_ntrsmLT_RR
#ifndef Upper_
@skip   #define ATL_ntrcopy ATL_ntrcopyL
@skip   #define ATL_ntrsm ATL_ntrsmLT
@skip   #define ATL_ntrsm_RR ATL_ntrsmLT_RR
@skip   #define ainc lda
   void ATL_utrsmR_LT
#else
@skip   #define ATL_ntrcopy ATL_ntrcopyU
@skip   #define ATL_ntrsm ATL_ntrsmUN
@skip   #define ATL_ntrsm_RR ATL_ntrsmUN_RR
@skip   #define ainc 1
   void ATL_utrsmR_UN
#endif
   (sminfo_t *ip, const enum ATLAS_DIAG Diag,
    ATL_CINT R, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t l2a = ip->a2blk, r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   ATL_CSZT ainc = ip->incA;
   const int IsTrans = (ainc != (1 SHIFT));
   const int IsConj = (ip->bv & 8) != 0;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int NUNU = NU*NU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + NU - 1) / NU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += MU, x += (MU SHIFT))
   {
      int nu, mu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      mu = Mmin(mu, MU);
      nu = Mmin(NU, N);
      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
@skip         ATL_ntrcopy(IsConj, nu, Ac, lda, L, NU, d);
         ATL_ntrcopy(IsConj, IsTrans, nu, Ac, lda, L, NU, d);
      if (nu == NU)
      {
         if (!UnitAlpha) { ATL_nscal(mu, alpha, xc, ldx); }
         ATL_ntrsm(mu, d, L, NU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, NU, xc, ldx);
      }

      for (i=nu, mbi=1, l=L+(NUNU SHIFT); 
            i < N; i += NU, mbi++, l+=(NUNU SHIFT))
      {
         nu = Mmin(N-i, NU);
         Ac += (NU SHIFT) * (lda+1);
         xc += (NU SHIFT) * ldx;
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mbi-1)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*NUNU;
            iL = l;
            r2a(NU, mu, ONE, xc-(NU SHIFT)*ldx, ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, nu, NONE, Ac-i*ainc, lda, rL, iL);
            iR = RW;
            rR = iR + iRWoff;
            #ifdef USE_TRANS
               amm_b0(1, 1, i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, i, iL, rR, w+MUNU, l+(mbi SHIFT)*NUNU, RW, w);
            #else
               amm_b0(1, 1, i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, i, iR, rL, w+MUNU, RW, l+(mbi SHIFT)*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(NU, mu, ONE, xc-(NU*ldx), ldx, RW+(mbi-1)*MUNU);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
            {
               l2a(i, nu, NONE, Ac-i*ainc, lda, l);
            }
            #ifdef USE_TRANS
               amm_b0(1, 1, i, l, RW, w, l+mbi*NUNU, RW, w);
            #else
               amm_b0(1, 1, i, RW, l, w, RW, l+mbi*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * NUNU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + (i SHIFT);
         if (DoCopy)
@skip            ATL_ntrcopy(IsConj, nu, Ac, lda, l, NU, d);
            ATL_ntrcopy(IsConj, IsTrans, nu, Ac, lda, l, NU, d);
         if (nu == NU)
            ATL_ntrsm(mu, d, l, NU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, NU, xc, ldx);
      }
   }
}
@ROUT ATL_utrsmR_LN_UT
#define ATL_ntrcopy ATL_ntrcopyLNUT
#define ATL_ntrsm ATL_ntrsmLN
#define ATL_ntrsm_RR ATL_ntrsmLN_RR
#ifdef Upper_
@skip   #define ainc lda
@skip   #define ATL_ntrcopy ATL_ntrcopyU
@skip   #define ATL_ntrsm ATL_ntrsmUT
@skip   #define ATL_ntrsm_RR ATL_ntrsmUT_RR
   void ATL_utrsmR_UT
#else
@skip   #define ainc 1
@skip   #define ATL_ntrcopy ATL_ntrcopyL
@skip   #define ATL_ntrsm ATL_ntrsmLN
@skip   #define ATL_ntrsm_RR ATL_ntrsmLN_RR
   void ATL_utrsmR_LN
#endif
   (sminfo_t *ip, const enum ATLAS_DIAG Diag,
    ATL_CINT R, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t l2a = ip->a2blk, r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   ATL_CSZT ainc = ip->incA;
   const int IsTrans = (ainc != (1 SHIFT));
   const int IsConj = (ip->bv & 8) != 0;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int NUNU = NU*NU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + NU - 1) / NU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += MU, x += (MU SHIFT))
   {
      int nu, mu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      mu = Mmin(mu, MU);
      nu = Mmin(NU, N);
      Ac += ((N - nu) SHIFT) * (lda+1);
      xc += ((N - nu) SHIFT) * ldx;
      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
@skip         ATL_ntrcopy(IsConj, nu, Ac, lda, L, NU, d);
         ATL_ntrcopy(IsConj, IsTrans, nu, Ac, lda, L, NU, d);
      if (nu == NU)
      {
         if (!UnitAlpha) { ATL_nscal(mu, alpha, xc, ldx); }
         ATL_ntrsm(mu, d, L, NU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, NU, xc, ldx);
      }

      for (i=N-nu, mbi=1, l=L+(NUNU SHIFT); 
            i > 0; i -= NU, mbi++, l+=(NUNU SHIFT))
      {
         nu = Mmin(i, NU);
         Ac -= (nu SHIFT) * (lda+1);
         xc -= (nu SHIFT) * ldx;
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mb-mbi)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*NUNU;
            iL = l;
            r2a(NU, mu, ONE, xc+(nu SHIFT)*ldx, ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, nu, NONE, Ac+nu*ainc, lda, rL, iL);
            #ifdef USE_TRANS
               amm_b0(1, 1, N-i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, N-i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, N-i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, N-i, iL, rR, w+MUNU, 
                      l+(mbi SHIFT)*NUNU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, N-i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, N-i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, N-i, iR, rL, w+MUNU, 
                      RW+(mb-mbi-1)*MUNU, l+(mbi SHIFT)*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(NU, mu, ONE, xc+nu*ldx, ldx, RW+((mb-mbi)*MUNU));
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, nu, NONE, Ac+nu*ainc, lda, l);
            #ifdef USE_TRANS
               amm_b0(1, 1, N-i, l, RW+(mb-mbi)*MUNU, w, 
                     l+mbi*NUNU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, RW+(mb-mbi)*MUNU, l, w, 
                     RW+(mb-mbi-1)*MUNU, l+mbi*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * NUNU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + ((N-i) SHIFT);
         if (DoCopy)
@skip            ATL_ntrcopy(IsConj, nu, Ac, lda, l, NU, d);
            ATL_ntrcopy(IsConj, IsTrans, nu, Ac, lda, l, NU, d);
         if (nu == NU)
            ATL_ntrsm(mu, d, l, NU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, NU, xc, ldx);
      }
   }
}
@ROUT
void Mjoin(PATL,utrsmRUN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasNoTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmRUT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmRUC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasConjTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}
#endif

void Mjoin(PATL,utrsmRLN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasNoTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmRLT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmRLC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasConjTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}
#endif
@ROUT trsmsrch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 
#define ATL_WANT ILCM 1
#include "atlas_iopt.h"
#include "atlas_cache.h"
#include "atlas_genparse.h"
#include "atlas_mmtesttime.h"

#define TSM_RIGHT  0
#define TSM_UPPER  1
#define TSM_TRANSA 2
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -S [L/R] : search Left or Right TRSM\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *forceTrsmCases(char pre, int flag)
{
   ATL_mmnode_t *mb, *mp, *gb=NULL;

   gb = ReadMMFileWithPath(pre, "res", "gAMMRES.sum");
   if (flag&(1<<TSM_RIGHT))      /* Right case requires  N=K */
      mb = ReadMMFileWithPath(pre, "res", "ipnek.sum");
   else
      mb = ReadMMFileWithPath(pre, "res", "ipmek.sum");
/*
 * We know no candidate kernels satisfy all criteria, so search for one that
 * is generated, and we will then vary ku until it works
 */
   for (mp=mb; mp; mp = mp->next)
   {
      if (!mp->ID)
      {
         ATL_mmnode_t *gp;
         gp = CloneMMNode(mp);
         gp->next = gb;
         gb = gp;
      }
   }
   KillAllMMNodes(mb);
/*
 * Now, force these generated kernels to satisfy TRSM requirements
 */
#if 0
   for (mp=gb; mp; mp = mp->next)
   {
      int U, ku=mp->ku;
      mp->flag |= 1<<MMF_KRUNTIME;
      mp->flag &= ~(1<<MMF_KUISKB);
      U = (flag&(1<<TSM_RIGHT)) ? mp->nu : mp->mu;
      while ((U/ku)*ku != U)
         ku--;
      mp->ku = ku;
   }
#endif
/*
 * FIXED for kvec kernels
 */
   for (mp=gb; mp; mp = mp->next)
   {
      int U, ku=mp->ku;
      mp->flag |= 1<<MMF_KRUNTIME;
      mp->flag &= ~(1<<MMF_KUISKB);
      U = (flag&(1<<TSM_RIGHT)) ? mp->nu : mp->mu;
      if (mp->flag & (1<<MMF_KVEC))
      {
         unsigned int VL=mp->vlen;
         if (ku > VL)
         {
            assert(ku%VL == 0);
            ku = (ku/VL)*VL;
            if ((U/VL)*VL != U)
               ku = VL;
            else
               while ((U/ku)*ku != U)
                  ku -= VL;
         }
         else
            ku = VL;
      }
      else
      {
         while ((U/ku)*ku != U)
            ku--;
      }
      mp->ku = ku;
   }
/* 
 * Remove duplicate cases after forcing TRSM reqs, then make them TRSM kerns
 */
   mb = AddUniqueMMKernsToList(NULL, gb);
   KillAllMMNodes(gb);
   for (mp=mb; mp; mp = mp->next)
   {
      mp->blask = ATL_KTRSM;
      mp->flag = (mp->flag&(~MMF_MVSET))|MMF_MVDEF;
   }
   return(mb);
}

ATL_mmnode_t *getAllCandKerns(char pre, int flag)
{
   ATL_mmnode_t *mb, *mp;
   mb = ReadMMFileWithPath(pre, "res", "ipmek.sum");
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "ipnek.sum"));
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "ipgen.sum"));
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "ipmen.sum"));
   mp = AddUniqueMMKernsToList(NULL, mb);
   KillAllMMNodes(mb);
   mb = mp;
   while (mp)
   {
      ATL_mmnode_t *nxt = mp->next;
      int KILL;
      KILL = !(mp->flag & (1<<MMF_KRUNTIME));  /* kill compile-time K */
      KILL |= mp->flag & (1<<MMF_KUISKB);  /* kill fixed ku=KB kerns */
      if (flag&(1<<TSM_RIGHT))      /* Right case requires */
         KILL |= (mp->nu % mp->ku); /* nu a multiple of ku */
      else                          /* Left case requires */
         KILL |= (mp->mu % mp->ku); /* mu a multiple of ku */
      if (KILL)
         mb = KillMMNodeFromQ(mb, mp);
      else
      {
         mp->blask = ATL_KTRSM;
         mp->flag = (mp->flag&(~MMF_MVSET))|MMF_MVDEF;
      }
      mp = nxt;
   }
   if (!mb) /* no candidates! */
      mb = forceTrsmCases(pre, flag);
   assert(mb);
   return(mb);
}

char GetFlags(int nargs, char **args, int *FLG)
{
   char pre = 'd';
   int flg=0;
   int i;

   for (i=1; i < nargs; i++)
   {
      int wch, *ip, **ipp, TST=0;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'S':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'R' || wch == 'r')
           flg |= 1<<TSM_RIGHT;
        else
           flg &= ~(1<<TSM_RIGHT);
        break;
      case 'U':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'U' || wch == 'u')
           flg |= 1<<TSM_UPPER;
        else
           flg &= ~(1<<TSM_UPPER);
        break;
      case 'A':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'T' || wch == 't')
           flg |= 1<<TSM_TRANSA;
        else
           flg &= ~(1<<TSM_TRANSA);
        break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *FLG = flg;
   return(pre);
}

double timeTRSM(char pre, int flag, int B, int R, ATL_mmnode_t *mmp)
{
   double mfB = 0.0;
   int it;
   const int RIGHT=(flag&(1<<TSM_RIGHT));
   int tflag= ((RIGHT) ? 4:0);
   const char TA[2] = {'N', 'T'};

   if (flag&(1<<TSM_UPPER))
      tflag |= 16;
   if (flag&(1<<TSM_TRANSA))
      tflag |= 32;
   for (it=0; it < 2; it++)
   {
      const int tfl = tflag | ((it)?8:0);
      int DOIT, NR;
      const int TR = (RIGHT) ? !it : it;
      if (TR)
      {
         DOIT = (mmp->nu % mmp->ku) == 0;
         NR = (R > mmp->mu) ? (R/mmp->mu)*mmp->mu : R;
      }
      else
      {
         DOIT = (mmp->mu % mmp->ku) == 0;
         NR = (R > mmp->nu) ? (R/mmp->nu)*mmp->nu : R;
      }
      if (DOIT)
      {
         double mf;
         int blask = mmp->blask;
         int mvflags = mmp->flag;
         ATL_MMF_MVPUT(mmp->flag, 4);
         mmp->blask = ATL_KTRSM;
         mf = TimeMMKernel(0, tfl, mmp, pre, NR, NR, B, 1, 0, -1);
         mmp->blask = blask;
         mmp->flag = mvflags;
         printf("      ID=%d : B=%u, NRHS=%u U=(%2u,%2u,%2u) TRANS=%c, "
                "mf=%.2f\n", mmp->ID, B, R, mmp->mu, mmp->nu, mmp->ku, 
                TA[it], mf);
         if (mf > mfB)
         {
            mmp->TA = mmp->TB = it ? AtlasTrans : AtlasNoTrans;
            mfB = mmp->mflop[0] = mf;
         }
      }
   }
   return(mfB);
}

ATL_mmnode_t *timeAllTRSM(char pre, int flag, int B, int R, ATL_mmnode_t *mb)
/*
 * Times all TRSM in mb with kb=B and NRHS roughly R, returns pointer to
 * cloned node of best performing
 */
{
   double mfB=0.0;
   ATL_mmnode_t *mp, *mmB=NULL;
   const int RIGHT=(flag&(1<<TSM_RIGHT));

      printf("   FINDING BEST TRSM KERNEL B=(%u,%u):\n", B, R);
   for (mp=mb; mp; mp = mp->next)
   {
      double mf;
      mf = timeTRSM(pre, flag, B, R, mp);
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mp;
      }
   }
   if (!mmB)
   {
      printf("   NO CASE FOUND FOR B=(%u,%u)\n", B, R);
      return(NULL);
   }
   mmB = CloneMMNode(mmB);
   assert(mmB->mflop[0] == mfB);
   mmB->mbB = mmB->nbB = mmB->kbB = B;
   if (RIGHT)
      mmB->mbB = R;
   else
      mmB->nbB = R;
      
   printf(
      "   BEST CASE FOR B=(%u,%u): ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n",
          B, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku,
          (mmB->TA == AtlasTrans)?'T':'N', mfB);
   return(mmB);
}

ATL_mmnode_t *findBestU(char pre, int flag, int B, int R, int U)
/*
 * Finds the best case with ku=1, and either mu OR nu = U
 */
{
   ATL_mmnode_t *mmb, *mmp, *mmB=NULL;
   int mb, nb, transB=0;
   double mfB=0.0;
   const int RIGHT=(flag&(1<<TSM_RIGHT));

   mmp = mmb = ReadMMFileWithPath(pre, "res", "WORKING.sum");
   while (mmp)
   {
      ATL_mmnode_t *nxt=mmp->next;
      if ((mmp->mu != U && mmp->nu != U) || (U%(mmp->ku)) || 
          !FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
         mmb = KillMMNodeFromQ(mmb, mmp);
      mmp = nxt;
   }
   printf("\nTIMING U=%u CASES FOR B=%u, NRHS=%u:\n", U, B, R);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      int it;
      mmp->blask = ATL_KTRSM;
      mf = timeTRSM(pre, flag, B, R, mmp);
      if (mf > mfB)
      {
         mmB = mmp;
         mfB = mf;
         transB = (mmp->TA == AtlasTrans) ? 1:0;
      }
   }
   if (mmB)
   {
      mmb = RemoveMMNodeFromQ(mmb, mmB);
      mmB->mbB = mmB->kbB = mmB->nbB = B;
      if (RIGHT)
         mmB->mbB = R;
      else
         mmB->nbB = R;
      mmB->mflop[0] = mfB;
      mmB->TA = mmB->TB = transB;
      printf(
      "BEST U=%u CASE FOR B=%u,%u: ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n\n",
             U, B, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku, transB?'T':'N', mfB);
   }
   else
      printf("NO USER CASES FOUND FOR U=%u.\n\n", U);
   KillAllMMNodes(mmb);
   return(mmB);
}

void findBestTRSM(char pre, int flag)
{
   ATL_mmnode_t *bb;   /* blocking base det by left or right setting */
   ATL_mmnode_t *tb=NULL; /* trsm best case queue, 1 for each entry in opmek */
   ATL_mmnode_t *kb;   /* list of candidate gemm kernels to try */
   ATL_mmnode_t *bp, *mp;
   int R=1, maxB=1, BN, BNN;
   double mf;
   char fnout[16];

   sprintf(fnout, "trsm%c_%c%c.sum", (flag&(1<<TSM_RIGHT))?'R':'L',
           (flag&(1<<TSM_UPPER))?'U':'L',(flag&(1<<TSM_TRANSA))?'T':'N');
   tb = TimeMMFileWithPath(pre, "res", fnout, 0, 1, 0, 1, 0, -1);
   if (tb)
   {
      KillAllMMNodes(tb);
      return;
   }

   kb = getAllCandKerns(pre, flag);
   PrintMMNodes(stdout, kb);
/*
 * Get NB that we will tune TRSM for
 */
   if (flag & (1<<TSM_RIGHT))
      bb = ReadMMFileWithPath(pre, "res", "opnek.sum");
   else
      bb = ReadMMFileWithPath(pre, "res", "opmek.sum");
/*
 * Compute RHS (R) to use, and find maxNB we'll see
 */
   for (mp=kb; mp; mp = mp->next)
   {
      R = ATL_iLCM(R, mp->nu);
      R = ATL_iLCM(R, mp->mu);
   }
   for (mp=bb; mp; mp = mp->next)
   {
      maxB = Mmax(maxB, mp->kbB);
      R = ATL_iLCM(R, mp->nu);
      R = ATL_iLCM(R, mp->mu);
   }
   if (maxB > R)
      R = (maxB/R)*R;  /* NRHS to time */
   else
      R = maxB;
   BN = bb->kbB;
/*
 * This is commented out, because it is bringing in very slow kerns
 * and I don't want to hassle with new kerns showing up due to TRSM.
 * Once install is working, we'll extend so it can cause new amm to be
 * added, then we need to add a version of this that adds kerns only
 * when the perform well on small problems!
 */
   #if 0
/*
 * Find best user U=[1-3] cases, so we have kerns that can do very small
 * block factors w/o huge performance loss
 */
   mp = findBestU(pre, flag, bb->kbB, R, 1);
   if (mp)
   {
      mp->next = kb;
      kb = mp;
      mf = mp->mflop[0];
   }
   else
      mf = 0.0;
   if (bb->next)
   {
      BN = bb->next->kbB;
      if (bb->next->next)
         BNN = bb->next->next->kbB;
      else
         BNN = BN;
   }
   else
      BNN = BN;
   mp = findBestU(pre, flag, BN, R, 2);
   if (mp)
   {
      if (mp->mflop[0] > mf)
      {
         mf = mp->mflop[0];
         mp->next = kb;
         kb = mp;
      }
      else
          KillMMNode(mp);
   }
   mp = findBestU(pre, flag, BNN, R, 3);
   if (mp)
   {
      if (mp->mflop[0] > mf)
      {
         mp->next = kb;
         kb = mp;
      }
      else
          KillMMNode(mp);
   }
   #endif
/*
 * Now look thru block sizes, and pick best-performing
 */
   printf("FINDING BEST TRSM KERNEL FOR %u BLOCK FACTORS:\n", 
          ATL_CountNumberOfMMNodes(bb));
   for (bp=bb; bp; bp = bp->next)
   {
      BN = bp->kbB;
      double mfB = 0.0;
      ATL_mmnode_t *mmB=NULL;
      @BEGINSKIP
      printf("   FINDING BEST TRSM KERNEL B=(%u,%u):\n", BN, R);
      for (mp=kb; mp; mp = mp->next)
      {
         mf = timeTRSM(pre, flag, BN, R, mp);
         if (mf > mfB)
         {
            mfB = mf;
            mmB = mp;
         }
      }
      printf(
      "   BEST CASE FOR B=(%u,%u): ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n",
             BN, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku,
             (mmB->TA == AtlasTrans)?'T':'N', mfB);
      @ENDSKIP
      mmB = timeAllTRSM(pre, flag, BN, R, kb);
      assert(mmB);
      mmB->next = tb;
      tb = mmB;
   }
   tb = ReverseMMQ(tb);
   printf("\nBEST CASES:\n");
   PrintMMNodes(stdout, tb);
   WriteMMFileWithPath(pre, "res", fnout, tb);
   KillAllMMNodes(tb);
   KillAllMMNodes(bb);
   KillAllMMNodes(kb);
}

int main(int nargs, char **args)
{
   char pre;
   int flag;

   pre = GetFlags(nargs, args, &flag);
   findBestTRSM(pre, flag);
   return(0);
}
@ROUT trsmgen
/*
 * Actually generates TRSM micro & nano kernels and their Makefile, and
 * moves this to BLDdir/src/blas/ukernel/<pre>UTRSM
 * Actual performance data is handled by views.
 */
#include "atlas_mmgen.h"
#include "atlas_type.h"
ATL_mmnode_t *allT2bv(ATL_mmnode_t *mp, unsigned long *lp)
{
   unsigned long bv=0;
   unsigned int n;
   assert(sizeof(long) >= ATL_PSIZE);
   for (n=0; mp && n < (ATL_PSIZE<<3); n++, mp=mp->next)
      if (mp->TA == AtlasTrans && mp->TB == AtlasTrans)
         bv |= (1L<<n);

   *lp = bv;
   return(mp);
}
void GenTrsmALLT
   (char pre, char sd, char up, char ta, FILE *fp, ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp;
   unsigned long flg=0;
   int k, L, n, ALL1=1, ALL0=1;

   for (mp=mb, n=0; mp; mp = mp->next, n++)
   {
      if (mp->TA == AtlasTrans && mp->TB == AtlasTrans)
         ALL0 = 0;
      else
         ALL1 = 0;
   }
   if (ALL0)
      fprintf(fp, "#define ATL_trsm%c_%c%c_allT(i_) 0\n", sd, up, ta);
   else if (ALL1)
      fprintf(fp, "#define ATL_trsm%c_%c%c_allT(i_) 1\n", sd, up, ta);
   else
   {
      mp = allT2bv(mb, &flg);
      if (!mp) /* only 1 constant needed */
         fprintf(fp, "#define ATL_trsm%c_%c%c_allT(i_) ((0x%lxL>>(i_))&1)\n", 
                 sd, up, ta, flg);
      else
      {
         int ne = (ATL_PSIZE<<3);
         ATL_mmnode_t *cp;
         for (cp=mb, n=0; cp; cp = cp->next, n++);
         ne = (n+ne-1)/ne;
         fprintf(fp, "#ifdef ATL_DECL_\n   const ATL_iptr_t ATL_UTRSM_ALLT[%u]="
                 "{0x%lxL", ne, flg);
         do
         {
            mp = allT2bv(mp, &flg);
            fprintf(fp, ",0x%lxL", flg);
         }
         while(mp);
         fprintf(fp, "};\n#else\n   extern const ATL_iptr_t ATL_UTRSM_ALLT[%u];"
                 "\n#endif\n", ne);
         for (ne=(ATL_PSIZE<<3), n=0; (ne^(1L<<n)); n++);
         n++;
         fprintf(fp, "#define ATL_trsm%c_%c%c_allT(i_) \\\n", sd, up, ta);
         fprintf(fp, "   ((ATL_UTRSM_ALLT[((i_)>>%u)]>>((i_)-"
                 "(((i_)>>%u)<<%u)))&1)\n", n, n, n);
      }
   }
   fprintf(fp, "#ifndef ATL_trsm_allT\n");
   fprintf(fp, "   #define ATL_trsm_allT ATL_trsm%c_%c%c_allT\n",
           sd, up, ta);
   fprintf(fp, "#endif\n");
}

char *GetTrsmDecor(char pre, char sd, char up, char ta, ATL_mmnode_t *mp)
{
   static char fn[64];
   char ALLT = (mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T':'N';
   if (ALLT == 'T')
      sprintf(fn, "%c_%c%c%ux%u%c", sd, up, ta, mp->nu, mp->mu, ALLT);
   else
      sprintf(fn, "%c_%c%c%ux%u%c", sd, up, ta, mp->mu, mp->nu, ALLT);
   return(fn);
}

void genTrsmHead(char pre, char *outd, char sd, char up, char ta,
                 ATL_mmnode_t *mb, ATL_mmnode_t *ub)
{
   char *of;
   FILE *fp;
   ATL_mmnode_t *mp;
   int k, L, n, muoff, nuoff, nxtoff, MULMU;
   L = strlen(outd) + 24;
   of = malloc(L);
   assert(of);

   k = sprintf(of, "%s/atlas_%cutrsm%c_%c%c.h", outd, pre, sd, up, ta);
   assert(k<L);
   fp = fopen(of, "w");
   assert(fp);
   fprintf(fp, "#ifndef ATLAS_%cTRSM%c_%c%c_H\n", 
           toupper(pre), toupper(sd), toupper(up), toupper(ta));
   fprintf(fp, "   #define ATLAS_%cTRSM%c_%c%c_H 1\n\n", 
           toupper(pre), toupper(sd), toupper(up), toupper(ta));

   fprintf(fp, "#include \"atlas_amm.h\"\n");
   GenTrsmALLT(pre, sd, up, ta, fp, mb);
   fprintf(fp, "/*\n * TRSM microkernel prototypes\n */\n");
   for (mp=ub; mp; mp = mp->next)
   {
      char *nm;
      nm = GetTrsmDecor(pre, sd, up, ta, mp);
      fprintf(fp, "void ATL_%cutrsm%s\n", pre, nm);
      fprintf(fp, "   (sminfo_t *ip, const enum ATLAS_DIAG Diag,\n"
              "    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A,"
              " ATL_CINT lda,\n    TYPE *X, ATL_CINT ldx, TYPE *diag, "
              "TYPE *L, TYPE *RW, TYPE *w);\n");
   }
   fprintf(fp, "\n#ifndef ATL_NOLOOKUP\n");
   fprintf(fp, "#ifndef ATL_findutrsm\n");
   fprintf(fp, "   #define ATL_findutrsm ATL_findutrsm%c_%c%c\n", sd, up, ta);
   fprintf(fp, "#endif\n");
   fprintf(fp, "static INLINE void *ATL_findutrsm%c_%c%c(ATL_UINT ALLT, "
           "ATL_UINT mu, ATL_UINT nu)\n", sd, up, ta);
   fprintf(fp, "{\n");
   fprintf(fp, "   void *vp=NULL;\n");
   fprintf(fp, "\n");
   ub = CloneMMQueue(ub);
   muoff = GetOffset(&ub->mu, ub);
   nuoff = GetOffset(&ub->nu, ub);
   nxtoff = GetOffset(&mb->next, mb);
   ub = SortListByIval_G2L(ub, nxtoff, muoff);
   k = ub->mu;
   for (mp=ub->next; mp && mp->mu == k; mp = mp->next);
   MULMU = (mp != NULL);
   if (MULMU)
      fprintf(fp, "   switch(mu)\n   {\n");
   while(ub)
   {
      char *nm;
      int mu=ub->mu, nu=ub->nu;
      int n;
      ATL_mmnode_t *mub, *last;

      if (MULMU)
         fprintf(fp, "   case %u:\n", mu);
/*
 *    Remove all identical mu kernels from queue
 */
      last = mub = ub;
      for (n=1,mp=ub->next; mp && mp->mu == mu; mp = mp->next, n++)
         last = mp;
      ub = mp;
      last->next = NULL;
/*
 *    Find if there's another utrsm with same mu & nu, then one must be
 *    using transpose case while other does not
 */
      mp = FindNodeWithIval(mub->next, nxtoff, nuoff, mub->nu);
      if (mp)
      {
         mub = RemoveNodeFromList(mub, mp, nxtoff);
         n--;
      }
      nm = GetTrsmDecor(pre, sd, up, ta, mub);
      if (n == 1)  /* is there only 1 kernel with this mu? */
      {
         if (mp)
         {
            int ALLT = (mub->TA == AtlasTrans && mub->TB == AtlasTrans);
            fprintf(fp, "         vp = (%s) ? ATL_%cutrsm%s :",
                    ALLT ? "ALLT":"!ALLT", pre, nm);
            nm = GetTrsmDecor(pre, sd, up, ta, mp);
            fprintf(fp, " ATL_%cutrsm%s;\n", pre, nm);
            KillMMNode(mp);
         }
         else
            fprintf(fp, "         vp = ATL_%cutrsm%s;\n", pre, nm);
         mub = KillMMNode(mub);
      }
      else
      {
         n = CountListEntries(mub, nxtoff);
         if (n > 1)
            fprintf(fp, "      switch(nu)\n      {\n");
         while(mub)
         {
            if (n > 1)
               fprintf(fp, "      case %u:\n", mub->nu);
            if (mp)
            {
               int ALLT = (mub->TA == AtlasTrans && mub->TB == AtlasTrans);
               fprintf(fp, "         vp = (%s) ? ATL_%cutrsm%s :",
                       ALLT ? "ALLT":"!ALLT", pre, nm);
               nm = GetTrsmDecor(pre, sd, up, ta, mp);
               fprintf(fp, " ATL_%cutrsm%s;\n", pre, nm);
               KillMMNode(mp);
            }
            else
               fprintf(fp, "         vp = ATL_%cutrsm%s;\n", pre, nm);
            if (n > 1)
               fprintf(fp,    "         break;\n");
            mub = KillMMNode(mub);
            if (mub)
            {
               nm = GetTrsmDecor(pre, sd, up, ta, mub);
               mp = FindNodeWithIval(mub->next, nxtoff, nuoff, mub->nu);
               if (mp)
                  mub = RemoveNodeFromList(mub, mp, nxtoff);
            }
         }
         if (n > 1)
            fprintf(fp, "      } /* end switch on nu */\n");
      }
      if (MULMU)
         fprintf(fp, "      break;\n");
   }
   if (MULMU)
      fprintf(fp, "   } /* end switch on mu */\n");
   fprintf(fp, "   return(vp);\n");
   fprintf(fp, "} /* end findUtrsm */\n");
   fprintf(fp, "#endif /* end no-lookup guard */\n");

   fprintf(fp, "\n#endif /* end multiple inclusion guard */\n");
   fclose(fp);
   free(of);
}

ATL_mmnode_t *getUniqueTrsmCases(char pre, ATL_mmnode_t *ub, ATL_mmnode_t *mb)
/*
 * Adds all cases of unique cases in mb to ub; mb nodes are cloned, so
 * mb is unchanged.  ub is already assumed unique on entry, so it is only
 * added to.
 * RETURNS: possibly changed ub
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      int mu=mp->mu, nu=mp->nu;
      char ALLT=(mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T' : 'N';
      assert(mp->TA == mp->TB);
      for (p=ub; p; p = p->next)
      {
         int mu0=p->mu, nu0=p->nu;
         char ALLT0=(p->TA == AtlasTrans && p->TB == AtlasTrans) ? 'T' : 'N';
         if (mu0 == mu && nu0 == nu && ALLT0 == ALLT) /* already seen this */
            break;                                    /* case so stop */
      }
      if (p == NULL)  /* this case not already in unique queueu */
      {
         p = CloneMMNode(mp);
         p->next = ub;
         ub = p;
      }
   }
   return(ub);
}

ATL_mmnode_t *GenMicroTrsm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp, *ub;
   int *mus, *nus;
   char *fn;
   int i, L;
   int nmu, nnu;
   char *ln;

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);
   ub = getUniqueTrsmCases(pre, NULL, mb);
   for (mp=ub; mp; mp = mp->next)
   {
      int mu=mp->mu, nu=mp->nu;
      char *nm;
      char ALLT=(mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T' : 'N';

      assert(mu > 0 && nu > 0 && mu < 1000 && nu < 1000);
      nm = GetTrsmDecor(pre, sd, up, ta, mp);
      i = sprintf(ln, "make gen_utrsm tALL=%c mu=%u nu=%u sd=%c up=%c ta=%c"
                  " cx=\"%s\" cnj=N rt=\"%s/ATL_utrsm%s.c\"", 
                  ALLT, mu, nu, sd, up, ta, (pre == 'c' || pre == 'z')?"c":"",
                  outd, nm);
      assert(i < L);
      assert(!Sys2File(ln, NULL));
   }
   free(ln);
   return(ub);
}

void GenMakeTrsm(char pre, char *outd, char up, char *sds, char *tas, 
                 ATL_mmnode_t **MBs)
{
   int k, i;
   FILE *fp;
   char *fn, *typ, *comp;

   k = strlen(outd) + 10;
   fn = malloc(k);
   assert(fn);
   i = sprintf(fn, "%s/Makefile", outd);
   fp = fopen(fn, "w");
   assert(fp);
   free(fn);
   fprintf(fp, "include ../Make.inc\n\n");

   fprintf(fp, "lib : %clib.grd\n", pre);
   fprintf(fp, "all : %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n\n", pre);

   fprintf(fp, "obj = ");
   if (pre == 'c' || pre == 's')
      comp = "$(SKC)";
   else
      comp = "$(DKC)";
   if (pre == 'z')
      typ = "DCPLX";
   else if (pre == 'c')
      typ = "SCPLX";
   else if (pre == 's')
      typ = "SREAL";
   else
      typ = "DREAL";
   for (k=0; k < 2; k++)
   {
      int s;
      for (i=s=0; s < 2; s++)
      {
         char sd=sds[s];
         int it;

         for (it=0; it < 2; it++)
         {
            ATL_mmnode_t *mp;
            char ta = tas[it];
            const int NCNJ = (ta == 'T' && (pre == 'c' || pre == 'z')) ? 2:1;

            for (mp=MBs[i++]; mp; mp=mp->next)
            {
               int c;
               for (c=0; c < NCNJ; c++)
               {
                  char *nm;
                  nm = GetTrsmDecor(pre, sd, up, ta, mp);
                  if (c)
                     nm[3] = 'H';
                  if (!k)
                     fprintf(fp, "\\\n      ATL_%cutrsm%s.o ", pre, nm);
                  else
                  {
                     fprintf(fp, "ATL_%cutrsm%s.o : ", pre, nm);
                     if (c)
                        nm[3] = 'T';
                     fprintf(fp, "ATL_utrsm%s.c $(deps)\n", nm);
                     if (c)
                        fprintf(fp, 
                "\t%s $(%cKCFLAGS) -c -o $@ -D%s=1 -DConj_=1 ATL_utrsm%s.c\n",
                           comp, pre, typ, nm);
                     else
                        fprintf(fp, 
                           "\t%s $(%cKCFLAGS) -c -o $@ -D%s=1 ATL_utrsm%s.c\n", 
                                comp, pre, typ, nm);
                  }
               }
            }
         }
      }
      if (!k)
      {
         fprintf(fp, "\n\n%clib : %clib.grd\n", pre, pre);
         fprintf(fp, "%clib.grd : $(obj)\n", pre);
         fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
         fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n\ttouch %clib.grd\n\n", pre);
      }
   }
   fclose(fp);
}

void GenAllTrsm(char pre, char *outd)
{
   int L, i, s;
   char sds[2] = {'L', 'R'};
   char tas[2] = {'N', 'T'};
   char up='L';
   char *od;
   char fn[16];
   ATL_mmnode_t *MBs[4];
/*
 * Delete and the re-create <pre>UTRSM subdir
 */
   L = strlen(outd) + 8 + 7;
   od = malloc(L);
   assert(od);
   i = sprintf(od, "rm -rf %s/%cUTRSM", outd, pre);
   assert(i < L);
   Sys2File(od, NULL);
   od[0]='m'; od[1]='k'; od[2]='d'; od[3]='i'; od[4]='r'; od[5]=' ';
   assert(!Sys2File(od, NULL));
   strcpy(fn, "trsmS_LN.sum");

   for (i=s=0; s < 2; s++)
   {
      char sd=sds[s];
      int it;

      for (it=0; it < 2; it++)
      {
         char ta = tas[it];
         ATL_mmnode_t *mb;
         fn[4] = sd;
         fn[7] = ta;
         mb = ReadMMFileWithPath(pre, "res", fn);
         MBs[i] = GenMicroTrsm(pre, od+7, sd, up, ta, mb);
         genTrsmHead(pre, od+7, sd, 'L', ta, mb, MBs[i]);
         KillAllMMNodes(mb);
         i++;
      }
   }
   GenMakeTrsm(pre, od+7, up, sds, tas, MBs);
   for (i=0; i < 4; i++)
      KillAllMMNodes(MBs[i]);
   free(od);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr,
"This will create the <pre>UTRSM subdir in <outdir>, and populate it with\n"
"all utrsm kernels and their Makefile.\n");
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -o <path>: what directory to output all files to?\n");
   fprintf(stderr, "   -p [s,d]: set type/precision prefix (d) \n"
           "      s/d will generate for complex (c/z) as well\n");

   exit(ierr ? ierr : -1);
}

char *GetFlags(int nargs, char **args, char *PRE)
{
   FILE *fpin=stdin;
   ATL_mmnode_t *mb=NULL, *bkb=NULL, *mp;
   char *outd=NULL;
   int i;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         outd = DupString(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!outd)
      outd = DupString("tmp");

   *PRE = pre;
   return(outd);
}

int main(int nargs, char **args)
{
   char *outd;
   char pre;
   outd = GetFlags(nargs, args, &pre);
   GenAllTrsm(pre, outd);
   free(outd);
   return(0);
}
@ROUT !
